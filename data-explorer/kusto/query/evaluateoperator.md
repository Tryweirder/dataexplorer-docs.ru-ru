---
title: Оператор Evaluate подключаемого модуля — Azure обозреватель данных | Документация Майкрософт
description: В этой статье описывается оператор Evaluate подключаемого модуля в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: alexans
ms.service: data-explorer
ms.topic: reference
ms.date: 10/30/2019
ms.openlocfilehash: dc7e410b79ad73c1ba9fa807142177f4270b7dfa
ms.sourcegitcommit: 3dfaaa5567f8a5598702d52e4aa787d4249824d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/05/2020
ms.locfileid: "87803120"
---
# <a name="evaluate-operator-plugins"></a>Подключаемые модули оператора evaluate

Вызывает расширение запроса на стороне службы (подключаемый модуль).

`evaluate`Оператор является табличным оператором, который предоставляет возможность вызывать расширения языка запросов, известные как **подключаемые модули**. Подключаемые модули можно включать или отключать (в отличие от других языковых конструкций, которые всегда доступны) и не привязаны к реляционной природе языка (например, они могут не иметь заранее определенной статически определяемой схемы вывода).

> [!NOTE]
> * Синтаксически, `evaluate` ведет себя аналогично [оператору Invoke](./invokeoperator.md), который вызывает табличные функции.
> * Подключаемые модули, предоставляемые оператором Evaluate, не привязаны к обычным правилам выполнения запросов или вычисления аргументов.
> * Определенные подключаемые модули могут иметь определенные ограничения. Например, подключаемые модули, схема вывода которых зависит от данных (например, [bag_unpack подключаемый модуль](./bag-unpackplugin.md) и [подключаемый модуль Pivot](./pivotplugin.md)), нельзя использовать при выполнении запросов между кластерами.

## <a name="syntax"></a>Синтаксис 

[*T* `|` ] `evaluate` [ *евалуатепараметерс* ] *PluginName* `(` [*PluginArg1* [ `,` *PluginArg2*]...`)`

## <a name="arguments"></a>Аргументы

* *T* — это необязательный табличный ввод для подключаемого модуля. (Некоторые подключаемые модули не принимают входные данные и работают в качестве источника табличных данных.)
* *PluginName* — это обязательное имя вызываемого подключаемого модуля.
* *PluginArg1*,... являются необязательными аргументами для подключаемого модуля.
* *евалуатепараметерс*: ноль или более (разделенных пробелами) параметров в виде значения *имени* `=` *Value* , определяющего поведение операции вычисления и плана выполнения. Каждый подключаемый модуль может по-разному реагировать на обработку каждого параметра. Конкретные действия см. в документации по каждому подключаемому модулю.  

## <a name="parameters"></a>Параметры

Поддерживаются следующие параметры: 

  |Имя                |Значения                           |Описание                                |
  |--------------------|---------------------------------|-------------------------------------------|
  |`hint.distribution` |`single`, `per_node`, `per_shard`| [Указания по распространению](#distribution-hints) |
  |`hint.pass_filters` |`true`, `false`| Разрешить `evaluate` оператору транзитировать все совпадающие фильтры перед подключаемым модулем. Фильтр считается "соответствующим", если он ссылается на столбец, существующий перед `evaluate` оператором. По умолчанию: `false` |
  |`hint.pass_filters_column` |*column_name*| Разрешить оператору подключаемого модуля сквозные фильтры, ссылающиеся на *column_name* перед подключаемым модулем. Параметр может использоваться несколько раз с разными именами столбцов. |

## <a name="distribution-hints"></a>Указания по распространению

Указания по распространению. Укажите, как будет распределяться выполнение подключаемого модуля по нескольким узлам кластера. Каждый подключаемый модуль может реализовать другую поддержку распределения. В документации по подключаемому модулю указываются параметры распространения, поддерживаемые подключаемым модулем.

Возможные значения:

* `single`: Один экземпляр подключаемого модуля будет выполняться по всем данным запроса.
* `per_node`: Если запрос до того, как вызов подключаемого модуля распределяется между узлами, экземпляр подключаемого модуля будет выполняться на каждом узле по содержащимся в нем данным.
* `per_shard`: Если данные перед вызовом подключаемого модуля распределяются по сегментам, то экземпляр подключаемого модуля будет выполняться в каждом сегменте данных.
