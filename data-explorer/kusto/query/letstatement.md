---
title: Инструкция Let — Azure обозреватель данных
description: В этой статье описывается инструкция let в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.openlocfilehash: c2e21f0b41f34b469e409109a2586f3e5fd98fa5
ms.sourcegitcommit: 733bde4c6bc422c64752af338b29cd55a5af1f88
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/13/2020
ms.locfileid: "83271474"
---
# <a name="let-statement"></a>Инструкция let

Инструкции Let привязывают имена к выражениям. Для оставшейся части области, в которой отображается инструкция let (глобальная область или в области тела функции), имя можно использовать для ссылки на связанное с ним значение. Если это имя ранее было привязано к другому значению, используется привязка инструкции Let "самый дальний".

Инструкции Let улучшают модульность и повторное использование, так как позволяют одному из них разбивать потенциально сложное выражение на несколько частей, каждое из которых привязывается к имени с помощью инструкции Let и объединяет их вместе. Они также могут использоваться для создания определяемых пользователем функций и представлений (выражений по таблицам, результаты которых выглядят как новая таблица).

Имена, связанные инструкциями let, должны быть допустимыми именами сущностей.

Выражения, связанные операторами let, могут быть:
* Скалярного типа
* Табличного типа
* Определяемые пользователем функции (лямбда-выражения)

**Синтаксис**

`let`*Имя* `=` *Скаларекспрессион*  |  *Табуларекспрессион*  |  *Функтиондефинитионекспрессион*

* *Имя*. имя для привязки. Имя должно быть допустимым именем сущности, а также запрещенным экранированием имен сущностей (например, `["Name with spaces"]` ). 
* *Скаларекспрессион*: выражение с скалярным результатом, значение которого будет привязано к имени. Например, `let one=1;`.
* *Табуларекспрессион*: выражение с табличным результатом, значение которого будет привязано к имени. Например, `Logs | where Timestamp > ago(1h)`.
* *Функтиондефинитионекспрессион*: выражение, возвращающее лямбда (Объявление анонимной функции), которое должно быть привязано к имени.
  Например, `let f=(a:int, b:string) { strcat(b, ":", a) }`.

Лямбда-выражения имеют следующий синтаксис:

[ `view` ] `(` [*Табулараргументс*] [ `,` ] [*скалараргументс*] `)` `{` *функтионбоди*`}`

`TabularArguments`-[*Табулараргнаме* `:` `(` [*атрнаме* `:` *атртипе*] [ `,` ...] `)` ] [`,` ... ] [`,`]

 или:-[*табулараргнаме* `:` `(` `*` `)` ]

`ScalarArguments`-[*Аргнаме* `:` *аргтипе*] [ `,` ...]

* `view`может использоваться только в лямбда-выражении без параметров (без аргументов) и указывает, что связанное имя будет включаться, если "все таблицы" являются запросами (например, при использовании `union *` ).
* *Табулараргументс* — это список формальных аргументов табличного выражения.
  Каждый аргумент имеет следующее:
  * *Табулараргнаме* — имя формального табличного аргумента. Затем имя может появиться в *функтионбоди* и привязано к определенному значению при вызове лямбда-выражения. 
  * Определение схемы таблицы — список атрибутов с их типами (Атрнаме: Атртипе).
  Табличное выражение, используемое при вызове лямбда-выражения, должно иметь все эти атрибуты с соответствующими типами, но не ограничивается этими атрибутами. 
  в качестве табличного выражения можно использовать "(*)". В этом случае любое табличное выражение можно использовать в лямбда-вызове, и ни один из его столбцов не может быть получен в лямбда-выражении.
  Все табличные аргументы должны располагаться перед скалярными аргументами.
* *Скалараргументс* — это список формальных скалярных аргументов. 
  Каждый аргумент имеет следующее:
  * *Аргнаме* — имя формального скалярного аргумента. Затем имя может появиться в *функтионбоди* и привязано к определенному значению при вызове лямбда-выражения.  
  * *Аргтипе* — тип формального скалярного аргумента. В настоящее время в качестве типа лямбда-аргумента поддерживаются только следующие типы: `bool` , `string` ,,,, `long` `datetime` `timespan` `real` и `dynamic` (и псевдонимы для этих типов).

**Несколько и вложенные инструкции Let**

С разделителем между ними можно использовать несколько инструкций Let `;` , как показано в следующем примере.
Последняя инструкция должна быть допустимым выражением запроса: 

```kusto
let start = ago(5h); 
let period = 2h; 
T | where Time > start and Time < start + period | ...
```

Вложенные инструкции Let разрешены и могут использоваться внутри лямбда-выражения.
Операторы Let и аргументы видимы в текущей и внутренней области тела функции.

```kusto
let start_time = ago(5h); 
let end_time = start_time + 2h; 
T | where Time > start_time and Time < end_time | ...
```

**Примеры**

### <a name="using-let-to-define-constants"></a>Использование let для определения констант

В следующем примере имя привязывается `x` к скалярному литералу `1` , а затем используется в операторе табличного выражения:

```kusto
let x = 1;
range y from x to x step x
```

Тот же пример, но в данном случае имя инструкции Let указывается с помощью параметра `['name']` понятие:

```kusto
let ['x'] = 1;
range y from x to x step x
```

Еще один пример, в котором используется Let для скалярных значений:

```kusto
let n = 10;  // number
let place = "Dallas";  // string
let cutoff = ago(62d); // datetime
Events 
| where timestamp > cutoff 
    and city == place 
| take n
```

### <a name="using-multiple-let-statements"></a>Использование нескольких инструкций Let

В следующем примере определяются два оператора let, где одна инструкция ( `foo2` ) использует другую ( `foo1` ).

```kusto
let foo1 = (_start:long, _end:long, _step:long) { range x from _start to _end step _step};
let foo2 = (_step:long) { foo1(1, 100, _step)};
foo2(2) | count
// Result: 50
```

### <a name="using-materialize-function"></a>Использование материализации Function

[`materialize`](materializefunction.md)функция позволяет кэшировать результаты вложенного запроса во время выполнения запроса. 

<!-- csl: https://help.kusto.windows.net:443/Samples -->
```kusto
let totalPagesPerDay = PageViews
| summarize by Page, Day = startofday(Timestamp)
| summarize count() by Day;
let materializedScope = PageViews
| summarize by Page, Day = startofday(Timestamp);
let cachedResult = materialize(materializedScope);
cachedResult
| project Page, Day1 = Day
| join kind = inner
(
    cachedResult
    | project Page, Day2 = Day
)
on Page
| where Day2 > Day1
| summarize count() by Day1, Day2
| join kind = inner
    totalPagesPerDay
on $left.Day1 == $right.Day
| project Day1, Day2, Percentage = count_*100.0/count_1


```

|День 1|День 2|Процент|
|---|---|---|
|2016-05-01 00:00:00.0000000|2016-05-02 00:00:00.0000000|34.0645725975255|
|2016-05-01 00:00:00.0000000|2016-05-03 00:00:00.0000000|16.618368960101|
|2016-05-02 00:00:00.0000000|2016-05-03 00:00:00.0000000|14.6291376489636|
