---
title: Препятствуйте заявлению - Проводник данных Azure (ru) Документы Майкрософт
description: В этой статье описывается заявление Let в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.openlocfilehash: 890a6e21400048031e4ebd3df9749b6c47803e71
ms.sourcegitcommit: 653bfb3edf32553c52ef36b339c8b80713a601b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81524452"
---
# <a name="let-statement"></a>Инструкция let

Пусть операторы связывают имена с выражениями. Для остальной части области, в которой отображается заявление let (глобальная область или область функционального органа), имя может быть использовано для обозначения его связанного значения. Если это имя ранее было привязано к другому значению, используется привязка "внутреннее" допустимое значение оператора.

Пусть операторы улучшат модульность и повторное использование, так как они позволяют разбить потенциально сложное выражение на несколько частей, каждая из которых связана с именем через оператор Let, и составить их вместе. Они также могут использоваться для создания пользовательских функций и представлений (выражения над таблицами, результаты которых выглядят как новая таблица).

Имена, связанные операторами, должны быть действительными именами сущностей.

Выражения, связанные операторами, могут быть:
* Из масштабируемого типа
* Табликового типа
* Функции, определяемые пользователем (лямбдас)

**Синтаксис**

`let`*Название* `=` *ScalarExpression* | *TabularExpression* | *FunctionExpressionExpressionExpressionExpression*

* *Имя*: Имя для связывания. Имя должно быть действительным именем сущности, а имя `["Name with spaces"]`сущности, избегающее (например, допускается). 
* *ScalarExpression*: Выражение с результатом scalar, значение которого будет привязано к имени. Например: `let one=1;`.
* *TabularExpression*: Выражение с табликовым результатом, значение которого будет привязано к имени. Например: `Logs | where Timestamp > ago(1h)`.
* *FunctionDefinitionExpression*: Выражение, которое дает lambda (анонимное заявление функции), которое должно быть связано с именем.
  Например: `let f=(a:int, b:string) { strcat(b, ":", a) }`.

Выражения Lambda имеют следующий синтаксис:

`(`-`view`*ТабулярныеАргументы*`,`:*ScalarАргументы*`)` `{` - *ФункцияТела*`}`

`TabularArguments`-*TabularArgName* `:` `(`-*AtrName* `:` *AtrType*.`,` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . `)`] [`,` ... ] [`,`]

 или: -*TabularArgName* `:` `(` `*` `)`

`ScalarArguments`-*ArgName* `:` *ArgType*`,`

* `view`может появиться только в безпаралисте lambda (тот, который не имеет аргументов) и указывает, что связанное имя будет включено, когда "все таблицы" являются запросами (например, при использовании). `union *`
* *TabularArguments* - это список формальных аргументов табулярного выражения.
  Каждый аргумент имеет:
  * *TabularArgName* - название формального табликского аргумента. Затем имя может отображаться в *FunctionBody* и привязывается к определенному значению при вызове лямбды. 
  * Определение схемы таблицы - список атрибутов с их типами (AtrName : AtrType).
  Таблоцированное выражение, используемое в призыве lambda, должно иметь все эти атрибуты с соответствующими типами, но не ограничивается ими. 
  '(Я)' может быть использован в качестве табликового выражения. В этом случае любое таблоярное выражение может быть использовано в призыве лямбда, и ни одна из его столбцов не может быть доступна в выражении лямбда.
  Все табловые аргументы должны появляться перед аргументами scalar.
* *ScalarАргументы* - это список формальных аргументов. 
  Каждый аргумент имеет:
  * *ArgName* - название формального скаларного аргумента. Затем имя может отображаться в *FunctionBody* и привязывается к определенному значению при вызове лямбды.  
  * *ArgType* - тип формального скаларного аргумента. В настоящее время только следующие типы поддерживаются `datetime`в `timespan` `real`качестве `dynamic` типа аргумента lambda: `bool`, `string`, `long`, , , и (и псевдонимы для этих типов).

**Несколько и вложенных пусть заявления**

Несколько инструкций let `;` можно использовать с делимитером между ними, как показано в следующем примере.
Последнее утверждение должно быть действительным выражением запроса: 

```kusto
let start = ago(5h); 
let period = 2h; 
T | where Time > start and Time < start + period | ...
```

Nested Пусть заявления разрешены и могут быть использованы внутри выражения лямбда.
Пусть заявления и Аргументы видны в текущей и внутренней области тела Функции.

```kusto
let start_time = ago(5h); 
let end_time = start_time + 2h; 
T | where Time > start_time and Time < end_time | ...
```

**Примеры**

### <a name="using-let-to-define-constants"></a>Использование позволяют определить константы

Следующий пример связывает `x` имя с кальярным `1`буквальным, а затем использует его в табликовом выражении:

```kusto
let x = 1;
range y from x to x step x
```

Тот же пример, но в этом случае - `['name']` название let заявление дается с использованием понятия:

```kusto
let ['x'] = 1;
range y from x to x step x
```

Еще один пример, который использует пусть для масштабирования значений:

```kusto
let n = 10;  // number
let place = "Dallas";  // string
let cutoff = ago(62d); // datetime
Events 
| where timestamp > cutoff 
    and city == place 
| take n
```

### <a name="using-multiple-let-statements"></a>Использование нескольких инструкций let

Следующий пример определяет два препятствовали`foo2`операторам где`foo1`одно заявление () использует другое ( ).

```kusto
let foo1 = (_start:long, _end:long, _step:long) { range x from _start to _end step _step};
let foo2 = (_step:long) { foo1(1, 100, _step)};
foo2(2) | count
// Result: 50
```

### <a name="using-materialize-function"></a>Использование функции материализации

[`materialize`](materializefunction.md)функция позволяет кэширование результатов подзапроса во время выполнения запроса. 

```kusto
let totalPagesPerDay = PageViews
| summarize by Page, Day = startofday(Timestamp)
| summarize count() by Day;
let materializedScope = PageViews
| summarize by Page, Day = startofday(Timestamp);
let cachedResult = materialize(materializedScope);
cachedResult
| project Page, Day1 = Day
| join kind = inner
(
    cachedResult
    | project Page, Day2 = Day
)
on Page
| where Day2 > Day1
| summarize count() by Day1, Day2
| join kind = inner
    totalPagesPerDay
on $left.Day1 == $right.Day
| project Day1, Day2, Percentage = count_*100.0/count_1


```

|День 1|День 2|Процент|
|---|---|---|
|2016-05-01 00:00:00.0000000|2016-05-02 00:00:00.0000000|34.0645725975255|
|2016-05-01 00:00:00.0000000|2016-05-03 00:00:00.0000000|16.618368960101|
|2016-05-02 00:00:00.0000000|2016-05-03 00:00:00.0000000|14.6291376489636|
