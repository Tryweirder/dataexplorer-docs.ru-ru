---
title: Инструкция Let — Azure обозреватель данных
description: В этой статье описывается инструкция let в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: alexans
ms.service: data-explorer
ms.topic: reference
ms.date: 08/09/2020
ms.localizationpriority: high
ms.openlocfilehash: c102637adfa1fd0340d28a67b52354956b511ada
ms.sourcegitcommit: 4e811d2f50d41c6e220b4ab1009bb81be08e7d84
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/24/2020
ms.locfileid: "95513319"
---
# <a name="let-statement"></a>Инструкция let

Инструкции Let привязывают имена к выражениям. Для оставшейся части области, где отображается оператор Let, имя можно использовать для ссылки на связанное с ним значение. Инструкция let может находиться в глобальной области видимости или в области тела функции.
Если это имя ранее было привязано к другому значению, используется привязка инструкции Let "самый дальний".

Инструкции Let улучшают модульность и повторное использование, так как позволяют разбивать потенциально сложное выражение на несколько частей.
Каждая часть привязывается к имени с помощью инструкции Let, и вместе они составляют весь объект. Они также могут использоваться для создания пользовательских функций и представлений. Представления представляют собой выражения для таблиц, результаты которых выглядят как новая таблица.

> [!NOTE]
> Имена, связанные инструкциями let, должны быть допустимыми именами сущностей.

Выражения, связанные операторами let, могут быть:
* Скалярные типы
* Табличные типы
* Определяемые пользователем функции (лямбда-выражения)

## <a name="syntax"></a>Синтаксис

`let`*Имя* `=` *Скаларекспрессион*  |  *Табуларекспрессион*  |  *Функтиондефинитионекспрессион*

|Поле  |Определение  |Пример  |
|---------|---------|---------|
|*имя*;   | Привязываемое имя. Имя должно быть допустимым именем сущности.    |Допускается экранирование имен сущностей, например `["Name with spaces"]` ,.      |
|*скаларекспрессион*     |  Выражение с скалярным результатом, значение которого привязывается к имени.  | `let one=1;`  |
|*табуларекспрессион*    | Выражение с табличным результатом, значение которого привязывается к имени.   | `Logs | where Timestamp > ago(1h)`    |
|*функтиондефинитионекспрессион*   | Выражение, результатом которого является лямбда-объявление анонимной функции, которое должно быть привязано к имени.   |  `let f=(a:int, b:string) { strcat(b, ":", a) }`  |


### <a name="lambda-expressions-syntax"></a>Синтаксис лямбда-выражений

[ `view` ] `(` [*Табулараргументс*] [ `,` ] [*скалараргументс*] `)` `{` *функтионбоди*`}`

`TabularArguments` -[*Табулараргнаме* `:` `(` [*атрнаме* `:` *атртипе*] [ `,` ...] `)` ] [`,` ... ] [`,`]

 или

 [*Табулараргнаме* `:` `(` `*` `)`]

`ScalarArguments` -[*Аргнаме* `:` *аргтипе*] [ `,` ...]


|Поле  |Определение  |Пример  |
|---------|---------|---------|
| **режиме** | Может использоваться только в лямбда-выражении без параметров, не имеющего аргументов. Указывает, что связанное имя будет включаться, если все таблицы являются запросами. | Например, при использовании `union *` .|
| ***Табулараргументс** _ | Список аргументов формального табличного выражения. 
| Каждый табличный аргумент имеет следующее:||
|<ul><li> _TabularArgName *</li></ul> | Имя формального табличного аргумента. Имя может появиться в *функтионбоди* и привязано к определенному значению при вызове лямбда-выражения. ||
|<ul><li>Определение схемы таблицы </li></ul> | Список атрибутов с их типами| Атрнаме: Атртипе|
| ***Скалараргументс** _ | Список формальных скалярных аргументов. 
|Каждый скалярный аргумент имеет следующее:||
|<ul><li>_ArgName *</li></ul> | Имя формального скалярного аргумента. Имя может появиться в *функтионбоди* и привязано к определенному значению при вызове лямбда-выражения.  |
| <ul><li>*аргтипе* </li></ul>| Тип формального скалярного аргумента. | В настоящее время в качестве типа лямбда-аргумента поддерживаются только следующие типы: `bool` , `string` ,,,, `long` `datetime` `timespan` `real` и `dynamic` (и псевдонимы для этих типов).

> [!NOTE]
>Табличное выражение, используемое в вызове лямбда-выражения, должно включать (но не ограничивается) все атрибуты с соответствующими типами.
>
>`(*)` может использоваться в качестве табличного выражения. 
>
> Любое табличное выражение можно использовать в лямбда-вызове, и ни один из его столбцов не может быть получен в лямбда-выражении. 
>
> Все табличные аргументы должны располагаться перед скалярными аргументами.

## <a name="multiple-and-nested-let-statements"></a>Несколько и вложенные инструкции Let

Несколько инструкций Let можно использовать с точкой с запятой, `;` разделителем между ними, как показано в следующем примере.

> [!NOTE]
> Последняя инструкция должна быть допустимым выражением запроса. 

```kusto
let start = ago(5h); 
let period = 2h; 
T | where Time > start and Time < start + period | ...
```

Вложенные инструкции Let разрешены и могут использоваться внутри лямбда-выражения.
Операторы Let и аргументы видимы в текущей и внутренней области тела функции.

```kusto
let start_time = ago(5h); 
let end_time = start_time + 2h; 
T | where Time > start_time and Time < end_time | ...
```

## <a name="examples"></a>Примеры

### <a name="use-let-function-to-define-constants"></a>Использование функции let для определения констант

В следующем примере имя привязывается `x` к скалярному литералу `1` , а затем используется в операторе табличного выражения.

```kusto
let x = 1;
range y from x to x step x
```

Этот пример аналогичен предыдущему, только имя инструкции Let указывается с помощью `['name']` идеи.

```kusto
let ['x'] = 1;
range y from x to x step x
```

### <a name="use-let-for-scalar-values"></a>Использование let для скалярных значений

```kusto
let n = 10;  // number
let place = "Dallas";  // string
let cutoff = ago(62d); // datetime
Events 
| where timestamp > cutoff 
    and city == place 
| take n
```

### <a name="use-let-statement-with-arguments-for-scalar-calculation"></a>Использование инструкции Let с аргументами для скалярного вычисления

В этом примере используется оператор Let с аргументами для скалярного вычисления. Запрос определяет функцию `MultiplyByN` для умножения двух чисел.

<!-- csl: https://help.kusto.windows.net/Samples -->
```kusto
let MultiplyByN = (val:long, n:long) { val * n };
range x from 1 to 5 step 1 
| extend result = MultiplyByN(x, 5)
```

|x|набор по|
|---|---|
|1|5|
|2|10|
|3|15|
|4|20|
|5|25|

В следующем примере удаляются начальные и конечные ( `1` ) из входных данных.

<!-- csl: https://help.kusto.windows.net/Samples -->
```kusto
let TrimOnes = (s:string) { trim("1", s) };
range x from 10 to 15 step 1 
| extend result = TrimOnes(tostring(x))
```

|x|набор по|
|---|---|
|10|0|
|11||
|12|2|
|13|3|
|14|4|
|15|5|


### <a name="use-multiple-let-statements"></a>Использование нескольких инструкций Let

В этом примере определяются два оператора let, где одна инструкция ( `foo2` ) использует другую ( `foo1` ).

<!-- csl: https://help.kusto.windows.net/Samples -->
```kusto
let foo1 = (_start:long, _end:long, _step:long) { range x from _start to _end step _step};
let foo2 = (_step:long) { foo1(1, 100, _step)};
foo2(2) | count
// Result: 50
```

### <a name="use-the-view-keyword-in-a-let-statement"></a>Использование `view` ключевого слова в инструкции Let

В этом примере показано, как использовать инструкцию Let с `view` ключевым словом.

<!-- csl: https://help.kusto.windows.net/Samples -->
```kusto
let Range10 = view () { range MyColumn from 1 to 10 step 1 };
let Range20 = view () { range MyColumn from 1 to 20 step 1 };
search MyColumn == 5
```

|$table|MyColumn|
|---|---|
|Range10|5|
|Range20|5|


### <a name="use-materialize-function"></a>Использовать функцию материализации

[`materialize`](materializefunction.md)Функция позволяет кэшировать результаты вложенных запросов во время выполнения запроса. 

<!-- csl: https://help.kusto.windows.net:443/Samples -->
```kusto
let totalPagesPerDay = PageViews
| summarize by Page, Day = startofday(Timestamp)
| summarize count() by Day;
let materializedScope = PageViews
| summarize by Page, Day = startofday(Timestamp);
let cachedResult = materialize(materializedScope);
cachedResult
| project Page, Day1 = Day
| join kind = inner
(
    cachedResult
    | project Page, Day2 = Day
)
on Page
| where Day2 > Day1
| summarize count() by Day1, Day2
| join kind = inner
    totalPagesPerDay
on $left.Day1 == $right.Day
| project Day1, Day2, Percentage = count_*100.0/count_1
```

|День 1|День 2|Процент|
|---|---|---|
|2016-05-01 00:00:00.0000000|2016-05-02 00:00:00.0000000|34.0645725975255|
|2016-05-01 00:00:00.0000000|2016-05-03 00:00:00.0000000|16.618368960101|
|2016-05-02 00:00:00.0000000|2016-05-03 00:00:00.0000000|14.6291376489636|
