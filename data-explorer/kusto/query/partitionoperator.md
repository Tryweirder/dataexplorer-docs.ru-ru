---
title: Оператор Partition — обозреватель данных Azure
description: В этой статье описывается оператор Partition в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: alexans
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.openlocfilehash: b6f2628bf2391ccea53e7fe70c76c341dda7f4e9
ms.sourcegitcommit: 4c7f20dfd59fb5b5b1adfbbcbc9b7da07df5e479
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2020
ms.locfileid: "95324573"
---
# <a name="partition-operator"></a>Оператор partition

Оператор Partition разделяет свою входную таблицу на несколько вложенных таблиц в соответствии со значениями указанного столбца, выполняет вложенный запрос для каждой подтаблицы и создает одну выходную таблицу, которая является объединением результатов всех вложенных запросов. 

```kusto
T | partition by Col1 ( top 10 by MaxValue )

T | partition by Col1 { U | where Col2=toscalar(Col1) }
```

## <a name="syntax"></a>Синтаксис

*T* `|` `partition` [*партитионпараметерс*] `by` *столбец* `(` *контекстуалсубкуери*`)`

*T* `|` `partition` *PartitionParameters* `by` *Column* `{` *Вложенный запрос* к столбцу T [партитионпараметерс]`}`

## <a name="arguments"></a>Аргументы

* *T*: табличный источник, данные которого должны обрабатываться оператором.

* *Столбец*: имя столбца в *T* , значения которого определяют способ секционирования входной таблицы. См. **Примечания** ниже.

* *Контекстуалсубкуери*: табличное выражение, источником которого является источник `partition` оператора с областью действия для одного значения *ключа* .

* *Вложенный запрос*: табличное выражение без источника. Значение *ключа* можно получить с помощью `toscalar()` вызова.

* *Партитионпараметерс*: ноль или более (разделенных пробелами) параметров в виде: *имя* `=` *значение* , определяющее поведение оператора. Поддерживаются следующие параметры:

  |Имя               |Значения         |Описание|
  |-------------------|---------------|-----------|
  |`hint.materialized`|`true`,`false` |Если задано значение, `true` то источником оператора будет материализация `partition` (по умолчанию `false` ).|
  |`hint.concurrency`|*Число*|Подсказка для системы, сколько секций следует выполнять параллельно. *Значение по умолчанию*: 16.|
  |`hint.spread`|*Число*|Содержит указания системы по распределению секций между узлами кластера (например, если имеется N секций, а для указания распределения задано значение P, то N секций будут обрабатываться P разными узлами кластера одинаково параллельно или последовательно в зависимости от указания на параллелизм). *Значение по умолчанию*: 1.|

## <a name="returns"></a>Возвращаемое значение

Оператор возвращает объединение результатов применения вложенного запроса к каждой секции входных данных.

**Примечания**

* В настоящее время оператор секционирования ограничен количеством секций.
  Может быть создано до 64 различных секций.
  Оператор выдаст ошибку, если столбец секционирования (*столбец*) имеет более 64 различных значений.

* Вложенный запрос ссылается на входную секцию неявно (для секции во вложенном запросе отсутствует "имя"). Чтобы ссылаться на входную секцию несколько раз во вложенном запросе, используйте [оператор as](asoperator.md), как **показано ниже. ссылка на раздел:**

**Пример: Top-Nested Case**

В некоторых случаях более производительно и проще написать запрос с помощью `partition` оператора, а не с помощью [ `top-nested` оператора](topnestedoperator.md) . в следующем примере выполняется вычисление вложенного запроса `summarize` и `top` для каждого из состояний, начинающихся с `W` : (штат ВАЙОМИНГ, Вашингтон, Западная Виргиния, Висконсина)

<!-- csl: https://help.kusto.windows.net:443/Samples -->
```kusto
StormEvents
| where State startswith 'W'
| partition by State 
(
    summarize Events=count(), Injuries=sum(InjuriesDirect) by EventType, State
    | top 3 by Events 
) 

```
|EventType|Состояние|События|Травмах|
|---|---|---|---|
|Град|ШТАТ ВАЙОМИНГ|108|0|
|Высокая обмотка|ШТАТ ВАЙОМИНГ|81|5|
|Зима|ШТАТ ВАЙОМИНГ|72|0|
|Тяжелая снег|Вашингтон|82|0|
|Высокая обмотка|Вашингтон|58|13|
|Пожара|Вашингтон|29|0|
|Шквалистый ветер|ЗАПАДНАЯ ВИРДЖИНИЯ|180|1|
|Град|ЗАПАДНАЯ ВИРДЖИНИЯ|103|0|
|Погода на зимнее|ЗАПАДНАЯ ВИРДЖИНИЯ|88|0|
|Шквалистый ветер|ВИСКОНСИНА|416|1|
|Зима|ВИСКОНСИНА|310|0|
|Град|ВИСКОНСИНА|303|1|

**Пример. запрос неперекрывающихся секций данных**

Иногда полезно (на уровне производительности) выполнять сложный вложенный запрос к непересекающимся секциям данных в стиле "схема/уменьшение". В приведенном ниже примере показано, как создать ручное распределение агрегата для 10 секций.

<!-- csl: https://help.kusto.windows.net:443/Samples -->
```kusto
StormEvents
| extend p = hash(EventId, 10)
| partition by p
(
    summarize Count=count() by Source 
)
| summarize Count=sum(Count) by Source
| top 5 by Count
```

|Источник|Счетчик|
|---|---|
|Подготовленный корректировщик|12770|
|Правоприменение|8570|
|Общие|6157|
|Специалист по управлению в чрезвычайных ситуациях|4900|
|Наблюдатель COOP|3039|

**Пример. секционирование по времени запроса**

В следующем примере показано, как можно секционировать запрос на N = 10 секций, где каждая секция вычисляет собственное число, а затем суммируется в TotalCount.

<!-- csl: https://help.kusto.windows.net/Samples -->
```kusto
let N = 10;                 // Number of query-partitions
range p from 0 to N-1 step 1  // 
| partition by p            // Run the sub-query partitioned 
{
    StormEvents 
    | where hash(EventId, N) == toscalar(p) // Use toscalar() to fetch partition key value
    | summarize Count = count()
}
| summarize TotalCount=sum(Count) 
```

|TotalCount|
|---|
|59066|


**Пример: ссылка на секцию**

В следующем примере показано, как можно использовать [оператор as](asoperator.md) для присвоения имени каждой секции данных, а затем повторно использовать это имя во вложенном запросе:

```kusto
T
| partition by Dim
(
    as Partition
    | extend MetricPct = Metric * 100.0 / toscalar(Partition | summarize sum(Metric))
)
```

**Пример: сложный вложенный запрос, скрытый с помощью вызова функции**

Тот же метод можно применить с гораздо более сложными вложенными запросами. Чтобы упростить синтаксис, можно заключить вложенный запрос в вызов функции:

<!-- csl: https://help.kusto.windows.net:443/Samples -->
```kusto
let partition_function = (T:(Source:string)) 
{
    T
    | summarize Count=count() by Source
};
StormEvents
| extend p = hash(EventId, 10)
| partition by p
(
    invoke partition_function()
)
| summarize Count=sum(Count) by Source
| top 5 by Count
```

|Источник|Счетчик|
|---|---|
|Подготовленный корректировщик|12770|
|Правоприменение|8570|
|Общие|6157|
|Специалист по управлению в чрезвычайных ситуациях|4900|
|Наблюдатель COOP|3039|
