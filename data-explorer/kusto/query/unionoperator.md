---
title: оператор Union — обозреватель данных Azure | Документация Майкрософт
description: В этой статье описывается оператор Union в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
zone_pivot_group_filename: data-explorer/zone-pivot-groups.json
zone_pivot_groups: kql-flavors
ms.openlocfilehash: 4995c989b04df5dd66e20e3405b5fb7da7c739ce
ms.sourcegitcommit: 6f610cd9c56dbfaff4eb0470ac0d1441211ae52d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/12/2020
ms.locfileid: "91954711"
---
# <a name="union-operator"></a>Оператор union

Принимает несколько таблиц и возвращает строки из них. 

```kusto
Table1 | union Table2, Table3
```

## <a name="syntax"></a>Синтаксис

*T* `| union` [*унионпараметерс*] [ `kind=` `inner` | `outer` ] [ `withsource=` *имя_столбца*] [ `isfuzzy=` `true` | `false` ] *Таблица* [ `,` *Таблица*]...  

Альтернативная форма без последовательного ввода:

`union`[*Унионпараметерс*] [ `kind=` `inner` | `outer` ] [ `withsource=` *Имя_столбца*] [ `isfuzzy=` `true` | `false` ] *Таблица* [ `,` *Таблица*]...  

## <a name="arguments"></a>Аргументы

::: zone pivot="azuredataexplorer"

* `Table`:
    *  Имя таблицы, например `Events`.
    *  Выражение запроса, которое должно быть заключено в круглые скобки, такие как `(Events | where id==42)` или `(cluster("https://help.kusto.windows.net:443").database("Samples").table("*"))` ;
    *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` формирует объединение всех таблиц в базе данных, имена которых начинаются `E` .
* `kind`: 
    * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
    * `outer` -(по умолчанию). Результат содержит все столбцы, которые встречаются в любом из входных данных. Ячейки, не определенные входной строкой, устанавливаются в значение `null` .
* `withsource`=*ColumnName*: Если указано, выходные данные будут включать столбец с именем *ColumnName* , значение которого указывает, какая исходная таблица была задействована в каждой строке.
Если запрос эффективно (после совпадения с подстановочными знаками) ссылается на таблицы из более чем одной базы данных (база данных по умолчанию всегда учитывает), значение этого столбца будет иметь имя таблицы, дополненное базой данных.
Аналогичные значения для __кластеров и баз данных__ будут присутствовать в значении, если имеется ссылка на несколько кластеров. 
* `isfuzzy=``true`  |  `false` : Если `isfuzzy` для задано значение, `true` разрешение нечеткого разрешения для разброса объединения. `Fuzzy` применяется к набору `union` источников. Это означает, что при анализе запроса и подготовке к выполнению набор источников объединения сокращается до набора ссылок на таблицы, которые существуют и доступны в момент времени. Если хотя бы одна такая таблица была найдена, любая ошибка разрешения выдаст предупреждение в результатах состояния запроса (по одному для каждой отсутствующей ссылки), но не будет препятствовать выполнению запроса. Если разрешения не были успешными, запрос возвратит ошибку.
Значение по умолчанию — `isfuzzy=` `false`.
* *Унионпараметерс*: ноль или более (разделенных пробелами) параметров в виде значения *имени* `=` *Value* , которое управляет поведением операции сопоставления строк и плана выполнения. Поддерживаются следующие параметры: 

  |Имя           |Значения                                        |Описание                                  |
  |---------------|----------------------------------------------|---------------------------------------------|
  |`hint.concurrency`|*Число*|Описывает систему, сколько одновременных вложенных запросов `union` оператора должно выполняться параллельно. *По умолчанию*: количество ядер ЦП на одном узле кластера (от 2 до 16).|
  |`hint.spread`|*Число*|Подсказка системы, сколько узлов должно использоваться при выполнении параллельных `union` вложенных запросов. *Значение по умолчанию*: 1.|

::: zone-end

::: zone pivot="azuremonitor"

* `Table`:
    *  Имя таблицы, например `Events`
    *  Выражение запроса, которое должно быть заключено в круглые скобки, например `(Events | where id==42)`
    *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` формирует объединение всех таблиц в базе данных, имена которых начинаются `E` .
* `kind`: 
    * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
    * `outer` -(по умолчанию). Результат содержит все столбцы, которые встречаются в любом из входных данных. Ячейки, не определенные входной строкой, устанавливаются в значение `null` .
* `withsource`=*ColumnName*: Если указано, выходные данные будут включать столбец с именем *ColumnName* , значение которого указывает, какая исходная таблица участвует в каждой строке.
Если запрос эффективно (после совпадения с подстановочными знаками) ссылается на таблицы из более чем одной базы данных (база данных по умолчанию всегда учитывает), значение этого столбца будет иметь имя таблицы, дополненное базой данных.
Аналогичным образом, при наличии нескольких кластеров, на которые указывают ссылки, можно использовать квалификацию __кластера и базы данных__ . 
* `isfuzzy=``true`  |  `false` : Если `isfuzzy` для задано значение, `true` разрешение нечеткого разрешения для разброса объединения. `Fuzzy` применяется к набору `union` источников. Это означает, что при анализе запроса и подготовке к выполнению набор источников объединения сокращается до набора ссылок на таблицы, которые существуют и доступны в момент времени. Если хотя бы одна такая таблица была найдена, любая ошибка разрешения выдаст предупреждение в результатах состояния запроса (по одному для каждой отсутствующей ссылки), но не будет препятствовать выполнению запроса. Если разрешения не были успешными, запрос возвратит ошибку.
Значение по умолчанию — `isfuzzy=false`.

::: zone-end

## <a name="returns"></a>Возвращаемое значение

Таблица с количеством строк, соответствующим количеству строк во всех входных таблицах.

**Примечания**

::: zone pivot="azuredataexplorer"

1. `union`область может включать [инструкции Let](./letstatement.md) , если они имеют атрибуты с [ключевым словом View](./letstatement.md) .
2. `union` область не будет содержать [функции](../management/functions.md). Чтобы включить функцию в область Union, определите [инструкцию Let](./letstatement.md) с [ключевым словом View](./letstatement.md) .
3. Если `union` входные данные являются [таблицами](../management/tables.md) (а не [табличными выражениями](./tabularexpressionstatements.md)), а `union` за ним следует [оператор WHERE](./whereoperator.md), для повышения производительности рассмотрите возможность замены с помощью [Find](./findoperator.md). Обратите внимание на другую [выходную схему](./findoperator.md#output-schema) , созданную `find` оператором. 
4. `isfuzzy=true` применяется только к `union` этапу разрешения источников. После определения набора исходных таблиц возможные дополнительные сбои запросов не будут подавлены.
5. При использовании `outer union` результат содержит все столбцы, которые встречаются в любом из входных данных, по одному столбцу для каждого вхождения имени и типа. Это означает, что если столбец отображается в нескольких таблицах и имеет несколько типов, он будет иметь соответствующий столбец для каждого типа в `union` результате. Это имя столбца будет сопровождаться суффиксом "_" и [типом](./scalar-data-types/index.md)исходного столбца.

::: zone-end

::: zone pivot="azuremonitor"

1. `union`область может включать [инструкции Let](./letstatement.md) , если они имеют атрибуты с [ключевым словом View](./letstatement.md) .
2. `union` область не будет содержать функции. Включение функции в область Union — определение [инструкции Let](./letstatement.md) с [ключевым словом View](./letstatement.md)
3. Если `union` входные данные являются таблицами (а не [табличными выражениями](./tabularexpressionstatements.md)), а `union` за ним следует [оператор WHERE](./whereoperator.md), рассмотрите возможность замены с помощью [Find](./findoperator.md) для повышения производительности. Обратите внимание на другую [выходную схему](./findoperator.md#output-schema) , созданную `find` оператором. 
4. `isfuzzy=``true`применяется только к фазе `union` разрешения источников. После определения набора исходных таблиц возможные дополнительные сбои запросов не будут подавлены.
5. При использовании `outer union` результат содержит все столбцы, которые встречаются в любом из входных данных, по одному столбцу для каждого вхождения имени и типа. Это означает, что если столбец отображается в нескольких таблицах и имеет несколько типов, он будет иметь соответствующий столбец для каждого типа в `union` результате. Это имя столбца будет сопровождаться суффиксом "_" и [типом](./scalar-data-types/index.md)исходного столбца.

::: zone-end


## <a name="example-tables-with-string-in-name-or-column"></a>Пример: таблицы со строкой в имени или столбце

```kusto
union K* | where * has "Kusto"
```

Строки из всех таблиц в базе данных, имя которых начинается с `K` , а в любом столбце содержится слово `Kusto` .

## <a name="example-distinct-count"></a>Пример: число различных объектов

```kusto
union withsource=SourceTable kind=outer Query, Command
| where Timestamp > ago(1d)
| summarize dcount(UserId)
```

Количество различных пользователей, которые за последний день создали событие `Query` или `Command`. В результате в столбце SourceTable будет указано одно из значений: Query или Command.

```kusto
Query
| where Timestamp > ago(1d)
| union withsource=SourceTable kind=outer 
   (Command | where Timestamp > ago(1d))
| summarize dcount(UserId)
```

Это более эффективный способ получить тот же результат, так как перед объединением каждая таблица отфильтровывается.

**Пример. Использование `isfuzzy=true`**
 
```kusto     
// Using union isfuzzy=true to access non-existing view:                                     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=1 };
let OtherView_1 = view () { print x=1 };
union isfuzzy=true
(View_1 | where x > 0), 
(View_2 | where x > 0),
(View_3 | where x > 0)
| count 
```

|Count|
|---|
|2|

Наблюдение за состоянием запроса. возвращается следующее предупреждение: `Failed to resolve entity 'View_3'`

```kusto
// Using union isfuzzy=true and wildcard access:
let View_1 = view () { print x=1 };
let View_2 = view () { print x=1 };
let OtherView_1 = view () { print x=1 };
union isfuzzy=true View*, SomeView*, OtherView*
| count 
```

|Count|
|---|
|3|

Наблюдение за состоянием запроса. возвращается следующее предупреждение: `Failed to resolve entity 'SomeView*'`

**Пример: несоответствие типов исходных столбцов**
 
```kusto     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=toint(2) };
union withsource=TableName View_1, View_2
```

|TableName|x_long|x_int|
|---------|------|-----|
|View_1   |1     |     |
|View_2   |      |2    |

```kusto     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=toint(2) };
let View_3 = view () { print x_long=3 };
union withsource=TableName View_1, View_2, View_3 
```

|TableName|x_long1|x_int |x_long|
|---------|-------|------|------|
|View_1   |1      |      |      |
|View_2   |       |2     |      |
|View_3   |       |      |3     |

Столбец `x` из `View_1` полученного суффикса `_long` , а как столбец с именем `x_long` уже существует в схеме результата, имена столбцов были удалены, создание нового столбца — `x_long1`
