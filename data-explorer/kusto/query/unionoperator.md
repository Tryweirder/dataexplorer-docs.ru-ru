---
title: профсоюзный оператор - Azure Data Explorer Документы Майкрософт
description: В этой статье описывается оператор профсоюза в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
zone_pivot_group_filename: data-explorer/zone-pivot-groups.json
zone_pivot_groups: kql-flavors
ms.openlocfilehash: b62c259e1abf1ff0e0e98a90ac4da5a000db5320
ms.sourcegitcommit: 01eb9aaf1df2ebd5002eb7ea7367a9ef85dc4f5d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81765401"
---
# <a name="union-operator"></a>Оператор union

Принимает несколько таблиц и возвращает строки из них. 

```kusto
Table1 | union Table2, Table3
```

**Синтаксис**

*T* `| union` -*Параметры*союза`kind=` `inner` | `outer`,`withsource=`- колонкаИмя`,` -*ColumnName*`isfuzzy=` `true` | `false` *таблица* - *таблица...*  

Альтернативная форма без ввода трубы:

`union`*Параметры союза* `kind=` `inner` | `outer` `false``,` *Table* *ColumnName* *Table*КолонкаИмя -`isfuzzy=` `true`Таблица и таблица... |`withsource=`  

**Аргументы**

::: zone pivot="azuredataexplorer"

* `Table`:
    *  Имя таблицы, например `Events`.
    *  Выражение запроса, которое должно быть приложено `(Events | where id==42)` `(cluster("https://help.kusto.windows.net:443").database("Samples").table("*"))`с скобками, например, или ; Или
    *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` сформируется объединение всех таблиц в базе `E`данных, имена которых начинаются.
* `kind`: 
    * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
    * `outer`- (по умолчанию). В результате есть все столбцы, которые встречаются в любом из входов. Ячейки, которые не были определены строкой ввода, настроены на. `null`
* `withsource`=*ColumnName*: Если указано, вывод будет включать столбец под названием *ColumnName,* значение которого указывает, какая строка кода внесла каждый вклад в каждую строку.
Если запрос эффективно (после сопоставления подстановочных карт) ссылается на таблицы из нескольких баз данных (база данных по умолчанию всегда учитывается), значение этого столбца будет иметь имя таблицы, квалифицируемое с базой данных.
Аналогичным образом квалификации __кластера и базы данных__ будут присутствовать в значении, если на них будет ссылаться более одного кластера. 
* `isfuzzy=``true` `isfuzzy` : Если установлен `true` на - позволяет нечеткое разрешение союз ноги.  |  `false` `Fuzzy`применяется к набору источников. `union` Это означает, что при анализе запроса и подготовке к исполнению набор союзных источников сводится к набору ссылок таблицы, которые существуют и доступны в то время. Если была найдена хотя бы одна такая таблица, любой сбой в решении приведет к предупреждению в результатах состояния запроса (по одному для каждой отсутствующих ссылок), но не предотвратит выполнение запроса; если разрешения не были успешными - запрос вернет ошибку.
Значение по умолчанию — `isfuzzy=` `false`.
* *Параметры соединения*: Нулевые или более (пространственно-разделенные) параметры в виде *значения* *имен,* `=` которые контролируют поведение операции и выполнения строки матча. Поддерживаются следующие параметры: 

  |Имя           |Значения                                        |Описание                                  |
  |---------------|----------------------------------------------|---------------------------------------------|
  |`hint.concurrency`|*Номер*|Подсказки системе, сколько параллельных подзапросов `union` оператора должно быть выполнено параллельно. *По умолчанию*: Количество ядер процессора на одном узло кластера (от 2 до 16).|
  |`hint.spread`|*Номер*|Подсказки системе, сколько узлов должно использоваться `union` одновременное выполнение подзапросов. *По умолчанию*: 1.|

::: zone-end

::: zone pivot="azuremonitor"

* `Table`:
    *  Название таблицы, например`Events`
    *  Выражение запроса, которое должно быть приложено с скобками, например`(Events | where id==42)`
    *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` сформируется объединение всех таблиц в базе `E`данных, имена которых начинаются.
* `kind`: 
    * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
    * `outer`- (по умолчанию). В результате есть все столбцы, которые встречаются в любом из входов. Ячейки, которые не были определены строкой ввода, настроены на. `null`
* `withsource`=*ColumnName*: Если указано, вывод будет включать столбец под названием *ColumnName,* значение которого указывает, какая таблица исходного кода внесла каждый ряд.
Если запрос эффективно (после сопоставления подстановочных карт) ссылается на таблицы из нескольких баз данных (база данных по умолчанию всегда учитывается), значение этого столбца будет иметь имя таблицы, квалифицируемое с базой данных.
Аналогичным образом, квалификация __кластера и базы данных__ будет присутствовать в значении, если будет увечиваться более одного кластера. 
* `isfuzzy=``true` `isfuzzy` : Если установлен `true` на - позволяет нечеткое разрешение союз ноги.  |  `false` `Fuzzy`применяется к набору источников. `union` Это означает, что при анализе запроса и подготовке к исполнению набор союзных источников сводится к набору ссылок таблицы, которые существуют и доступны в то время. Если была найдена хотя бы одна такая таблица, любой сбой в решении приведет к предупреждению в результатах состояния запроса (по одному для каждой отсутствующих ссылок), но не предотвратит выполнение запроса; если разрешения не были успешными - запрос вернет ошибку.
Значение по умолчанию — `isfuzzy=false`.

::: zone-end

**Возвращает**

Таблица с количеством строк, соответствующим количеству строк во всех входных таблицах.

**Примечания**

::: zone pivot="azuredataexplorer"

1. `union`область действия может включать в себя [пусть заявления,](./letstatement.md) если те приписываются с [ключевым словом представления](./letstatement.md)
2. `union`область применения не будет включать [функции.](../management/functions.md) Чтобы включить функцию в область союза, определите [заявление let](./letstatement.md) с ключевым [словом view](./letstatement.md)
3. Если `union` входные [таблицы таблицы](../management/tables.md) (в отличие от `union` [табликовых выражений),](./tabularexpressionstatements.md)а затем, где [оператор](./whereoperator.md), для повышения производительности, рассмотреть вопрос о замене обоих с [найти](./findoperator.md). Обратите внимание на различные [схемы вывода,](./findoperator.md#output-schema) производимые оператором. `find` 
4. `isfuzzy=true`применяется только `union` к фазе разрешения источников. Как только набор исходных таблиц будет определен, возможные дополнительные сбои запроса не будут подавлены.
5. При `outer union`использовании, результат имеет все столбцы, которые происходят в любом из входов, один столбец для каждого имени и ввечи вспыхиваний. Это означает, что если столбец отображается в нескольких таблицах и имеет `union`несколько типов, он будет иметь соответствующий столбец для каждого типа в результате '. Это имя столбца будет суффиксировано с [типом](./scalar-data-types/index.md)столбца происхождения.

::: zone-end

::: zone pivot="azuremonitor"

1. `union`область действия может включать в себя [пусть заявления,](./letstatement.md) если те приписываются с [ключевым словом представления](./letstatement.md)
2. `union`область применения не будет включать функции. Включить функцию в область союза - определите [заявление let](./letstatement.md) с ключевым [словом view](./letstatement.md)
3. Если `union` входные таблицы таблицы (в отличие от `union` [табулярных выражений),](./tabularexpressionstatements.md)а затем, где [оператор](./whereoperator.md), рассмотреть вопрос о замене обоих с [поиском](./findoperator.md) для лучшей производительности. Обратите внимание на различные [схемы вывода,](./findoperator.md#output-schema) производимые оператором. `find` 
4. `isfuzzy=``true` применяется только к фазе `union` разрешения источников. Как только набор исходных таблиц был определен, возможные дополнительные сбои запроса не будут подавлены.
5. При `outer union`использовании, результат имеет все столбцы, которые происходят в любом из входов, один столбец для каждого имени и ввечи вспыхиваний. Это означает, что если столбец отображается в нескольких таблицах и имеет `union`несколько типов, он будет иметь соответствующий столбец для каждого типа в результате '. Это имя столбца будет суффиксировано с [типом](./scalar-data-types/index.md)столбца происхождения.

::: zone-end


**Пример**

```kusto
union K* | where * has "Kusto"
```

Строки из всех таблиц в базе `K`данных, имя которых `Kusto`начинается с , и в котором любой столбец включает в себя слово .

**Пример**

```kusto
union withsource=SourceTable kind=outer Query, Command
| where Timestamp > ago(1d)
| summarize dcount(UserId)
```

Количество различных пользователей, которые за последний день создали событие `Query` или `Command`. В результате в столбце SourceTable будет указано одно из значений: Query или Command.

```kusto
Query
| where Timestamp > ago(1d)
| union withsource=SourceTable kind=outer 
   (Command | where Timestamp > ago(1d))
| summarize dcount(UserId)
```

Это более эффективный способ получить тот же результат, так как перед объединением каждая таблица отфильтровывается.

**Пример: Использование`isfuzzy=true`**
 
```kusto     
// Using union isfuzzy=true to access non-existing view:                                     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=1 };
let OtherView_1 = view () { print x=1 };
union isfuzzy=true
(View_1 | where x > 0), 
(View_2 | where x > 0),
(View_3 | where x > 0)
| count 
```

|Count|
|---|
|2|

Наблюдение за статусом запроса - следующее предупреждение возвращается:`Failed to resolve entity 'View_3'`

```kusto
// Using union isfuzzy=true and wildcard access:
let View_1 = view () { print x=1 };
let View_2 = view () { print x=1 };
let OtherView_1 = view () { print x=1 };
union isfuzzy=true View*, SomeView*, OtherView*
| count 
```

|Count|
|---|
|3|

Наблюдение за статусом запроса - следующее предупреждение возвращается:`Failed to resolve entity 'SomeView*'`

**Пример: несоответствие типов исходных столбов**
 
```kusto     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=toint(2) };
union withsource=TableName View_1, View_2
```

|TableName|x_long|x_int|
|---------|------|-----|
|View_1   |1     |     |
|View_2   |      |2    |

```kusto     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=toint(2) };
let View_3 = view () { print x_long=3 };
union withsource=TableName View_1, View_2, View_3 
```

|TableName|x_long1|x_int |x_long|
|---------|-------|------|------|
|View_1   |1      |      |      |
|View_2   |       |2     |      |
|View_3   |       |      |3     |

`x` Колонка `View_1` из полученного `_long`суффикса, и в качестве столбца, названного `x_long` уже существует в схеме результата, названия столбцов были де-дублированы, создавая новую колонку-`x_long1`
