---
title: Оператор union — Azure Data Explorer | Документация Майкрософт
description: Узнайте, как использовать оператор union в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: alexans
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.localizationpriority: high
zone_pivot_group_filename: data-explorer/zone-pivot-groups.json
zone_pivot_groups: kql-flavors
ms.openlocfilehash: b8ad39e8c1233acc2df6c30059a6926cea85f37a
ms.sourcegitcommit: f49e581d9156e57459bc69c94838d886c166449e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2020
ms.locfileid: "95512814"
---
# <a name="union-operator"></a>Оператор union

Принимает несколько таблиц и возвращает строки из них. 

```kusto
Table1 | union Table2, Table3
```

## <a name="syntax"></a>Синтаксис

*T* `| union` [*UnionParameters*] [`kind=` `inner`|`outer`] [`withsource=`*ColumnName*] [`isfuzzy=` `true`|`false`] *Table* [`,` *Table*]...  

Альтернативная форма без разделения ввода:

`union` [*UnionParameters*] [`kind=` `inner`|`outer`] [`withsource=`*ColumnName*] [`isfuzzy=` `true`|`false`] *Table* [`,` *Table*]...  

## <a name="arguments"></a>Аргументы

::: zone pivot="azuredataexplorer"

* `Table`:
    *  Имя таблицы, например `Events`.
    *  Выражение запроса, которое должно быть заключено в скобки, например `(Events | where id==42)` или `(cluster("https://help.kusto.windows.net:443").database("Samples").table("*"))`; или
    *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` будет формировать объединение всех таблиц в базе данных, имена которых начинаются с `E`.
* `kind`: 
    * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
    * `outer` — значение по умолчанию. Результат содержит все столбцы, которые есть в любых входных таблицах. Для ячеек, которые не определены во входной строке, будет задано значение `null`.
* `withsource`=*ColumnName.* Если аргумент указан, выходные данные будут содержать столбец с именем *ColumnName*. В нем для каждой строки будет указано, из какой исходной таблицы она взята.
Если запрос эффективно (после нахождения соответствий по подстановочным знакам) ссылается на таблицы из более чем одной базы данных (база данных по умолчанию всегда учитывается), значение этого столбца будет включать имя таблицы, дополненное именем базы данных.
Точно так же в значение будут добавляться имена __кластера и базы данных__, если есть ссылка более чем на один кластер. 
* `isfuzzy=` `true` | `false`. Если для `isfuzzy` задано значение `true`, значит для разветвлений union допускается нечеткое разрешение. `Fuzzy` применяется к набору источников `union`. Это означает, что при анализе запроса и подготовке к выполнению набор источников union сокращается до набора ссылок на таблицы, которые существуют и доступны в указанный момент. Если найдена хотя бы одна такая таблица, любая ошибка разрешения приведет к отображению предупреждения в результатах состояния запроса (по одному для каждой отсутствующей ссылки), но это не будет препятствовать выполнению запроса. Если разрешения не были успешными, запрос вернет ошибку.
Значение по умолчанию — `isfuzzy=` `false`.
* *UnionParameters.* Ноль или более разделенных пробелами параметров в виде *имя* `=` *значение*, управляющих поведением операции сопоставления строк и планом выполнения. Поддерживаются следующие параметры: 

  |Имя           |Значения                                        |Описание                                  |
  |---------------|----------------------------------------------|---------------------------------------------|
  |`hint.concurrency`|*Число*|Указывает системе, сколько параллельных вложенных запросов оператора `union` необходимо выполнять одновременно. *По умолчанию*: количество ядер ЦП на одном узле кластера (от 2 до 16).|
  |`hint.spread`|*Число*|Указывает системе, сколько узлов должно использоваться при параллельном выполнении вложенных запросов `union`. *По умолчанию*: 1.|

::: zone-end

::: zone pivot="azuremonitor"

* `Table`:
    *  имя таблицы, например `Events`.
    *  Выражение запроса, которое должно быть заключено в скобки, например `(Events | where id==42)`.
    *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` сформирует объединение всех таблиц в базе данных, имена которых начинаются с `E`.
* `kind`: 
    * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
    * `outer` — значение по умолчанию. Результат содержит все столбцы, которые есть в любых входных таблицах. Для ячеек, которые не определены во входной строке, будет задано значение `null`.
* `withsource`=*ColumnName.* Если аргумент указан, выходные данные будут содержать столбец с именем *ColumnName*. В нем для каждой строки будет указано, из какой исходной таблицы она взята.
Если запрос эффективно (после нахождения соответствий по подстановочным знакам) ссылается на таблицы из более чем одной базы данных (база данных по умолчанию всегда учитывается), значение этого столбца будет включать имя таблицы, дополненное именем базы данных.
Точно так же в значение будут добавляться имена __кластера и базы данных__, если есть ссылка более чем на один кластер. 
* `isfuzzy=` `true` | `false`. Если для `isfuzzy` задано значение `true`, значит для разветвлений union допускается нечеткое разрешение. `Fuzzy` применяется к набору источников `union`. Это означает, что при анализе запроса и подготовке к выполнению набор источников union сокращается до набора ссылок на таблицы, которые существуют и доступны в указанный момент. Если найдена хотя бы одна такая таблица, любая ошибка разрешения приведет к отображению предупреждения в результатах состояния запроса (по одному для каждой отсутствующей ссылки), но это не будет препятствовать выполнению запроса. Если разрешения не были успешными, запрос вернет ошибку.
Значение по умолчанию — `isfuzzy=false`.

::: zone-end

## <a name="returns"></a>Возвращаемое значение

Таблица с количеством строк, соответствующим количеству строк во всех входных таблицах.

**Примечания**

::: zone pivot="azuredataexplorer"

1. Область `union` может включать [инструкции let](./letstatement.md), если для них указано [ключевое слово view](./letstatement.md).
2. Область `union` не будет включать [функции](../management/functions.md). Чтобы включить функцию в область union, определите [инструкцию let](./letstatement.md) с [ключевым словом view](./letstatement.md).
3. Если в качестве входных данных `union` используются [таблицы](../management/tables.md) (в отличие от [табличных выражений](./tabularexpressionstatements.md)), а за `union` следует [оператор where](./whereoperator.md), для повышения производительности рекомендуется заменить их [оператором find](./findoperator.md). Обратите внимание на разные [схемы вывода](./findoperator.md#output-schema), создаваемые оператором `find`. 
4. `isfuzzy=true` применяется только к этапу разрешения источников `union`. После определения набора исходных таблиц возможные дополнительные сбои запросов не будут подавляться.
5. При использовании `outer union` результат будет включать все столбцы, которые встречаются во входных данных, по одному столбцу для каждого вхождения имени и типа. Это означает, что, если столбец присутствует в нескольких таблицах и имеет несколько типов, он будет иметь соответствующий столбец для каждого типа в результатах `union`. К этому имени столбца будет добавлен суффикс _, за которым следует [тип](./scalar-data-types/index.md) исходного столбца.

::: zone-end

::: zone pivot="azuremonitor"

1. Область `union` может включать [инструкции let](./letstatement.md), если для них указано [ключевое слово view](./letstatement.md).
2. Область `union` не будет включать функции. Чтобы включить функцию в область union, определите [инструкцию let](./letstatement.md) с [ключевым словом view](./letstatement.md).
3. Если в качестве входных данных `union` используются таблицы (в отличие от [табличных выражений](./tabularexpressionstatements.md)), а за `union` следует [оператор where](./whereoperator.md), для повышения производительности рекомендуется заменить их [оператором find](./findoperator.md). Обратите внимание на разные [схемы вывода](./findoperator.md#output-schema), создаваемые оператором `find`. 
4. `isfuzzy=` `true` применяется только к этапу разрешения источников `union`. После определения набора исходных таблиц возможные дополнительные сбои запросов не будут подавляться.
5. При использовании `outer union` результат будет включать все столбцы, которые встречаются во входных данных, по одному столбцу для каждого вхождения имени и типа. Это означает, что, если столбец присутствует в нескольких таблицах и имеет несколько типов, он будет иметь соответствующий столбец для каждого типа в результатах `union`. К этому имени столбца будет добавлен суффикс _, за которым следует [тип](./scalar-data-types/index.md) исходного столбца.

::: zone-end


## <a name="example-tables-with-string-in-name-or-column"></a>Пример Таблицы со строкой в имени или столбце

```kusto
union K* | where * has "Kusto"
```

Строки из всех таблиц в базе данных, имена которых начинаются с `K`, а в каком-либо столбце содержится слово `Kusto`.

## <a name="example-distinct-count"></a>Пример количество различных объектов

```kusto
union withsource=SourceTable kind=outer Query, Command
| where Timestamp > ago(1d)
| summarize dcount(UserId)
```

Количество различных пользователей, которые за последний день создали событие `Query` или `Command`. В результате в столбце SourceTable будет указано одно из значений: Query или Command.

```kusto
Query
| where Timestamp > ago(1d)
| union withsource=SourceTable kind=outer 
   (Command | where Timestamp > ago(1d))
| summarize dcount(UserId)
```

Это более эффективный способ получить тот же результат, так как перед объединением каждая таблица отфильтровывается.

**Пример. С использованием `isfuzzy=true`**
 
```kusto     
// Using union isfuzzy=true to access non-existing view:                                     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=1 };
let OtherView_1 = view () { print x=1 };
union isfuzzy=true
(View_1 | where x > 0), 
(View_2 | where x > 0),
(View_3 | where x > 0)
| count 
```

|Счетчик|
|---|
|2|

Наблюдение за состоянием запроса — возвращается следующее предупреждение: `Failed to resolve entity 'View_3'`

```kusto
// Using union isfuzzy=true and wildcard access:
let View_1 = view () { print x=1 };
let View_2 = view () { print x=1 };
let OtherView_1 = view () { print x=1 };
union isfuzzy=true View*, SomeView*, OtherView*
| count 
```

|Счетчик|
|---|
|3|

Наблюдение за состоянием запроса — возвращается следующее предупреждение: `Failed to resolve entity 'SomeView*'`

**Пример: несоответствие типов исходных столбцов**
 
```kusto     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=toint(2) };
union withsource=TableName View_1, View_2
```

|TableName|x_long|x_int|
|---------|------|-----|
|View_1   |1     |     |
|View_2   |      |2    |

```kusto     
let View_1 = view () { print x=1 };
let View_2 = view () { print x=toint(2) };
let View_3 = view () { print x_long=3 };
union withsource=TableName View_1, View_2, View_3 
```

|TableName|x_long1|x_int |x_long|
|---------|-------|------|------|
|View_1   |1      |      |      |
|View_2   |       |2     |      |
|View_3   |       |      |3     |

Столбец `x` из `View_1` получил суффикс `_long`, и так как столбец с именем `x_long` уже существует в схеме результата, для имен столбцов выполнено удаление дубликатов, что привело к созданию нового столбца — `x_long1`
