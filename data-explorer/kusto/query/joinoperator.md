---
title: оператор Join — Azure обозреватель данных
description: В этой статье описывается оператор JOIN в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
zone_pivot_group_filename: data-explorer/zone-pivot-groups.json
zone_pivot_groups: kql-flavors
ms.openlocfilehash: 4952e315a974e72135c722b255a96f57bf89cc12
ms.sourcegitcommit: d6f35df833d5b4f2829a8924fffac1d0b49ce1c2
ms.contentlocale: ru-RU
ms.lasthandoff: 07/07/2020
ms.locfileid: "86058785"
---
# <a name="join-operator"></a>Оператор join

Объедините строки двух таблиц, чтобы сформировать новую таблицу, сопоставляя значения указанных столбцов из каждой таблицы.

```kusto
Table1 | join (Table2) on CommonColumn, $left.Col1 == $right.Col2
```

## <a name="syntax"></a>Синтаксис

*Лефттабле* `|` `join`[*Жоинпараметерс*] `(` *RightTable* `)` `on` *атрибуты* ригхттабле

## <a name="arguments"></a>Аргументы

* *Лефттабле*: **левая** таблица или табличное выражение, иногда называемое **внешней** таблицей, строки которой должны быть объединены. Отмечается как `$left` .

* *Ригхттабле*: **правильная** таблица или табличное выражение, иногда называемое **внутренней** таблицей, строки которой должны быть объединены. Отмечается как `$right` .

* *Attributes*: одно или несколько **правил** с разделителями-запятыми, описывающих, как строки из *лефттабле* сопоставляются со строками из *ригхттабле*. С помощью логического оператора вычисляется несколько правил `and` .

  **Правило** может быть одним из следующих:

  |Тип правила        |Синтаксис          |Predicate    |
  |-----------------|--------------|-------------------------|
  |Равенство по имени |*ColumnName*    |`where`*Лефттабле*. *ColumnName* `==` *Ригхттабле*. *ColumnName*|
  |Равенство по значению|`$left.`*Лефтколумн* `==` `$right.` *Ригхтколумн*|`where``$left.` *LeftColumn* `==` Лефтколумн `$right.` *Ригхтколумн*       |

    > [!NOTE]
    > Для "Equality по значению" имена столбцов *должны* уточняться применимой таблицей владельца, обозначенной `$left` `$right` нотацией и.

* *Жоинпараметерс*: ноль или больше параметров, разделенных пробелами, в *Name* виде `=` *значения* имени, которое управляет поведением операции сопоставления строк и плана выполнения. Поддерживаются следующие параметры:

    ::: zone pivot="azuredataexplorer"

    |Имя параметра           |Значения                                        |Описание:                                  |
    |---------------|----------------------------------------------|---------------------------------------------|
    |`kind`         |Разновидности оператора соединения|См. [Флаги соединений](#join-flavors)|                                             |
    |`hint.remote`  |`auto`, `left`, `local`, `right`              |См. раздел [соединение между кластерами](joincrosscluster.md) .|
    |`hint.strategy`|Указания выполнения                               |См. [указания по соединению](#join-hints)                |

    ::: zone-end

    ::: zone pivot="azuremonitor"

    |Имя           |Значения                                        |Описание:                                  |
    |---------------|----------------------------------------------|---------------------------------------------|
    |`kind`         |Разновидности оператора соединения|См. [Флаги соединений](#join-flavors)|                                             |
    |`hint.remote`  |`auto`, `left`, `local`, `right`              |                                             |
    |`hint.strategy`|Указания выполнения                               |См. [указания по соединению](#join-hints)                |

    ::: zone-end

> [!WARNING]
> Если `kind` параметр не указан, используется флаг соединений по умолчанию `innerunique` . Это отличается от некоторых других продуктов аналитики, которые имеют `inner` разновидность по умолчанию.  Ознакомьтесь с вариантами [Join](#join-flavors) , чтобы понять различия и убедиться, что запрос возвращает предполагаемые результаты.

## <a name="returns"></a>Возвращаемое значение

**Схема вывода зависит от разновидности объединения:**

| Разновидность присоединение | Схема вывода |
|---|---|
|`kind=leftanti`, `kind=leftsemi`| Таблица результатов содержит только столбцы из левой части.|
| `kind=rightanti`, `kind=rightsemi` | Таблица результатов содержит только столбцы из правой части.|
|  `kind=innerunique`, `kind=inner`, `kind=leftouter`, `kind=rightouter`, `kind=fullouter` |  Столбец для каждого столбца в каждой из двух таблиц, в том числе соответствующие ключи. В случае конфликта имен столбцы в правой части будут автоматически переименованы. |
   
**Выходные записи зависят от флага объединения:**

   > [!NOTE]
   > Если есть несколько строк с одинаковыми значениями для этих полей, вы получите строки для всех комбинаций.
   > Соответствие — это строки из обеих таблиц, у которых совпадают значения всех полей `on` .

| Разновидность присоединение | Выходные записи |
|---|---|
|`kind=leftanti`, `kind=leftantisemi`| Возвращает все записи с левой стороны, не имеющие соответствий справа|
| `kind=rightanti`, `kind=rightantisemi`| Возвращает все записи с правой стороны, у которых нет совпадений слева.|
| `kind`Unspecified`kind=innerunique`| Каждому значению ключа `on` соответствует только одна строка из левой части. Выходные данные содержат по одной строке для каждого соответствия этой строки со строками из правой части.|
| `kind=leftsemi`| Возвращает все записи из левой части, имеющие совпадения справа. |
| `kind=rightsemi`| Возвращает все записи с правой стороны, имеющие совпадения слева. |
|`kind=inner`| Содержит строку в выходных данных для каждого сочетания совпадающих строк слева и справа. |
| `kind=leftouter` (или `kind=rightouter`, или `kind=fullouter`)| Содержит по одной строке для каждой строки слева и справа, даже если она не имеет совпадения. Непарные выходные ячейки содержат значения NULL. |

> [!TIP]
> Для лучшей производительности, если одна таблица всегда меньше другой, используйте ее в качестве левой (перенаправленной) стороны объединения.

## <a name="example"></a>Пример

Получение расширенных действий из `login` , в которых некоторые записи отмечаются как начало и конец действия.

```kusto
let Events = MyLogTable | where type=="Event" ;
Events
| where Name == "Start"
| project Name, City, ActivityId, StartTime=timestamp
| join (Events
    | where Name == "Stop"
        | project StopTime=timestamp, ActivityId)
    on ActivityId
| project City, ActivityId, StartTime, StopTime, Duration = StopTime - StartTime
```

```kusto
let Events = MyLogTable | where type=="Event" ;
Events
| where Name == "Start"
| project Name, City, ActivityIdLeft = ActivityId, StartTime=timestamp
| join (Events
        | where Name == "Stop"
        | project StopTime=timestamp, ActivityIdRight = ActivityId)
    on $left.ActivityIdLeft == $right.ActivityIdRight
| project City, ActivityId, StartTime, StopTime, Duration = StopTime - StartTime
```

## <a name="join-flavors"></a>Разновидности оператора соединения

Точная разновидность оператора Join указывается с помощью ключевого слова *Kind* . Поддерживаются следующие разновидности оператора Join:

|Тип и разновидность присоединение|Описание:|
|--|--|
|[`innerunique`](#default-join-flavor)(или пустое значение по умолчанию)|Внутреннее соединение с дедупликацией левой стороны|
|[`inner`](#inner-join-flavor)|Стандартное внутреннее соединение|
|[`leftouter`](#left-outer-join-flavor)|левое внешнее соединение.|
|[`rightouter`](#right-outer-join-flavor)|Правое внешнее соединение|
|[`fullouter`](#full-outer-join-flavor)|Полное внешнее соединение|
|[`leftanti`](#left-anti-join-flavor), [`anti`](#left-anti-join-flavor) или[`leftantisemi`](#left-anti-join-flavor)|Левое сглаживание|
|[`rightanti`](#right-anti-join-flavor) или [`rightantisemi`](#right-anti-join-flavor)|Правое сглаживание|
|[`leftsemi`](#left-semi-join-flavor)|Левое соединение|
|[`rightsemi`](#right-semi-join-flavor)|Правое соединение|

### <a name="default-join-flavor"></a>Разновидность соединений по умолчанию

Флаг соединений по умолчанию — это внутреннее соединение с дедупликацией левой стороны. Реализация соединений по умолчанию полезна в типичных сценариях анализа журнала/трассировки, где необходимо сопоставить два события, каждое из которых соответствует определенному критерию фильтрации, под одним и тем же ИДЕНТИФИКАТОРом корреляции. Вы хотите вернуть все представления об этом представлении и пропустить несколько представлений участвующих записей трассировки.

``` 
X | join Y on Key
 
X | join kind=innerunique Y on Key
```

Для объяснения операции объединения используются следующие два образца таблиц.

**Таблица X**

|Key |Значение1
|---|---
|а |1
|b |2
|b |3
|с |4

**Таблица Y**

|Key |Значение2
|---|---
|b |10
|с |20
|с |30
|d |40

Соединение по умолчанию выполняет внутреннее соединение после дедупликации левой части ключа объединения (в результате дедупликации сохраняется первая запись).

С учетом этой инструкции:`X | join Y on Key`

эффективная левая сторона объединения, таблица X после дедупликации, будет выглядеть следующим образом:

|Key |Значение1
|---|---
|а |1
|b |2
|с |4

а в результате объединения мы получим следующее:

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|

> [!NOTE]
> Ключи "a" и "d" не отображаются в выходных данных, так как в левой и правой сторонах нет совпадающих ключей.

### <a name="inner-join-flavor"></a>Разновидность внутреннего подключения

Функция внутреннего объединения похожа на стандартное внутреннее соединение из мира SQL. Выходная запись создается, когда запись с левой стороны имеет тот же ключ объединения, что и запись с правой стороны.

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=inner Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|

> [!NOTE]
> * (b, 10) с правой стороны был соединен дважды: с обоими (b, 2) и (b, 3) слева.
> * (c, 4) слева была соединена дважды: с обоими (c, 20) и (c, 30) справа.

### <a name="innerunique-join-flavor"></a>Иннеруникуе-флаг подключения
 
Используйте **флаг иннеруникуе-Join** для дедупликации ключей с левой стороны. Результат будет представлять собой строку в выходных данных каждого сочетания повторяющихся левых клавиш и правых клавиш.

> [!NOTE]
> **иннеруникуе** может выдать два возможных выхода, и оба имеют правильный результат.
В первом выводе оператор Join случайным образом выбрал первый ключ, который отображается в T1, со значением val 1.1 и соответствующим ему с помощью ключей T2.
Во втором выводе оператор Join случайным образом выбирает второй ключ, который отображается в T1, со значением "Val 1.2" и сопоставляет его с ключами T2.

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3",
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
```

|ключ|value|key1|value1|
|---|---|---|---|
|1|Val 1.1|1|Val 1.3|
|1|Val 1.1|1|Val 1.4|

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
```

|ключ|value|key1|value1|
|---|---|---|---|
|1|Val 1.2|1|Val 1.3|
|1|Val 1.2|1|Val 1.4|

* Kusto оптимизирована для push-фильтров, которые поступают после `join` , в сторону соответствующей стороны подключения, по возможности влево или вправо.

* В некоторых случаях используется разновидность **иннеруникуе** , и фильтр распространяется на левую сторону объединения. Эта разновидность будет автоматически распространена, а ключи, применяемые к этому фильтру, всегда будут отображаться в выходных данных.
    
* Используйте приведенный выше пример и добавьте фильтр `where value == "val1.2" ` . Он всегда будет давать второй результат и никогда не будет давать первый результат для наборов данных:

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
| where value == "val1.2"
```

|ключ|value|key1|value1|
|---|---|---|---|
|1|Val 1.2|1|Val 1.3|
|1|Val 1.2|1|Val 1.4|

### <a name="left-outer-join-flavor"></a>Разновидность левого внешнего объединения

Результат левого внешнего объединения для таблиц X и Y всегда содержит все записи левой таблицы (X), даже если условием объединения не удается найти совпадающую запись в правой таблице (Y).

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftouter Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|
|а|1|||

### <a name="right-outer-join-flavor"></a>Конфигурация правого внешнего объединения

Правое внешнее соединение напоминает левое внешнее соединение, но обработка таблиц в обратную.

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightouter Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|
|||d|40|

### <a name="full-outer-join-flavor"></a>Полное внешнее соединение, разновидность

Полное внешнее соединение объединяет результат применения двух левых и правых внешних соединений. Если записи в соединяемых таблицах не совпадают, результирующий набор будет иметь `null` значения для каждого столбца таблицы, в которой отсутствует соответствующая строка. Для совпадающих записей в результирующем наборе создается одна строка, содержащая поля, заполненные из обеих таблиц.

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=fullouter Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|
|||d|40|
|а|1|||

### <a name="left-anti-join-flavor"></a>Разновидность защиты от левого объединения

Левое сглаживание возвращает все записи с левой стороны, которые не соответствуют записям с правой стороны.

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftanti Y on Key
```

|Key|Значение1|
|---|---|
|а|1|

> [!NOTE]
> Антисоединение моделирует запрос NOT IN.

### <a name="right-anti-join-flavor"></a>Вариант защиты от несоединений

Правое сглаживание возвращает все записи с правой стороны, которые не соответствуют записям с левой стороны.

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightanti Y on Key
```

|Key|Значение2|
|---|---|
|d|40|

> [!NOTE]
> Антисоединение моделирует запрос NOT IN.

### <a name="left-semi-join-flavor"></a>Флаг левой точки подключения

Левое соединение возвращает все записи с левой стороны, соответствующие записи с правой стороны. Возвращаются только столбцы из левой части.

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftsemi Y on Key
```

|Key|Значение1|
|---|---|
|b|3|
|b|2|
|с|4|

### <a name="right-semi-join-flavor"></a>Правая половина объединения

Правое частичное соединение возвращает все записи с правой стороны, соответствующие записи с левой стороны. Возвращаются только столбцы из правой части.

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightsemi Y on Key
```

|Key|Значение2|
|---|---|
|b|10|
|с|20|
|с|30|

### <a name="cross-join"></a>Перекрестное соединение

Kusto изначально не предоставляет версию для перекрестного объединения. Невозможно пометить оператор с помощью `kind=cross` .
Для имитации используйте фиктивный ключ.

`X | extend dummy=1 | join kind=inner (Y | extend dummy=1) on dummy`

## <a name="join-hints"></a>Указания по соединению

`join`Оператор поддерживает ряд подсказок, управляющих способом выполнения запроса.
Эти подсказки не изменяют семантическую семантику `join` , но могут повлиять на ее производительность.

Указания по соединению описаны в следующих статьях:

* `hint.shufflekey=<key>`и `hint.strategy=shuffle`  -  [случайный выбор запроса](shufflequery.md)
* `hint.strategy=broadcast` - [широковещательное соединение](broadcastjoin.md)
* `hint.remote=<strategy>` - [соединение между кластерами](joincrosscluster.md)
