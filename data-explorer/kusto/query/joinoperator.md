---
title: оператор JOIN в Azure обозреватель данных | Документация Майкрософт
description: В этой статье описывается оператор JOIN в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
zone_pivot_group_filename: data-explorer/zone-pivot-groups.json
zone_pivot_groups: kql-flavors
ms.openlocfilehash: 2961f27226175fe81b7d9c82a6366b36134d805f
ms.sourcegitcommit: 31af2dfa75b5a2f59113611cf6faba0b45d29eb5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/05/2020
ms.locfileid: "84454122"
---
# <a name="join-operator"></a>Оператор join

объединение строк двух таблиц для формирования новой таблицы путем сопоставления значений указанных столбцов каждой таблицы.

```kusto
Table1 | join (Table2) on CommonColumn, $left.Col1 == $right.Col2
```

**Синтаксис**

*Лефттабле* `|` `join`[*Жоинпараметерс*] `(` *RightTable* `)` `on` *атрибуты* ригхттабле

**Аргументы**

* *Лефттабле*: **левая** таблица или табличное выражение (иногда называемое **внешней** таблицей), строки которых должны быть объединены. Отмечается как `$left` .

* *Ригхттабле*: **подходящую** таблицу или табличное выражение (иногда называемое **внутренней* таблицей), строки которых должны быть объединены. Отмечается как `$right` .

* *Attributes*: одно или несколько (разделенных запятыми) правил, описывающих, как строки из *лефттабле* сопоставляются со строками из *ригхттабле*. С помощью логического оператора вычисляется несколько правил `and` .
  Правило может быть одним из следующих:

  |Тип правила        |Синтаксис                                          |Predicate                                                      |
  |-----------------|------------------------------------------------|---------------------------------------------------------------|
  |Равенство по имени |*ColumnName*                                    |`where`*Лефттабле*. *ColumnName* `==` *Ригхттабле*. *ColumnName*|
  |Равенство по значению|`$left.`*Лефтколумн* `==` `$right.` *Ригхтколумн*|`where``$left.` *LeftColumn* `==` Лефтколумн `$right.` *Ригхтколумн*       |

> [!NOTE]
> В случае "равенства по значению" имена столбцов *должны* уточняться применимой таблицей владельца, обозначенной `$left` `$right` нотацией и.

* *Жоинпараметерс*: ноль или более (разделенных пробелами) параметров в виде значения *имени* `=` *Value* , которое управляет поведением операции сопоставления строк и плана выполнения. Поддерживаются следующие параметры: 

::: zone pivot="azuredataexplorer"

  |Имя           |Значения                                        |Описание                                  |
  |---------------|----------------------------------------------|---------------------------------------------|
  |`kind`         |Разновидности оператора соединения|См. [Флаги соединений](#join-flavors)|                                             |
  |`hint.remote`  |`auto`, `left`, `local`, `right`              |См. раздел [соединение между кластерами](joincrosscluster.md) .|
  |`hint.strategy`|Указания выполнения                               |См. [указания по соединению](#join-hints)                |

::: zone-end

::: zone pivot="azuremonitor"

  |Имя           |Значения                                        |Описание                                  |
  |---------------|----------------------------------------------|---------------------------------------------|
  |`kind`         |Разновидности оператора соединения|См. [Флаги соединений](#join-flavors)|                                             |
  |`hint.remote`  |`auto`, `left`, `local`, `right`              |                                             |
  |`hint.strategy`|Указания выполнения                               |См. [указания по соединению](#join-hints)                |

::: zone-end


> [!WARNING]
> Флаг объединения по умолчанию, если `kind` не указан, имеет значение `innerunique` . Это отличается от некоторых других продуктов аналитики, которые имеют `inner` разновидность по умолчанию. Внимательно прочтите [следующие](#join-flavors) сведения, чтобы понять различия между различными типами и убедиться, что запрос возвращает предполагаемые результаты.

**Возвращает**

Схема вывода зависит от разновидности объединения:

 * `kind=leftanti`, `kind=leftsemi`:

     Таблица результатов содержит только столбцы из левой части.

     
 * `kind=rightanti`, `kind=rightsemi`:

     Таблица результатов содержит только столбцы из правой части.

     
*  `kind=innerunique`, `kind=inner`, `kind=leftouter`, `kind=rightouter`, `kind=fullouter`

     Столбец для каждого столбца в каждой из двух таблиц, в том числе соответствующие ключи. В случае конфликта имен столбцы в правой части будут автоматически переименованы.

     
Выходные записи зависят от разновидности объединения:

 * `kind=leftanti`, `kind=leftantisemi`

     Возвращает все записи с левой стороны, у которых нет совпадений справа.     
     
 * `kind=rightanti`, `kind=rightantisemi`

     Возвращает все записи с правой стороны, у которых нет совпадений слева.  
      
*  `kind=innerunique`, `kind=inner`, `kind=leftouter`, `kind=rightouter`, `kind=fullouter`, `kind=leftsemi`, `kind=rightsemi`

    Строка для каждого соответствия во входных таблицах. Совпадение — это строка, выбранная из одной таблицы, которая имеет то же значение для всех `on` полей, что и строка в другой таблице с этими ограничениями:

   - `kind`Unspecified`kind=innerunique`

    Каждому значению ключа `on` соответствует только одна строка из левой части. Выходные данные содержат по одной строке для каждого соответствия этой строки со строками из правой части.
    
   - `kind=leftsemi`
   
    Возвращает все записи из левой части, имеющие совпадения справа.
    
   - `kind=rightsemi`
   
       Возвращает все записи с правой стороны, имеющие совпадения слева.

   - `kind=inner`
 
    Строка в выходных данных для каждой комбинации соответствующих строк из левой и правой частей.

   - `kind=leftouter` (или `kind=rightouter`, или `kind=fullouter`)

    Кроме внутренних соответствий есть также строка для каждой строки в левой и (или) правой части, даже при отсутствии соответствия. В этом случае ячейки выходных данных без соответствий содержат значения NULL.
    Если есть несколько строк с одинаковыми значениями для этих полей, вы получите строки для всех комбинаций.

 

**"Советы"**

Обеспечить наилучшую производительность можно так.

* Если одна таблица меньше другой, используйте ее в качестве левой (перенаправленной) части объединенных данных.

**Пример**

Получите расширенные сведения о действиях из журнала, в котором некоторые записи указывают на время начала и конца действия. 

```kusto
let Events = MyLogTable | where type=="Event" ;
Events
| where Name == "Start"
| project Name, City, ActivityId, StartTime=timestamp
| join (Events
    | where Name == "Stop"
        | project StopTime=timestamp, ActivityId)
    on ActivityId
| project City, ActivityId, StartTime, StopTime, Duration = StopTime - StartTime
```

```kusto
let Events = MyLogTable | where type=="Event" ;
Events
| where Name == "Start"
| project Name, City, ActivityIdLeft = ActivityId, StartTime=timestamp
| join (Events
        | where Name == "Stop"
        | project StopTime=timestamp, ActivityIdRight = ActivityId)
    on $left.ActivityIdLeft == $right.ActivityIdRight
| project City, ActivityId, StartTime, StopTime, Duration = StopTime - StartTime
```

[Подробнее об этом примере](./samples.md#get-sessions-from-start-and-stop-events).

## <a name="join-flavors"></a>Разновидности оператора соединения

Точная разновидность оператора соединения определяется с помощью ключевого слова kind. На сегодняшний день Kusto поддерживает следующие разновидности оператора Join: 

|Тип соединения|Описание|
|--|--|
|[`innerunique`](#default-join-flavor)(или пустое значение по умолчанию)|Внутреннее соединение с дедупликацией левой стороны|
|[`inner`](#inner-join)|Стандартное внутреннее соединение|
|[`leftouter`](#left-outer-join)|левое внешнее соединение.|
|[`rightouter`](#right-outer-join)|Правое внешнее соединение|
|[`fullouter`](#full-outer-join)|Полное внешнее соединение|
|[`leftanti`](#left-anti-join), [`anti`](#left-anti-join) или[`leftantisemi`](#left-anti-join)|Левое сглаживание|
|[`rightanti`](#right-anti-join)ни[`rightantisemi`](#right-anti-join)|Правое сглаживание|
|[`leftsemi`](#left-semi-join)|Левое соединение|
|[`rightsemi`](#right-semi-join)|Правое соединение|

### <a name="inner-and-innerunique-join-operator-flavors"></a>разновидности операторов INNER и иннеруникуе Join

-    При использовании **флага внутреннего объединения**в выходных данных будет выведена строка для каждой комбинации совпадающих строк слева и справа без левых ключей. Выходные данные будут декартово произведением левых и правых ключей.
    Пример **внутреннего объединения**:

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = inner
    t2
on key
```

|key|value|key1|value1|
|---|---|---|---|
|1|Val 1.2|1|Val 1.3|
|1|Val 1.1|1|Val 1.3|
|1|Val 1.2|1|Val 1.4|
|1|Val 1.1|1|Val 1.4|

-    При использовании **флага иннеруникуе Join** параметры будут дедублироваться с левой стороны, а в выходных данных будет указана строка, состоящая из каждого сочетания повторяющихся левых и правых ключей.
    Пример **иннеруникуе Join** для тех же наборов данных, которые использовались выше. Обратите внимание, что **иннеруникуеская** версия для этого случая может выдавать два возможных выхода, и оба имеют правильный результат.
    В первом выводе оператор Join случайным образом выбрал первый ключ, который отображается в T1 со значением val 1.1 и совпал с ключами T2, а во второй — оператор Join случайным образом выбрал второй ключ в T1, который имеет значение "Val 1.2" и совпал с ключами T2:

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
```

|key|value|key1|value1|
|---|---|---|---|
|1|Val 1.1|1|Val 1.3|
|1|Val 1.1|1|Val 1.4|

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
```

|key|value|key1|value1|
|---|---|---|---|
|1|Val 1.2|1|Val 1.3|
|1|Val 1.2|1|Val 1.4|


-    Kusto оптимизирована для принудительных фильтров, которые появляются после `join` достижения соответствующей стороны подключения, если это возможно.
    Иногда, когда используется **иннеруникуе** , а фильтр может быть передан в левую сторону объединения, он будет распространяться автоматически, а ключи, которые применяются к этому фильтру, всегда будут отображаться в выходных данных.
    Например, использование приведенного выше примера и Добавление фильтра ` where value == "val1.2" ` всегда приведут к второму результату и никогда не выдаст первый результат для используемых наборов данных:

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
| where value == "val1.2"
```

|key|value|key1|value1|
|---|---|---|---|
|1|Val 1.2|1|Val 1.3|
|1|Val 1.2|1|Val 1.4|
 
### <a name="default-join-flavor"></a>Разновидность соединений по умолчанию
    
    X | join Y on Key
    X | join kind=innerunique Y on Key
     
Для объяснения операции объединения используются два образца таблиц: 
 
Таблица X 

|Key |Значение1 
|---|---
|а |1 
|b |2 
|b |3 
|c |4 

Таблица Y 

|Key |Значение2 
|---|---
|b |10 
|c |20 
|c |30 
|d |40 
 
Соединение по умолчанию выполняет внутреннее соединение после удаления дубликатов в левой части по ключу соединения (первая запись при дедупликации сохраняется). Рассмотрим эту инструкцию: 

    X | join Y on Key 

эффективная левая сторона соединения (таблица X после удаления дубликатов) будет следующей: 

|Key |Значение1 
|---|---
|а |1 
|b |2 
|c |4 

а в результате объединения мы получим следующее: 

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|2|b|10|
|c|4|c|20|
|c|4|c|30|


(Обратите внимание, что ключи "a" и "d" не отображаются в выходных данных, так как в левой и правой сторонах нет совпадающих ключей). 
 
(Исторически, это была первая реализация объединения, поддерживаемая первоначальной версией Kusto; она полезна в типичных сценариях анализа журнала/трассировки, в которых нам нужно сопоставить два события (каждый критерий фильтрации) под одним и тем же ИДЕНТИФИКАТОРом корреляции, и получить все представления о том, что мы искали, игнорируя несколько представлений участвующих записей трассировки.)
 
### <a name="inner-join"></a>внутреннее соединение,

Это стандартное внутреннее соединение SQL. Выходная запись образуется каждый раз, когда у записи с левой стороны есть тот же ключ соединения, что и у записи с правой стороны. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=inner Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|c|4|c|20|
|c|4|c|30|

Обратите внимание, что (b, 10), идущее от правой части, соединено дважды: с обоими (b, 2) и (b, 3) слева; Кроме того, (c, 4) слева был соединен дважды: с обоими (c, 20) и (c, 30) справа. 

### <a name="left-outer-join"></a>левое внешнее соединение. 

Результат левого внешнего соединения для таблиц X и Y всегда содержит все записи из левой таблицы (X), даже если условие соединения не соответствует ни одной из записей из правой таблицы (Y). 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftouter Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|c|4|c|20|
|c|4|c|30|
|а|1|||

 
### <a name="right-outer-join"></a>Правое внешнее соединение 

Напоминает левое внешнее соединение, но обработка таблиц осуществляется в обратном порядке. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightouter Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|c|4|c|20|
|c|4|c|30|
|||d|40|

 
### <a name="full-outer-join"></a>Полное внешнее соединение 

По сути, полное внешнее соединение объединяет результаты, полученные после применения левого и правого внешних соединений. Если записи в соединяемых таблицах не совпадают, результирующий набор будет иметь значения NULL для каждого столбца таблицы, в котором отсутствует соответствующая строка. Для тех записей, для которых соответствия нет, в результирующий набор будет добавлена одна строка (содержащая поля, заполненные из обеих таблиц). 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=fullouter Y on Key
```

|Key|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|c|4|c|20|
|c|4|c|30|
|||d|40|
|а|1|||

 
### <a name="left-anti-join"></a>Левое сглаживание

Левое Антисоединение возвращает все записи с левой стороны, которые не соответствуют какой бы то ни было записи из правой части. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftanti Y on Key
```

|Key|Значение1|
|---|---|
|а|1|

Антисоединение моделирует запрос NOT IN. 

### <a name="right-anti-join"></a>Правое сглаживание

Правое Антисоединение возвращает все записи с правой стороны, которые не соответствуют записям из левой части. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightanti Y on Key
```

|Key|Значение2|
|---|---|
|d|40|

Антисоединение моделирует запрос NOT IN. 

### <a name="left-semi-join"></a>Левое соединение

Левое соединение возвращает все записи с левой стороны, соответствующие записи с правой стороны. Возвращаются только столбцы из левой части. 

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftsemi Y on Key
```

|Key|Значение1|
|---|---|
|b|3|
|b|2|
|c|4|

### <a name="right-semi-join"></a>Правое соединение

Правое соединение возвращает все записи с правой стороны, соответствующие записи с левой стороны. Возвращаются только столбцы из правой части. 

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightsemi Y on Key
```

|Key|Значение2|
|---|---|
|b|10|
|c|20|
|c|30|


### <a name="cross-join"></a>Перекрестное соединение

Kusto изначально не предоставляет флаги перекрестного объединения (т. е. оператор нельзя помечать на `kind=cross` ).
Тем не менее, не сложно имитировать это, если поступит с помощью фиктивного ключа:

    X | extend dummy=1 | join kind=inner (Y | extend dummy=1) on dummy

## <a name="join-hints"></a>Указания по соединению

`join`Оператор поддерживает ряд подсказок, управляющих способом выполнения запроса.
Они не изменяют семантическую семантику `join` , но могут повлиять на его производительность.

Указания по соединению описаны в следующих статьях: 
* `hint.shufflekey=<key>`и `hint.strategy=shuffle`  -  [случайный выбор запроса](shufflequery.md)
* `hint.strategy=broadcast` - [широковещательное соединение](broadcastjoin.md)
* `hint.remote=<strategy>` - [соединение между кластерами](joincrosscluster.md)
