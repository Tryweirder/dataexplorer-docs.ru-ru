---
title: присоединиться к оператору - Azure Data Explorer Документы Майкрософт
description: В этой статье описывается оператор соединения в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
zone_pivot_group_filename: data-explorer/zone-pivot-groups.json
zone_pivot_groups: kql-flavors
ms.openlocfilehash: 86d883c8d0214d278099260fa2406b91b776b4d1
ms.sourcegitcommit: 01eb9aaf1df2ebd5002eb7ea7367a9ef85dc4f5d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81765815"
---
# <a name="join-operator"></a>Оператор join

объединение строк двух таблиц для формирования новой таблицы путем сопоставления значений указанных столбцов каждой таблицы.

```kusto
Table1 | join (Table2) on CommonColumn, $left.Col1 == $right.Col2
```

**Синтаксис**

*LeftTable* `|` `join` -*Соедините Параметры* `(` - *Правые Атрибуты* `)` `on` *Attributes*

**Аргументы**

* *LeftTable*: **Левая** таблица или табулярное выражение (иногда называемое **внешней** таблицей), строки которого должны быть объединены. Обозначено `$left`как .

* *RightTable*: **Правая** таблица или табулярное выражение (иногда называемое*внутренней* таблицей), строки которого должны быть объединены. Обозначено `$right`как .

* *Атрибуты*: Один или несколько (запятой разделенных) правил, описывающих, как строки из *LeftTable* сопоставляются с строками из *RightTable*. Несколько правил оцениваются с помощью логического `and` оператора.
  Правило может быть одним из:

  |Вид правила        |Синтаксис                                          |Predicate                                                      |
  |-----------------|------------------------------------------------|---------------------------------------------------------------|
  |Равенство по имени |*ColumnName*                                    |`where`*LeftTable*. *КолонкаНазаRight* `==` *RightTable*. *КолонкаИмя*|
  |Равенство по стоимости|`$left.`*Леваяколонна* `==` `$right.` *правая колонна*|`where``$left.` *Леваяколонна* `==` `$right.` *правая колонна*       |

> [!NOTE]
> В случае "равенства по стоимости" имена столбцов *должны* быть квалифицированы `$right` с соответствующей таблицей владельца, обозначаемой и обозначенной и обозначенными. `$left`

* *Присоединиться к Параметры*: Нулевой или более (пространство-отделены) параметры в виде *значения* *имени,* `=` которые контролируют поведение строки матча операции и выполнения плана. Поддерживаются следующие параметры: 

::: zone pivot="azuredataexplorer"

  |Имя           |Значения                                        |Описание                                  |
  |---------------|----------------------------------------------|---------------------------------------------|
  |`kind`         |Разновидности оператора соединения|Смотрите [Присоединиться к ароматизаторам](#join-flavors)|                                             |
  |`hint.remote`  |`auto`, `left`, `local`, `right`              |Посмотреть [соединение кросс-кластера](joincrosscluster.md)|
  |`hint.strategy`|Подсказки исполнения                               |Посмотреть [подсказки Join](#join-hints)                |

::: zone-end

::: zone pivot="azuremonitor"

  |Имя           |Значения                                        |Описание                                  |
  |---------------|----------------------------------------------|---------------------------------------------|
  |`kind`         |Разновидности оператора соединения|Смотрите [Присоединиться к ароматизаторам](#join-flavors)|                                             |
  |`hint.remote`  |`auto`, `left`, `local`, `right`              |                                             |
  |`hint.strategy`|Подсказки исполнения                               |Посмотреть [подсказки Join](#join-hints)                |

::: zone-end


> [!WARNING]
> Вкус соединения по `kind` умолчанию, если `innerunique`не указан, является . Это отличается от некоторых других `inner` продуктов аналитики, которые имеют в качестве вкуса по умолчанию. Пожалуйста, внимательно прочитайте [ниже,](#join-flavors) чтобы понять различия между различными видами и убедиться, что запрос дает предполагаемые результаты.

**Возвращает**

Схема вывода зависит от вкуса соединения:

 * `kind=leftanti`, `kind=leftsemi`:

     Таблица результатов содержит только столбцы с левой стороны.

     
 * `kind=rightanti`, `kind=rightsemi`:

     Таблица результатов содержит столбцы только с правой стороны.

     
*  `kind=innerunique`, `kind=inner`, `kind=leftouter`, `kind=rightouter`, `kind=fullouter`

     Столбец для каждого столбца в каждой из двух таблиц, в том числе соответствующие ключи. В случае конфликта имен столбцы в правой части будут автоматически переименованы.

     
Выходные записи зависят от вкуса соединения:

 * `kind=leftanti`, `kind=leftantisemi`

     Возвращает все записи с левой стороны, которые не имеют совпадений справа.     
     
 * `kind=rightanti`, `kind=rightantisemi`

     Возвращает все записи с правой стороны, которые не имеют совпадений слева.  
      
*  `kind=innerunique`, `kind=inner`, `kind=leftouter`, `kind=rightouter`, `kind=fullouter`, `kind=leftsemi`, `kind=rightsemi`

    Строка для каждого соответствия во входных таблицах. Совпадение — это строка, выбранная из одной `on` таблицы, которая имеет одинаковое значение для всех полей, как и строка в другой таблице с этими ограничениями:

   - `kind`Неопределенное`kind=innerunique`

    Каждому значению ключа `on` соответствует только одна строка из левой части. Выходные данные содержат по одной строке для каждого соответствия этой строки со строками из правой части.
    
   - `kind=leftsemi`
   
    Возвращает все записи с левой стороны, которые имеют матчи справа.
    
   - `kind=rightsemi`
   
       Возвращает все записи с правой стороны, которые имеют матчи слева.

   - `kind=inner`
 
    Строка в выходных данных для каждой комбинации соответствующих строк из левой и правой частей.

   - `kind=leftouter` (или `kind=rightouter`, или `kind=fullouter`)

    Кроме внутренних соответствий есть также строка для каждой строки в левой и (или) правой части, даже при отсутствии соответствия. В этом случае ячейки выходных данных без соответствий содержат значения NULL.
    Если есть несколько строк с одинаковыми значениями для этих полей, вы получите строки для всех комбинаций.

 

**Советы**

Обеспечить наилучшую производительность можно так.

* Если одна таблица меньше другой, используйте ее в качестве левой (перенаправленной) части объединенных данных.

**Пример**

Получите расширенные сведения о действиях из журнала, в котором некоторые записи указывают на время начала и конца действия. 

```kusto
let Events = MyLogTable | where type=="Event" ;
Events
| where Name == "Start"
| project Name, City, ActivityId, StartTime=timestamp
| join (Events
    | where Name == "Stop"
        | project StopTime=timestamp, ActivityId)
    on ActivityId
| project City, ActivityId, StartTime, StopTime, Duration = StopTime - StartTime
```

```kusto
let Events = MyLogTable | where type=="Event" ;
Events
| where Name == "Start"
| project Name, City, ActivityIdLeft = ActivityId, StartTime=timestamp
| join (Events
        | where Name == "Stop"
        | project StopTime=timestamp, ActivityIdRight = ActivityId)
    on $left.ActivityIdLeft == $right.ActivityIdRight
| project City, ActivityId, StartTime, StopTime, Duration = StopTime - StartTime
```

[Подробнее об этом примере](./samples.md#activities).

## <a name="join-flavors"></a>Разновидности оператора соединения

Точная разновидность оператора соединения определяется с помощью ключевого слова kind. На сегодняшний день Kusto поддерживает следующие ароматы оператора соединения: 

|Тип соединения|Описание|
|--|--|
|[`innerunique`](#default-join-flavor)(или пустой по умолчанию)|Внутреннее соединение с левой стороны deduplication|
|[`inner`](#inner-join)|Стандартное внутреннее соединение|
|[`leftouter`](#left-outer-join)|левое внешнее соединение.|
|[`rightouter`](#right-outer-join)|Правое внешнее соединение|
|[`fullouter`](#full-outer-join)|Полное внешнее соединение|
|[`leftanti`](#left-anti-join), [`anti`](#left-anti-join) или[`leftantisemi`](#left-anti-join)|Левый анти-присоединиться|
|[`rightanti`](#right-anti-join)Или[`rightantisemi`](#right-anti-join)|Право анти присоединиться|
|[`leftsemi`](#left-semi-join)|Левый полуприсоединиться|
|[`rightsemi`](#right-semi-join)|Право полу присоединиться|

### <a name="inner-and-innerunique-join-operator-flavors"></a>внутренний и innerunique присоединиться к оператору вкусов

-    При **использовании внутреннего вкуса соединения,** будет строка в выходе для каждой комбинации соответствующих строк слева и справа без дедоктирования левых клавиш. Выход будет декартовый продукт левого и правого ключей.
    Пример **внутреннего соединения:**

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = inner
    t2
on key
```

|ключ|значение|key1|value1|
|---|---|---|---|
|1|val1.2|1|val1.3|
|1|val1.1|1|val1.3|
|1|val1.2|1|val1.4|
|1|val1.1|1|val1.4|

-    Использование **innerunique присоединиться вкус** будет deduplicate ключи с левой стороны и не будет строки в выходе из каждой комбинации deduplicated левые клавиши и правые ключи.
    Пример **внутреннего соединения** для тех же наборов данных, используемых выше, Пожалуйста, обратите внимание, что **innerunique вкус** для этого случая может дать два возможных выходов и оба являются правильными.
    В первом выходе оператор соединения случайно выбрал первый ключ, который появляется в t1 со значением "val1.1" и сопоставил его с ключами t2, в то время как во втором оператор соединения случайно выбрал второй ключ, который имеет значение "val1.2" и сопоставил его с ключами t2:

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
```

|ключ|значение|key1|value1|
|---|---|---|---|
|1|val1.1|1|val1.3|
|1|val1.1|1|val1.4|

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
```

|ключ|значение|key1|value1|
|---|---|---|---|
|1|val1.2|1|val1.3|
|1|val1.2|1|val1.4|


-    Kusto оптимизирован для нажатия фильтров, которые приходят после `join` соответствующего соединения стороны влево или вправо, когда это возможно.
    Иногда, когда используемый вкус **является innerunique** и фильтр может быть распространен в левую сторону соединения, то он будет распространяться автоматически и ключи, которые применяются к этому фильтру всегда будет отображаться в выходе.
    например, использование приведенного выше ` where value == "val1.2" ` примера и добавление фильтра всегда даст второй результат и никогда не даст первого результата для используемых наборов данных:

```kusto
let t1 = datatable(key:long, value:string)  
[
1, "val1.1",  
1, "val1.2"  
];
let t2 = datatable(key:long, value:string)  
[  
1, "val1.3", 
1, "val1.4"  
];
t1
| join kind = innerunique
    t2
on key
| where value == "val1.2"
```

|ключ|значение|key1|value1|
|---|---|---|---|
|1|val1.2|1|val1.3|
|1|val1.2|1|val1.4|
 
### <a name="default-join-flavor"></a>По умолчанию присоединиться к вкусу
    
    X | join Y on Key
    X | join kind=innerunique Y on Key
     
Давайте использовать две таблицы примеров для объяснения работы соединения: 
 
Таблица X 

|Клавиши |Значение1 
|---|---
|а |1 
|b |2 
|b |3 
|с |4 

Таблица Y 

|Клавиши |Значение2 
|---|---
|b |10 
|с |20 
|с |30 
|d |40 
 
Соединение по умолчанию выполняет внутреннее соединение после удаления дубликатов в левой части по ключу соединения (первая запись при дедупликации сохраняется). Рассмотрим эту инструкцию: 

    X | join Y on Key 

эффективная левая сторона соединения (таблица X после удаления дубликатов) будет следующей: 

|Клавиши |Значение1 
|---|---
|а |1 
|b |2 
|с |4 

а в результате объединения мы получим следующее: 

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join Y on Key
```

|Клавиши|Значение1|Key1|Значение2|
|---|---|---|---|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|


(Обратите внимание, что клавиши 'a' и 'd' не отображаются на выходе, так как не было соответствующих ключей как на левой, так и на правой сторонах). 
 
(Исторически это была первая реализация соединения, поддерживаемого первоначальной версией Kusto; это полезно в типичных сценариях анализа журналов/следов, где мы хотим соотнести два события (каждое из которых соответствует некоторым критерию фильтрации) под одним и тем же идентификатором корреляции и вернуть все видимости явления, которое мы ищем, игнорируя многочисленные видимости записей, способствующих следов.
 
### <a name="inner-join"></a>внутреннее соединение,

Это стандартное внутреннее соединение SQL. Выходная запись образуется каждый раз, когда у записи с левой стороны есть тот же ключ соединения, что и у записи с правой стороны. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=inner Y on Key
```

|Клавиши|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|

Отметим, что (b,10), идущие с правой стороны, были соединены дважды: с обоими (b,2) и (b,3) слева; также (c,4) слева присоединились дважды: с обоими (c,20) и (c,30) справа. 

### <a name="left-outer-join"></a>левое внешнее соединение. 

Результат левого внешнего соединения для таблиц X и Y всегда содержит все записи из левой таблицы (X), даже если условие соединения не соответствует ни одной из записей из правой таблицы (Y). 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftouter Y on Key
```

|Клавиши|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|
|а|1|||

 
### <a name="right-outer-join"></a>Правое внешнее соединение 

Напоминает левое внешнее соединение, но обработка таблиц осуществляется в обратном порядке. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightouter Y on Key
```

|Клавиши|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|
|||d|40|

 
### <a name="full-outer-join"></a>Полное внешнее соединение 

По сути, полное внешнее соединение объединяет результаты, полученные после применения левого и правого внешних соединений. В тех случаях, когда записи в объединенных таблицах не совпадают, набор результатов будет иметь значения NULL для каждого столбца таблицы, в котором отсутствует соответствующий ряд. Для тех записей, для которых соответствия нет, в результирующий набор будет добавлена одна строка (содержащая поля, заполненные из обеих таблиц). 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=fullouter Y on Key
```

|Клавиши|Значение1|Key1|Значение2|
|---|---|---|---|
|b|3|b|10|
|b|2|b|10|
|с|4|с|20|
|с|4|с|30|
|||d|40|
|а|1|||

 
### <a name="left-anti-join"></a>Левый анти-присоединиться

Левый анти-присоединиться возвращает все записи с левой стороны, которые не соответствуют любой записи с правой стороны. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftanti Y on Key
```

|Клавиши|Значение1|
|---|---|
|а|1|

Антисоединение моделирует запрос NOT IN. 

### <a name="right-anti-join"></a>Право анти присоединиться

Право анти присоединиться возвращает все записи с правой стороны, которые не соответствуют любой записи с левой стороны. 
 
```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightanti Y on Key
```

|Клавиши|Значение2|
|---|---|
|d|40|

Антисоединение моделирует запрос NOT IN. 

### <a name="left-semi-join"></a>Левый полуприсоединиться

Левый полу-присоединиться возвращает все записи с левой стороны, которые соответствуют записи с правой стороны. Возвращаются только столбцы с левой стороны. 

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=leftsemi Y on Key
```

|Клавиши|Значение1|
|---|---|
|b|3|
|b|2|
|с|4|

### <a name="right-semi-join"></a>Право полу присоединиться

Право полу присоединиться возвращает все записи с правой стороны, которые соответствуют записи с левой стороны. Возвращаются только столбцы с правой стороны. 

```kusto
let X = datatable(Key:string, Value1:long)
[
    'a',1,
    'b',2,
    'b',3,
    'c',4
];
let Y = datatable(Key:string, Value2:long)
[
    'b',10,
    'c',20,
    'c',30,
    'd',40
];
X | join kind=rightsemi Y on Key
```

|Клавиши|Значение2|
|---|---|
|b|10|
|с|20|
|с|30|


### <a name="cross-join"></a>Крестное соединение

Kusto не обеспечивает вкус кросс-соединения (т.е. вы не можете пометить `kind=cross`оператора).
Это не трудно имитировать это, однако, придумав манекен ключ:

    X | extend dummy=1 | join kind=inner (Y | extend dummy=1) on dummy

## <a name="join-hints"></a>Присоединиться к подсказкам

Оператор `join` поддерживает ряд подсказок, которые контролируют способ выполнения запроса.
Они не меняют семантического, `join`но могут повлиять на его производительность.

Присоединяйтесь к подсказкам, разъясняемым в следующих статьях: 
* `hint.shufflekey=<key>`и `hint.strategy=shuffle`  -  [перетасовать запрос](shufflequery.md)
* `hint.strategy=broadcast` - [трансляция присоединиться](broadcastjoin.md)
* `hint.remote=<strategy>` - [кросс-кластерное соединение](joincrosscluster.md)
