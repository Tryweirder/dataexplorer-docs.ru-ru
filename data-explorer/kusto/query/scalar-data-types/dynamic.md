---
title: Динамический тип данных — Azure обозреватель данных | Документация Майкрософт
description: В этой статье описывается динамический тип данных в обозреватель данных Azure.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/12/2020
ms.openlocfilehash: 8a979d91b008be7a93626aa7f58865cb5466076b
ms.sourcegitcommit: c3bbb9a6bfd7c5506f05afb4968fdc2043a9fbbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/24/2020
ms.locfileid: "85332577"
---
# <a name="the-dynamic-data-type"></a>Динамический тип данных

`dynamic`Скалярный тип данных является специальным в том, что он может принимать любые значения других скалярных типов данных из приведенного ниже списка, а также массивов и контейнеров свойств. В частности, `dynamic` значение может быть следующим:

* Заканчивающ.
* Значение любого из примитивных скалярных типов данных: `bool` , `datetime` ,, `guid` , `int` `long` , `real` , `string` и `timespan` .
* Массив `dynamic` значений, содержащий ноль или более значений с индексацией, начинающейся с нуля.
* Контейнер свойств, который сопоставляет уникальные `string` значения со `dynamic` значениями.
  Контейнер свойств имеет ноль или более таких сопоставлений (называемых "слотами"), индексируемых по уникальным `string` значениям. Слоты не упорядочены.

> [!NOTE]
> * Значения типа `dynamic` ограничены 1 МБ (2 ^ 20).
> * Несмотря на то `dynamic` , что тип выглядит как JSON, он может содержать значения, которые не представляются в модели JSON, поскольку они не существуют в JSON (например,,,, `long` `real` `datetime` `timespan` и `guid` ).
>   Таким образом, при сериализации `dynamic` значений в представление JSON значения, которые JSON не могут представить, сериализуются в `string` значения. И наоборот, Kusto будет анализировать строки как строго типизированные значения, если они могут быть проанализированы таким образом.
>   Это применимо `datetime` к `real` типам,, `long` и `guid` . 
>   Дополнительные сведения об объектной модели JSON см. в разделе [JSON.org](https://json.org/).
> * Kusto не пытается сохранить порядок сопоставлений имен и значений в контейнере свойств, поэтому вы не можете предположить, что этот порядок сохраняется. Для двух контейнеров свойств с одинаковым набором сопоставлений можно получить разные результаты, если они представлены в виде `string` значений, например.

## <a name="dynamic-literals"></a>Динамические литералы

Литерал типа выглядит следующим образом `dynamic` :

`dynamic(` *Значение* `)`

*Значение* может быть следующим:

* `null`, в этом случае литерал представляет динамическое значение NULL: `dynamic(null)` .
* Другой скалярный литерал типа данных. в этом случае литерал представляет `dynamic` литерал типа "Inner". Например, `dynamic(4)` является динамическим значением, содержащим значение 4 типа Long скалярных данных.
* Массив динамических или других литералов: `[` *листофвалуес* `]` . Например, `dynamic([1, 2, "hello"])` — это динамический массив из трех элементов, два `long` значения и одно `string` значение.
* Контейнер свойств: `{` *имя* `=` *значение* ... `}` . Например, `dynamic({"a":1, "b":{"a":2}})` — это контейнер свойств с двумя слотами: `a` , и `b` , второй слот является другим контейнером свойств.

```kusto
print o=dynamic({"a":123, "b":"hello", "c":[1,2,3], "d":{}})
| extend a=o.a, b=o.b, c=o.c, d=o.d
```

Для удобства `dynamic` литералы, отображаемые в самом тексте запроса, могут также содержать другие литералы Kusto (такие как `datetime` литералы, `timespan` литералы и т. д.). Это расширение по сравнению с JSON недоступно при синтаксическом анализе строк (например, при использовании `parse_json` функции или при приеме данных), но это позволяет сделать следующее:

```kusto
print d=dynamic({"a": datetime(1970-05-11)})
```

Чтобы проанализировать `string` значение, которое соответствует правилам кодирования JSON `dynamic` , в значение, используйте `parse_json` функцию. Пример.

* `parse_json('[43, 21, 65]')` — массив чисел;
* `parse_json('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')`— словарь
* `parse_json('21')` — одно значение динамического типа, содержащее число;
* `parse_json('"21"')` — одно значение динамического типа, содержащее строку.
* `parse_json('{"a":123, "b":"hello", "c":[1,2,3], "d":{}}')`— дает то же значение, что и в приведенном `o` выше примере.

> [!NOTE]
> В отличие от JavaScript, JSON требует использования символов двойной кавычки ( `"` ) вокруг строк и имен свойств контейнера свойств.
> Поэтому, как правило, проще поцитировать строковый литерал в кодировке JSON с помощью символа одинарной кавычки ( `'` ).
  
В следующем примере показано, как можно определить таблицу, содержащую `dynamic` столбец (а также `datetime` столбец), а затем присвоить ей одну запись. Здесь также показано, как кодировать строки JSON в CSV-файлах.

```kusto
// dynamic is just like any other type:
.create table Logs (Timestamp:datetime, Trace:dynamic)

// Everything between the "[" and "]" is parsed as a CSV line would be:
// 1. Since the JSON string includes double-quotes and commas (two characters
//    that have a special meaning in CSV), we must CSV-quote the entire second field.
// 2. CSV-quoting means adding double-quotes (") at the immediate beginning and end
//    of the field (no spaces allowed before the first double-quote or after the second
//    double-quote!)
// 3. CSV-quoting also means doubling-up every instance of a double-quotes within
//    the contents.
.ingest inline into table Logs
  [2015-01-01,"{""EventType"":""Demo"", ""EventValue"":""Double-quote love!""}"]
```

|Отметка времени                   | Трассировка                                                 |
|----------------------------|-------------------------------------------------------|
|2015-01-01 00:00:00.0000000 | {"EventType": "Demo", "Евентвалуе": "двойная кавычка!"}|

## <a name="dynamic-object-accessors"></a>Методы доступа к динамическим объектам

Чтобы проиндексировать словарь, используйте либо точечную нотацию ( `dict.key` ), либо нотацию квадратных скобок ( `dict["key"]` ).
Если индекс является строковой константой, оба параметра являются эквивалентными.

> [!NOTE] 
> Чтобы использовать выражение в качестве индекса, используйте нотацию квадратных скобок. При использовании арифметических выражений выражение внутри квадратных скобок должно быть заключено в круглые скобки.

В примерах ниже `dict` и `arr` являются столбцами динамического типа:

|Выражение                        | Тип выражения доступа | Значение                                                                              | Комментарии                                      |
|----------------------------------|--------------------------|--------------------------------------------------------------------------------------|-----------------------------------------------|
|словарь [col]                         | Имя сущности (столбец)     | Подстрочный индекс словаря с использованием значений столбца в `col` качестве ключа              | Столбец должен иметь тип String                 | 
|arr [Индекс]                        | Индекс сущности (столбец)    | Подстрочный индекс массива, использующий значения столбца в `index` качестве индекса              | Столбец должен иметь тип Integer или Boolean     | 
|arr [-index]                       | Индекс сущности (столбец)    | Извлекает значение "индекс'-th" из конца массива                             | Столбец должен иметь тип Integer или Boolean     |
|arr [(-1)]                         | Индекс сущности             | Извлекает Последнее значение в массиве                                                |                                               |
|arr [тоинт (Индексасстринг)]         | Вызов функции            | Приводит значения столбца `indexAsString` к типу int и использует их для создания индекса массива |                                               |
|словарь [[' где ']]                   | Ключевое слово, используемое в качестве имени сущности (столбец) | Проиндексировать словарь, используя значения столбца в `where` качестве ключа    | Имена сущностей, идентичные некоторым ключевым словам языка запросов, должны быть заключены в кавычки | 
|словарь. [' WHERE '] или словарь [' WHERE ']   | Константа                 | Подстрочный индекс словаря с использованием `where` строки в качестве ключа                              |                                               |

**Совет по повышению производительности.** Предпочитать использовать постоянные индексы, когда это возможно

При доступе к подобъекту `dynamic` значения получается другое `dynamic` значение, даже если у подобъекта другой базовый тип. Используйте `gettype` функцию, чтобы найти фактический базовый тип значения, и любую приведенную ниже функцию приведения, чтобы привести ее к фактическому типу.

## <a name="casting-dynamic-objects"></a>Приведение динамических объектов

> После создания скрипта динамического объекта необходимо привести значение к простому типу.

|Выражение | Значение | Тип|
|---|---|---|
| X | parse_json ("[100101102]")| массиве|
|X [0]|parse_json (' 100 ')|Динамический|
|тоинт (X [1])|101| INT|
| Да | parse_json ("{" a1 ": 100," a b c ":" 2015-01-01 "}")| словарь|
|Y. a1|parse_json (' 100 ')|Динамический|
|Y ["a b c"]| parse_json ("2015-01-01")|Динамический|
|ToDate (Y ["a b c"])|Дата и время (2015-01-01)| DATETIME|

Функции приведения:

* `tolong()`
* `todouble()`
* `todatetime()`
* `totimespan()`
* `tostring()`
* `toguid()`
* `todynamic()`

## <a name="building-dynamic-objects"></a>Создание динамических объектов

Несколько функций позволяют создавать новые `dynamic` объекты:

* [Pack ()](../packfunction.md) создает контейнер свойств из пар "имя-значение".
* [pack_array ()](../packarrayfunction.md) создает массив из пар "имя-значение".
* [Range ()](../rangefunction.md) создает массив с арифметическими последовательностями чисел.
* [почтовые ()](../zipfunction.md) пары "параллельных" значений из двух массивов в один массив.
* [Repeat ()](../repeatfunction.md) создает массив с повторяющимся значением.

Кроме того, существует несколько агрегатных функций, которые создают `dynamic` массивы для хранения статистических значений:

* [буилдсчема ()](../buildschema-aggfunction.md) Возвращает статистическую схему нескольких `dynamic` значений.
* [make_bag ()](../make-bag-aggfunction.md) Возвращает контейнер свойств динамических значений в группе.
* [make_bag_if ()](../make-bag-if-aggfunction.md) Возвращает контейнер свойств динамических значений в группе (с предикатом).
* [make_list ()](../makelist-aggfunction.md) возвращает массив, содержащий все значения в последовательности.
* [make_list_if ()](../makelistif-aggfunction.md) возвращает массив, содержащий все значения в последовательности (с предикатом).
* [make_list_with_nulls ()](../make-list-with-nulls-aggfunction.md) возвращает массив, содержащий все значения, в последовательности, включая значения NULL.
* [make_set ()](../makeset-aggfunction.md) возвращает массив, содержащий все уникальные значения.
* [make_set_if ()](../makesetif-aggfunction.md) возвращает массив, содержащий все уникальные значения (с предикатом).

## <a name="operators-and-functions-over-dynamic-types"></a>Операторы и функции для динамических типов

|||
|---|---|
| *значение* `in` *массив*| Возвращает значение true, если в массиве *array* есть элемент, который равен значению *value*.<br/>`where City in ('London', 'Paris', 'Rome')`
| *значение* `!in` *массив*| Возвращает значение true, если в массиве *array* нет ни одного элемента, который равен значению *value*.
|[`array_length(`массиве`)`](../arraylengthfunction.md)| Возвращает NULL, если это не массив
|[`bag_keys(`контейнера`)`](../bagkeysfunction.md)| Перечисляет все корневые ключи в динамическом объекте контейнера свойств.
|[`bag_merge(`bag1,..., Багн`)`](../bag-merge-function.md)| Объединяет динамические контейнеры свойств в динамический контейнер свойств со всеми объединенными свойствами.
|[`extractjson(`путь, объект`)`](../extractjsonfunction.md)|Использует путь path для перехода к объекту object.
|[`parse_json(`источника`)`](../parsejsonfunction.md)| Преобразует строку формата JSON в динамический объект.
|[`range(`от, до, шаг`)`](../rangefunction.md)| Массив значений
|[`mv-expand`листколумн](../mvexpandoperator.md) | Реплицирует строку для каждого значения в списке в указанной ячейке.
|[`summarize buildschema(`рубрик`)`](../buildschema-aggfunction.md) |Определяет схему типа по содержимому столбца.
|[`summarize make_bag(`рубрик`)`](../make-bag-aggfunction.md) | Объединяет значения контейнера свойств (Dictionary) в столбце в один контейнер свойств без дублирования ключа.
|[`summarize make_bag_if(`столбец, предикат`)`](../make-bag-if-aggfunction.md) | Объединяет значения контейнера свойств (Dictionary) в столбце в один контейнер свойств без дублирования ключа (with предикат).
|[`summarize make_list(`столбец `)`](../makelist-aggfunction.md)| Выполняет сведение групп строк и помещает значения столбца в массив.
|[`summarize make_list_if(`столбец, предикат `)`](../makelistif-aggfunction.md)| Выполняет сведение групп строк и помещает значения столбца в массив (with предикат).
|[`summarize make_list_with_nulls(`столбец `)`](../make-list-with-nulls-aggfunction.md)| Выполняет сведение групп строк и помещает значения столбца в массив, включая значения NULL.
|[`summarize make_set(`рубрик`)`](../makeset-aggfunction.md) | Выполняет сведение групп строк и помещает значения столбца в массив без дублирования значений.
