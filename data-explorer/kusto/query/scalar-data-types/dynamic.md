---
title: Динамический тип данных - Azure Data Explorer Документы Майкрософт
description: В этой статье описывается тип динамических данных в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/12/2020
ms.openlocfilehash: e1cdb6e5af20b326198a7447c50c24e5f632d237
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81509883"
---
# <a name="the-dynamic-data-type"></a>Динамический тип данных

Тип `dynamic` данных масштабируется, поскольку он может принимать на себя любую ценность других типов масштабных данных из приведенного ниже списка, а также массивов и пакетов свойств. В частности, `dynamic` значение может быть:

* Null.
* Значение любого из примитивных типов `bool` `datetime`масштабных `int` `long`данных: `timespan`, , `guid`, , `real` `string`, и .
* Массив значений, `dynamic` удерживающих ноль или более значений с нулевым индексированием.
* Мешок свойств, `string` который отображает `dynamic` уникальные значения значения.
  Сумка свойства имеет ноль или несколько таких карт (называемых `string` «слотами»), индексированных по уникальным значениям. Слоты не упорядочены.

> [!NOTE]
> Значения типа `dynamic` ограничены 1 МБ (2 х 20).

> [!NOTE]
> Хотя `dynamic` тип отображается JSON-как, он может содержать значения, которые модель JSON не представляет, потому `long`что `real` `datetime`они `timespan`не существуют в JSON (например, , , , , , и `guid`).
> Таким образом, `dynamic` при сериализации значений в представлении JSON значения, которые `string` JSON не может представить, сериализируются в значения. И наоборот, Kusto будет разбирать строки как сильно набранные значения, если они могут быть разобраны как таковые.
> Это относится `datetime` `real`к `long`, `guid` и, и типы. Подробнее о модели объектов JSON смотрите [json.org](https://json.org/).

> [!NOTE]
> Kusto не пытается сохранить порядок отображения от имени к стоимости в сумке свойства, и поэтому вы не можете взять на себя заказ, который будет сохранен. Вполне возможно, что два пакета свойств с одинаковым набором карт дают разные `string` результаты, когда они представлены как значения, например.

## <a name="dynamic-literals"></a>Динамические буквальные буквы

Буквальный тип `dynamic` выглядит следующим образом:

`dynamic(`*Значение*`)`

*Значение* может быть:

* `null`, и в этом случае буквальное `dynamic(null)`представляет нулевую динамическое значение: .
* Другой масштабданный тип данных буквально, и в `dynamic` этом случае буквальное представляет собой буквальное "внутреннего" типа. Например, `dynamic(4)` это динамическое значение, удерживая значение 4 длинного типа данных scalar.
* Массив динамических или других буквальных: `[` *ListOfValues* `]`. Например, `dynamic([1, 2, "hello"])` это динамический массив `long` из трех `string` элементов, двух значений и одного значения.
* Сумка `{` собственности: *Значение* *имени* `=` ... `}`. Например, `dynamic({"a":1, "b":{"a":2}})` это сумка собственности `a`с `b`двумя слотами, и , со вторым слотом является другой мешок собственности.

```kusto
print o=dynamic({"a":123, "b":"hello", "c":[1,2,3], "d":{}})
| extend a=o.a, b=o.b, c=o.c, d=o.d
```

Для удобства, буквальные, `dynamic` которые появляются в тексте запроса сам может также `datetime` включать другие буквы Кусто (например, буквальные, `timespan` буквальные и т.д.) Это расширение над JSON недоступно при разборе строк (например, при использовании `parse_json` функции или при глотании данных), но позволяет сделать это:

```kusto
print d=dynamic({"a": datetime(1970-05-11)})
```

Чтобы разобрать `string` значение, которое следует правилам кодирования JSON, в `dynamic` значение, используйте функцию. `parse_json` Пример:

* `parse_json('[43, 21, 65]')` — массив чисел;
* `parse_json('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')`- словарь
* `parse_json('21')` — одно значение динамического типа, содержащее число;
* `parse_json('"21"')` — одно значение динамического типа, содержащее строку.
* `parse_json('{"a":123, "b":"hello", "c":[1,2,3], "d":{}}')`- дает такое `o` же значение, как в приведенном выше примере.

> [!NOTE]
> В отличие от JavaScript, JSON требует`"`использования двойных котировок () символов вокруг строк и названий свойств.
> Таким образом, как правило, легче цитировать JSON-закодированной строки`'`буквально с помощью одной цитаты ( ) характер.
  
В следующем примере показано, как можно `dynamic` определить таблицу, `datetime` вмещающей столбец (а также столбец), а затем глотать в нее одну запись. он также демонстрирует, как можно кодировать строки JSON в файлах CSV:

```kusto
// dynamic is just like any other type:
.create table Logs (Timestamp:datetime, Trace:dynamic)

// Everything between the "[" and "]" is parsed as a CSV line would be:
// 1. Since the JSON string includes double-quotes and commas (two characters
//    that have a special meaning in CSV), we must CSV-quote the entire second field.
// 2. CSV-quoting means adding double-quotes (") at the immediate beginning and end
//    of the field (no spaces allowed before the first double-quote or after the second
//    double-quote!)
// 3. CSV-quoting also means doubling-up every instance of a double-quotes within
//    the contents.
.ingest inline into table Logs
  [2015-01-01,"{""EventType"":""Demo"", ""EventValue"":""Double-quote love!""}"]
```

|Отметка времени                   | Трассировка                                                 |
|----------------------------|-------------------------------------------------------|
|2015-01-01 00:00:00.0000000 | "EventType":"Демо","EventValue":"Двойная цитата любви!"|

## <a name="dynamic-object-accessors"></a>Динамические объекты-аксессуары

Чтобы описать словарь, используйте либо`dict.key`обозначение точки ( )`dict["key"]`или обозначение скобки ().
Когда строка является постоянной строкой, оба варианта эквивалентны.

> [!NOTE] 
> Чтобы использовать выражение в качестве подписки, используйте обозначение кронштейнов. При использовании арифметических выражений выражение внутри скобки должно быть завернуто в скобки.

В приведенных `dict` `arr` ниже примерах и ниже приведены столбцы динамического типа:

|Выражение                        | Тип выражения аксессуаров | Значение                                                                              | Комментарии                                      |
|----------------------------------|--------------------------|--------------------------------------------------------------------------------------|-----------------------------------------------|
|диктант                         | Имя сущности (колонка)     | Subscripts словарь, используя значения столбца `col` в качестве ключа              | Столбец должен быть строки типа                 | 
|arr'index                        | Индекс сущности (столбец)    | Субскрипты массива, используя значения `index` столбца в качестве индекса              | Колонна должна быть типа integer или boolean     | 
|arr-индекс                       | Индекс сущности (столбец)    | Извлекает значение 'индекс'-th из конца массива                             | Колонна должна быть типа integer или boolean     |
|арре (-1))                         | Индекс сущности             | Извлекает последнее значение в массиве                                                |                                               |
|arr'toint (indexAsString)         | Вызов функции             | Отбрасывает значения столбца, `indexAsString` чтобы int и использовать их для субписания массива |                                               |
|диктант »где' »                   | Ключевое слово, используемое в качестве имени сущности (колонка) | Subscripts словарь, используя значения `where` столбца в качестве ключа    | Имена сущностей, идентичные некоторым ключевым словам языка запроса, должны быть процитированы | 
|диктант.   | Константа                 | Посвяжество `where` словаря, используя строку в качестве ключа                              |                                               |

**Наконечник производительности:** Предпочитаю использовать постоянные подписки, когда это возможно

Доступ к субобъекту `dynamic` значения дает `dynamic` другое значение, даже если субобъект имеет другой базовый тип. Используйте `gettype` функцию, чтобы обнаружить фактический базовый тип значения, и любой из функций литья, перечисленных ниже, чтобы бросить его в фактический тип.

## <a name="casting-dynamic-objects"></a>Кастинг динамических объектов

> После оповестить динамический объект необходимо отбросить значение в простой тип.

|Выражение | Значение | Тип|
|---|---|---|
| X | parse_json ('100,101,102)')| массиве|
|Х-0|parse_json ('100')|Динамический|
|toint (X '1)|101| INT|
| Да | parse_json ('a1":100, "a b":"2015-01-01")| словарь|
|Y.a1|parse_json ('100')|Динамический|
|Y'"a b c"| parse_json ("2015-01-01")|Динамический|
|до датируется (Y'"a b c")|время (2015-01-01)| DATETIME|

Актеры:

* `tolong()`
* `todouble()`
* `todatetime()`
* `totimespan()`
* `tostring()`
* `toguid()`
* `todynamic()`

## <a name="building-dynamic-objects"></a>Строительство динамических объектов

Несколько функций позволяют создавать новые `dynamic` объекты:

* [пакет ()](../packfunction.md) создает пакет свойств из пар имени/значения.
* [pack_array ()](../packarrayfunction.md) создает массив из пар имен/значений.
* [диапазон ()](../rangefunction.md) создает массив с арифметической серией чисел.
* [zip ()](../zipfunction.md) соединяет "параллельные" значения из двух массивов в один массив.
* [повторить ()](../repeatfunction.md) создает массив с повторным значением.

Кроме того, существует несколько `dynamic` агрегированных функций, которые создают массивы для хранения агрегированных значений:

* [buildschema ()](../buildschema-aggfunction.md) возвращает агрегированную `dynamic` схему нескольких значений.
* [make_bag ()](../make-bag-aggfunction.md) возвращает пакет свойств динамических значений внутри группы.
* [make_bag_if ()](../make-bag-if-aggfunction.md) возвращает пакет свойств динамических значений внутри группы (с предикатом).
* [make_list ()](../makelist-aggfunction.md) возвращает массив, держащий все значения, последовательно.
* [make_list_if ()](../makelistif-aggfunction.md) возвращает массив, держащий все значения, последовательно (с предикатом).
* [make_list_with_nulls ()](../make-list-with-nulls-aggfunction.md) возвращает массив, вмещающих все значения, последовательно, включая нулевые значения.
* [make_set ()](../makeset-aggfunction.md) возвращает массив, вмещающих все уникальные значения.
* [make_set_if ()](../makesetif-aggfunction.md) возвращает массив, вмещающих все уникальные значения (с предикатом).

## <a name="operators-and-functions-over-dynamic-types"></a>Операторы и функции для динамических типов

|||
|---|---|
| *значение* `in` *массив*| Возвращает значение true, если в массиве *array* есть элемент, который равен значению *value*.<br/>`where City in ('London', 'Paris', 'Rome')`
| *значение* `!in` *массив*| Возвращает значение true, если в массиве *array* нет ни одного элемента, который равен значению *value*.
|[`array_length(`Массива`)`](../arraylengthfunction.md)| Возвращает NULL, если это не массив
|[`bag_keys(`Сумка`)`](../bagkeysfunction.md)| Перечисляет все корневые клавиши в динамическом объекте с пакетом свойств.
|[`extractjson(`путь, объект`)`](../extractjsonfunction.md)|Использует путь path для перехода к объекту object.
|[`parse_json(`Источник`)`](../parsejsonfunction.md)| Преобразует строку формата JSON в динамический объект.
|[`range(`от,к, шаг`)`](../rangefunction.md)| Массив значений
|[`mv-expand`listColumn](../mvexpandoperator.md) | Реплицирует строку для каждого значения в списке в указанной ячейке.
|[`summarize buildschema(`Столбца`)`](../buildschema-aggfunction.md) |Определяет схему типа по содержимому столбца.
|[`summarize make_bag(`Столбца`)`](../make-bag-aggfunction.md) | Слияние значения пакета свойств (словаря) в столбце в один пакет свойств без дублирования ключа.
|[`summarize make_bag_if(`колонка,предикат`)`](../make-bag-if-aggfunction.md) | Слияние значения пакета свойств (словаря) в столбце в один пакет свойств без дублирования ключа (с предикатом).
|[`summarize make_list(`колонка`)`](../makelist-aggfunction.md)| Выполняет сведение групп строк и помещает значения столбца в массив.
|[`summarize make_list_if(`колонка,предикат`)`](../makelistif-aggfunction.md)| Уплощает группы строк и помещает значения столбца в массив (с предикатом).
|[`summarize make_list_with_nulls(`колонка`)`](../make-list-with-nulls-aggfunction.md)| Уплощает группы строк и помещает значения столбца в массив, включая нулевые значения.
|[`summarize make_set(`Столбца`)`](../makeset-aggfunction.md) | Выполняет сведение групп строк и помещает значения столбца в массив без дублирования значений.
|[`summarize make_bag(`Столбца`)`](../make-bag-aggfunction.md) | Слияние значения пакета свойств (словаря) в столбце в один пакет свойств без дублирования ключа.