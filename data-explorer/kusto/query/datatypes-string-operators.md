---
title: Операторы струнных - Исследователь данных Azure (ru) Документы Майкрософт
description: В этой статье описаны операторы строк в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.openlocfilehash: 91955ef5877e6c054917f70c655fc4b7cd3f277b
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81516479"
---
# <a name="string-operators"></a>Строковые операторы

В следующей таблице сводятся итоги для операторов по строкам:

Оператор        |Описание                                                       |С учетом регистра|Пример (при `true`)
----------------|------------------------------------------------------------------|--------------|-----------------------
`==`            |Равно                                                            |Да           |`"aBc" == "aBc"`
`!=`            |Не равно                                                        |Да           |`"abc" != "ABC"`
`=~`            |Равно                                                            |нет            |`"abc" =~ "ABC"`
`!~`            |Не равно                                                        |нет            |`"aBc" !~ "xyz"`
`has`           |Правая часть представляет собой все слово в левой части     |нет            |`"North America" has "america"`
`!has`          |Правая часть не является всем словом в левой части                                     |нет            |`"North America" !has "amer"` 
`has_cs`        |Правая часть представляет собой все слово в левой части     |Да           |`"North America" has_cs "America"`
`!has_cs`       |Правая часть не является всем словом в левой части                                     |Да           |`"North America" !has_cs "amer"` 
`hasprefix`     |RHS является префиксом термина в LHS                                       |нет            |`"North America" hasprefix "ame"`
`!hasprefix`    |RHS не является префиксом термина в LHS                                   |нет            |`"North America" !hasprefix "mer"` 
`hasprefix_cs`  |RHS является префиксом термина в LHS                                       |Да           |`"North America" hasprefix_cs "Ame"`
`!hasprefix_cs` |RHS не является префиксом термина в LHS                                   |Да           |`"North America" !hasprefix_cs "CA"` 
`hassuffix`     |RHS является термин суффикс в LHS                                       |нет            |`"North America" hassuffix "ica"`
`!hassuffix`    |RHS не термин суффикс в LHS                                   |нет            |`"North America" !hassuffix "americ"`
`hassuffix_cs`  |RHS является термин суффикс в LHS                                       |Да           |`"North America" hassuffix_cs "ica"`
`!hassuffix_cs` |RHS не термин суффикс в LHS                                   |Да           |`"North America" !hassuffix_cs "icA"`
`contains`      |Правая часть является вхождением в левую часть                                |нет            |`"FabriKam" contains "BRik"`
`!contains`     |Правая часть не входит в левую часть                                         |нет            |`"Fabrikam" !contains "xyz"`
`contains_cs`   |Правая часть является вхождением в левую часть                                |Да           |`"FabriKam" contains_cs "Kam"`
`!contains_cs`  |Правая часть не входит в левую часть                                         |Да           |`"Fabrikam" !contains_cs "Kam"`
`startswith`    |RHS является начальной последовательностью LHS                              |нет            |`"Fabrikam" startswith "fab"`
`!startswith`   |RHS не является первоначальной посевной LHS                          |нет            |`"Fabrikam" !startswith "kam"`
`startswith_cs` |RHS является начальной последовательностью LHS                              |Да           |`"Fabrikam" startswith_cs "Fab"`
`!startswith_cs`|RHS не является первоначальной посевной LHS                          |Да           |`"Fabrikam" !startswith_cs "fab"`
`endswith`      |RHS является закрывающей последовательностью LHS                               |нет            |`"Fabrikam" endswith "Kam"`
`!endswith`     |RHS не является заключительной пословицы LHS                           |нет            |`"Fabrikam" !endswith "brik"`
`endswith_cs`   |RHS является закрывающей последовательностью LHS                               |Да           |`"Fabrikam" endswith "Kam"`
`!endswith_cs`  |RHS не является заключительной пословицы LHS                           |Да           |`"Fabrikam" !endswith "brik"`
`matches regex` |Левая часть содержит соответствие для правой части                                      |Да           |`"Fabrikam" matches regex "b.*k"`
`in`            |Соответствует одному из элементов                                     |Да           |`"abc" in ("123", "345", "abc")`
`!in`           |Не соответствует одному из элементов                                 |Да           |`"bca" !in ("123", "345", "abc")`
`in~`           |Соответствует одному из элементов                                     |нет            |`"abc" in~ ("123", "345", "ABC")`
`!in~`          |Не соответствует одному из элементов                                 |нет            |`"bca" !in~ ("123", "345", "ABC")`
`has_any`       |То `has` же, что и работает над любым из элементов                    |нет            |`"North America" has_any("south", "north")`

## <a name="performance-tips"></a>Советы по улучшению производительности

Для повышения производительности, когда есть два оператора, выполняющие одну и ту же задачу, используйте задачу, учитывая случай.
Пример:

* `=~`вместо, использовать`==`
* `in~`вместо, использовать`in`
* `contains`вместо, использовать`contains_cs`

Для более быстрых результатов, если вы тестируете на наличие символа или алфавитного слова, которое связано не-альфанумерными символами (или началом или концом поля), используйте `has` или `in`. `has`выполняет быстрее, `contains` `startswith`чем `endswith`, , или .

Например, первый из этих запросов выполняется быстрее:

```kusto
EventLog | where continent has "North" | count;
EventLog | where continent contains "nor" | count
```

## <a name="understanding-string-terms"></a>Понимание терминов строки

По умолчанию Kusto индексирует все столбцы, `string`включая столбцы типа .
На самом деле для таких столбцов, в зависимости от фактических данных, строятся несколько индексов. Для пользователя, эти индексы непосредственно не подвергаются (кроме их положительного влияния на `string` производительность `has` запроса, конечно), `has` `!has`за `hasprefix` `!hasprefix`исключением операторов, которые имеют как часть своего имени: , , и т.д. Эти операторы особенны в том, что их семантическая продиктована тем, как закодирована колонка; вместо того, чтобы делать "обычный" подстроки, эти операторы соответствуют **терминам.**

Чтобы понять совпадение на основе терминов, сначала нужно понять, что такое термин. По умолчанию Кусто `string` разбивает каждое значение в максимальные последовательности буквенно-цифровых символов ASCII, и каждый из них превращается в термин. Например, в `string` `Kusto`следующих условиях, `WilliamGates3rd`и следующие подстроки: `ad67d136`, `c1db`, `4f9f`, `88ef` `d94f3b6b0b5a`:

```
Kusto:  ad67d136-c1db-4f9f-88ef-d94f3b6b0b5a;;WilliamGates3rd
```

По умолчанию, Kusto строит термин индекс, состоящий из всех терминов, которые `has` `!has`являются четыре символа или более, и этот индекс используется, и т.д. при поиске терминов, которые также четыре символа или более. (Если запрос ищет термин, который меньше четырех символов, `contains` или использует оператора, например, Kusto вернется к сканированию значений в столбце, если он не может определить совпадение, что гораздо медленнее, чем поиск термина вверх в термине индекс.)

