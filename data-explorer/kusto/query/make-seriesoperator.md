---
title: Оператор серии сделать - Azure Data Explorer Документы Майкрософт
description: В этой статье описывается оператор серии решений в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/16/2020
ms.openlocfilehash: 3fa8f1693b56fc0820b9e0ba6b5f03a9363c9b98
ms.sourcegitcommit: 436cd515ea0d83d46e3ac6328670ee78b64ccb05
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/21/2020
ms.locfileid: "81663728"
---
# <a name="make-series-operator"></a>Оператор make-series

Создание серии указанных агрегированных значений вдоль указанной оси. 

```kusto
T | make-series sum(amount) default=0, avg(price) default=0 on timestamp from datetime(2016-01-01) to datetime(2016-01-10) step 1d by fruit, supplier
```

**Синтаксис**

*Т* `| make-series` *.*. . .*Column* `=`. *Aggregation* `default` `=` *DefaultValue*.`,` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . `on` *AxisКолонка (AxisColumn)* `from` `by` - *начало*, шаг`to` к *концу* `step` , *колонка* -*групповое* `=` *выражение* .`,` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

**Аргументы**

* *Column* — необязательное имя итогового столбца. По умолчанию это имя, получаемое из выражения.
* *DefaultValue:* Значение по умолчанию, которое будет использоваться вместо отсутствующих значений. Если нет строки с определенными значениями *AxisColumn* и *GroupExpression,* то в результатах соответствующий элемент массива будет назначен значением *DefaultValue.* Если `default =` *defaultValue* опущено, то предполагается 0. 
* *Агрегация:* Вызов [функции агрегации,](make-seriesoperator.md#list-of-aggregation-functions) `count()` такой `avg()`как или с именами столбцов в качестве аргументов. Смотрите [список функций агрегирования.](make-seriesoperator.md#list-of-aggregation-functions) Обратите внимание, что с `make-series` оператором могут использоваться только функции агрегации, которые возвращают числовый результат.
* *ОсьКолонна:* Колонка, на которой будет заказана серия. Это можно рассматривать как временную `datetime` шкалу, но кроме того, принимаются любые числовые типы.
* *начало*: (необязательно) Низкое значение *AxisColumn* для каждой серии будет построено. *запуск,* *конец* и *шаг* используются для создания массива значений *AxisColumn* в пределах заданного диапазона и с использованием заданного *шага.* Все значения *агрегации* упорядочены соответственно к этому массиву. Этот массив *AxisColumn* также является последним выходным столбиком в выходе с тем же *именем, что и AxisColumn.* Если *начальное* значение не указано, старт является первым язлом (шагом), в котором имеются данные в каждой серии.
* *конец*: (необязательно) Высокое значение границы (не инклюзивное) *AxisColumn*, последний индекс временных рядов меньше этого значения (и будет *старт* плюс множество многоступенчатый *шаг,* который меньше *конца).* Если *конечное* значение не предусмотрено, это будет верхняя граница последнего ядра (шаг), который имеет данные для каждой серии.
* *шаг*: Разница между двумя последовательными элементами массива *AxisColumn* (т.е. размер ядра).
* *GroupExpression* — выражение для столбцов, предоставляющее набор уникальных значений. Обычно это имя столбца, который уже содержит ограниченный набор значений. 
* *Параметры MakeSeries*: Ноль или более (пространственно-разделенные) параметры в виде *значения* *имен,* `=` которые контролируют поведение. Поддерживаются следующие параметры: 
  
  |Имя           |Значения                                        |Описание                                                                                        |
  |---------------|-------------------------------------|------------------------------------------------------------------------------|
  |`kind`          |`nonempty`                               |Производит результат по умолчанию, когда вход оператора make-series пуст|                                

**Возвращает**

Строки ввода расположены в группы, имеющие `by` одинаковые `bin_at(`значения выражений и выражение*начала* `)` *шага*`, ` *AxisColumn.*`, ` Затем указанные агрегатные функции выполняют вычисления и создают строку для каждой группы. Результат содержит `by` столбцы, столбец *AxisColumn,* а также по крайней мере одну колонку для каждого вычисленных агрегатов. (Агрегация, что несколько столбцов или нечисловые результаты не поддерживаются.)

Этот промежуточный результат имеет столько строк, `by` сколько `bin_at(`есть различные комбинации и значения*начала* `)` *шага*`, ` *AxisColumn.*`, `

Наконец, строки из промежуточного результата, расположенные `by` в группы, имеющие одинаковые значения выражений и `dynamic` все агрегированные значения, расположены в массивы (значения типа). Для каждой агрегации имеется одна колонка, содержащая массив с тем же именем. Последний столбец на выходе диапазона функции со всеми значениями *AxisColumn.* Его значение повторяется для всех строк. 

Обратите внимание, что из-за заполнения отсутствующих ячеек по умолчанию, полученная таблица поворота имеет одинаковое количество ячеек (т.е. агрегированных значений) для всех серий  

**Примечание**

Хотя можно предоставить произвольные выражения как для агрегирования, так и для группирования выражений, более эффективно использовать простые имена столбцов.

**Альтернативный синтаксис**

*T* `| make-series` -*Колонка* `=`-`default` `=` *Агрегация* - *По умолчанию - "По умолчанию" (Default)*`,` `on` *AxisКолонка* `in` `range(` *начала* `,` `by` *GroupExpression* *Column* *stop* `,` *стоп-шага* `)` `=``,`

Генерируемая серия из альтернативного синтаксиса отличается от основного синтаксиса в 2 аспектах:
* *Значение стоп-остановки* включительно.
* Binning оси индекса генерируется с помощью бен() и не bin_at(), что означает, что *начало* не гарантируется для включения в сгенерированную серию.

Рекомендуется использовать основной синтаксис серии, а не альтернативный синтаксис.

**Распределение и перемешивание**

`make-series`поддерживает `summarize` [подсказки shufflekey](shufflequery.md) с помощью syntax hint.shufflekey.

## <a name="list-of-aggregation-functions"></a>Список функций агрегирования

|Компонент|Описание|
|--------|-----------|
|[любой()](any-aggfunction.md)|Возвращает случайное непустое значение для группы|
|[avg()](avg-aggfunction.md)|Ретунгот среднее значение по всей группе|
|[количество ()](count-aggfunction.md)|Количество возвратов группы|
|[countif()](countif-aggfunction.md)|Количество возвратов с предикатом группы|
|[всчет()](dcount-aggfunction.md)|Возвращает приблизительное количество элементов группы|
|[макс()](max-aggfunction.md)|Возвращает максимальное значение по всей группе|
|[мин()](min-aggfunction.md)|Возвращает минимальное значение по всей группе|
|[stdev()](stdev-aggfunction.md)|Возвращает стандартное отклонение по всей группе|
|[сумма()](sum-aggfunction.md)|Возвращает сумму элементов с группой|
|[дисперсия()](variance-aggfunction.md)|Возвращает дисперсию по всей группе|

## <a name="list-of-series-analysis-functions"></a>Список функций анализа серий

|Компонент|Описание|
|--------|-----------|
|[series_fir()](series-firfunction.md)|Применяет фильтр [Finite Impulse Response](https://en.wikipedia.org/wiki/Finite_impulse_response)|
|[series_iir()](series-iirfunction.md)|Применяет фильтр [Infinite Impulse Response](https://en.wikipedia.org/wiki/Infinite_impulse_response)|
|[series_fit_line()](series-fit-linefunction.md)|Находит прямую линию, которая является наилучшим приближением ввода|
|[series_fit_line_dynamic()](series-fit-line-dynamicfunction.md)|Находит линию, которая является наилучшим приближением ввода, возвращающимся динамическим объектом|
|[series_fit_2lines()](series-fit-2linesfunction.md)|Находит две строки, которые является лучшим приближением ввода|
|[series_fit_2lines_dynamic()](series-fit-2lines-dynamicfunction.md)|Находит две строки, которые является наилучшим приближением ввода, возвращающегося динамического объекта|
|[series_outliers()](series-outliersfunction.md)|Оценки аномалий в серии|
|[series_periods_detect()](series-periods-detectfunction.md)|Находит наиболее значительные периоды, которые существуют в временных рядах|
|[series_periods_validate()](series-periods-validatefunction.md)|Проверяет, содержит ли временные ряды периодические закономерности заданной длины|
|[series_stats_dynamic()](series-stats-dynamicfunction.md)|Возврат нескольких столбцов с общей статистикой (мин/макс/разница/стдев/средний)|
|[series_stats()](series-statsfunction.md)|Генерирует динамическое значение с общей статистикой (мин/макс/разница/стдев/средний)|
  
## <a name="list-of-series-interpolation-functions"></a>Список функций интерполяции серий
|Компонент|Описание|
|--------|-----------|
|[series_fill_backward()](series-fill-backwardfunction.md)|Выполняет обратную заполняемую интерполяцию недостающих значений в серии|
|[series_fill_const()](series-fill-constfunction.md)|Заменяет недостающие значения в серии на определенное постоянное значение|
|[series_fill_forward()](series-fill-forwardfunction.md)|Выполняет передний залив интерполяции недостающих значений в серии|
|[series_fill_linear()](series-fill-linearfunction.md)|Выполняет линейную интерполяцию недостающих значений в серии|

* Примечание: Функции интерполяции по умолчанию принимают `null` как недостающее значение. Поэтому рекомендуется указать `default=` *двойное*()`null`в `make-series` случае, если вы собираетесь использовать функции интерполяции для серии. 

## <a name="example"></a>Пример
  
 Таблица, которая показывает массивы чисел и средние цены каждого фрукта от каждого поставщика, заказанный меткой времени с указанным диапазоном. Там в строке в выходе для каждого отдельного сочетания фруктов и поставщиков. На выходных столбцах показаны фрукты, поставщик и массивы: счет, средний и вся линия времени (с 2016-01-01 до 2016-01-10). Все массивы сортируются по соответствующей метке времени, и все пробелы заполняются значениями по умолчанию (0 в этом примере). Все остальные входные столбцы игнорируются.
  
```kusto
T | make-series PriceAvg=avg(Price) default=0
on Purchase from datetime(2016-09-10) to datetime(2016-09-13) step 1d by Supplier, Fruit
```

:::image type="content" source="images/aggregations/makeseries.png" alt-text="Макесерии":::  
  
```kusto
let data=datatable(timestamp:datetime, metric: real)
[
  datetime(2016-12-31T06:00), 50,
  datetime(2017-01-01), 4,
  datetime(2017-01-02), 3,
  datetime(2017-01-03), 4,
  datetime(2017-01-03T03:00), 6,
  datetime(2017-01-05), 8,
  datetime(2017-01-05T13:40), 13,
  datetime(2017-01-06), 4,
  datetime(2017-01-07), 3,
  datetime(2017-01-08), 8,
  datetime(2017-01-08T21:00), 8,
  datetime(2017-01-09), 2,
  datetime(2017-01-09T12:00), 11,
  datetime(2017-01-10T05:00), 5,
];
let interval = 1d;
let stime = datetime(2017-01-01);
let etime = datetime(2017-01-10);
data
| make-series avg(metric) on timestamp from stime to etime step interval 
```
  
|avg_metric|TIMESTAMP|
|---|---|
|[ 4.0, 3.0, 5.0, 0.0, 10.5, 4.0, 3.0, 8.0, 6.5 ]|"2017-01-01T00:00.0000000", "2017-01-02T00:00:0000000", "2017-01-03T00:00.000000", "2017-01-04T00:00:00:00.00000", "2017-01-05T00:00:00.00000 ", "2017-01-06T00:00.0000000", "2017-01-07T00:00:00.000000", "2017-01-08T00:00:0000000", "2017-01-09T00:00:00.000000"|  


Когда входные `make-series` показатели опустели, поведение по умолчанию `make-series` также приводит к пустому результату.

```kusto
let data=datatable(timestamp:datetime, metric: real)
[
  datetime(2016-12-31T06:00), 50,
  datetime(2017-01-01), 4,
  datetime(2017-01-02), 3,
  datetime(2017-01-03), 4,
  datetime(2017-01-03T03:00), 6,
  datetime(2017-01-05), 8,
  datetime(2017-01-05T13:40), 13,
  datetime(2017-01-06), 4,
  datetime(2017-01-07), 3,
  datetime(2017-01-08), 8,
  datetime(2017-01-08T21:00), 8,
  datetime(2017-01-09), 2,
  datetime(2017-01-09T12:00), 11,
  datetime(2017-01-10T05:00), 5,
];
let interval = 1d;
let stime = datetime(2017-01-01);
let etime = datetime(2017-01-10);
data
| limit 0
| make-series avg(metric) default=1.0 on timestamp from stime to etime step interval 
| count 
```

|Count|
|---|
|0|


Использование `kind=nonempty` `make-series` будет производить непустой результат значений по умолчанию:

```kusto
let data=datatable(timestamp:datetime, metric: real)
[
  datetime(2016-12-31T06:00), 50,
  datetime(2017-01-01), 4,
  datetime(2017-01-02), 3,
  datetime(2017-01-03), 4,
  datetime(2017-01-03T03:00), 6,
  datetime(2017-01-05), 8,
  datetime(2017-01-05T13:40), 13,
  datetime(2017-01-06), 4,
  datetime(2017-01-07), 3,
  datetime(2017-01-08), 8,
  datetime(2017-01-08T21:00), 8,
  datetime(2017-01-09), 2,
  datetime(2017-01-09T12:00), 11,
  datetime(2017-01-10T05:00), 5,
];
let interval = 1d;
let stime = datetime(2017-01-01);
let etime = datetime(2017-01-10);
data
| limit 0
| make-series kind=nonempty avg(metric) default=1.0 on timestamp from stime to etime step interval 
```

|avg_metric|TIMESTAMP|
|---|---|
|[<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0<br>]|[<br>  "2017-01-01T00:00.0000000",<br>  "2017-01-02T00:00.0000000",<br>  "2017-01-03T00:00.0000000",<br>  "2017-01-04T00:00.0000000",<br>  "2017-01-05T00:00.0000000",<br>  "2017-01-06T00:00.0000000",<br>  "2017-01-07T00:00.0000000",<br>  "2017-01-08T00:00.0000000",<br>  "2017-01-09T00:00.0000000"<br>]|