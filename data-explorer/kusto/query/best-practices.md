---
title: Рекомендации по запросам в Azure Data Explorer
description: В этой статье описываются рекомендации по запросам в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: alexans
ms.service: data-explorer
ms.topic: reference
ms.date: 02/03/2020
ms.localizationpriority: high
adobe-target: true
ms.openlocfilehash: 87154368a033afe1da7669e71e269081865b689d
ms.sourcegitcommit: db99b9d0b5f34341ad3be38cc855c9b80b3c0b0e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100359919"
---
# <a name="query-best-practices"></a>Рекомендации по запросам

Ниже приведены некоторые рекомендации, которые позволят ускорить выполнение запроса.

|Действие  |Назначение  |Не используйте  |Примечания  |
|---------|---------|---------|---------|
| **Фильтры времени** | Сначала используйте фильтры времени. ||Kusto высоко оптимизирован для использования фильтров времени.| 
|**Строковые операторы**      | Используйте оператор `has`.     | Не используйте `contains`.     | При поиске полных токенов лучше использовать метод `has`, поскольку он не ищет подстроки.   |
|**Операторы с учетом регистра**     |  Используйте `==`.       | Не используйте `=~`.       |  При возможности используйте операторы с учетом регистра.       |
| | Используйте `in`. | Не используйте `in~`.|
|  | Используйте `contains_cs`.         | Не используйте `contains`.        | Если вы можете использовать `has`/`has_cs`, а не `contains`/`contains_cs`, это даже лучше. |
| **Поиск текста**    |    Поиск в определенном столбце     |    Не используйте `*`.    |   `*` выполняет полнотекстовый поиск по всем столбцам.    |
| **Извлечение полей из [динамических объектов](./scalar-data-types/dynamic.md) в миллионах строк**    |  Материализуйте столбец во время приема, если большинство запросов приводят к извлечению полей из динамических объектов в миллионах строк.      |         | Таким образом, вы будете платить лишь за одно извлечение данных из столбца.    |
| **Поиск редких ключей и значений в [динамических объектах](./scalar-data-types/dynamic.md)**    |  Используйте `MyTable | where DynamicColumn has "Rare value" | where DynamicColumn.SomeKey == "Rare value"`. | Не используйте `MyTable | where DynamicColumn.SomeKey == "Rare value"`. | Таким образом, вы отфильтруете большинство записей и выполните синтаксический анализ JSON только для оставшихся записей. |
| Оператор **`let` со значением, которое используется более одного раза** | Используйте [функцию materialize()](./materializefunction.md). |  |   Дополнительные сведения об использовании функции `materialize()`см. [здесь](materializefunction.md).|
| **Применение преобразований к более чем 1 миллиарду записей**| Измените область запроса, чтобы уменьшить объем данных, поступающих в преобразование.| Не преобразовывайте большие объемы данных, если их можно опустить. | |
| **Новые запросы** | Используйте `limit [small number]` или `count` в конце. | |     Выполнение запросов без ограничений на неизвестном наборе данных может привести к тому, что клиенту будет возвращено несколько ГБ результатов, что приведет к замедлению ответов и перегрузке кластера.|
| **Cравнения с учетом регистра** | Используйте `Col =~ "lowercasestring"`. | Не используйте `tolower(Col) == "lowercasestring"`. |
| **Сравнение данных, которые уже находятся в нижнем регистре (или в верхнем регистре)** | `Col == "lowercasestring"` (или `Col == "UPPERCASESTRING"`) | Старайтесь не использовать сравнения без учета регистра.||
| **Фильтрация по столбцам** |  Фильтруйте по столбцу таблицы.|Не фильтруйте по вычисляемому столбцу. | |
| | Используйте `T | where predicate(<expression>)`. | Не используйте `T | extend _value = <expression> | where predicate(_value)`. ||
| **Оператор summarize** |  Используйте [hint.strategy=shuffle](./shufflequery.md), если `group by keys` оператора суммирования имеет высокую кратность. | | Высокая кратность в идеале превышает 1 миллион.|
|**[Оператор join](./joinoperator.md)** | Выберите первой таблицу с меньшим количеством строк (самая левая в запросе). ||
| Соединение между кластерами |Во всех кластерах выполните запрос на "правой" стороне соединения, где находится большинство данных. ||
|Соединение, если левая часть маленькая, а правая большая | Используйте [hint.strategy=broadcast](./broadcastjoin.md). || Небольшим считается значение до 100 000 записей. |
|Соединение, если обе стороны слишком большие | Используйте [hint.strategy=shuffle](./shufflequery.md). || Используется, когда ключ соединения имеет высокую кратность.|
|**Извлечение значений в столбце, которые имеют общий формат или шаблон строк**|  Используйте [оператор parse](./parseoperator.md). | Не используйте несколько операторов `extract()`.  | Например, значения вроде `"Time = <time>, ResourceId = <resourceId>, Duration = <duration>, ...."`
|**[Функция extract()](./extractfunction.md)**| Используйте, если проанализированные строки не принадлежат к одному и тому же формату или шаблону.| |Извлеките необходимые значения с помощью регулярного выражения.|
| **[Функция materialize()](./materializefunction.md)** . | Принудительно отправьте все возможные операторы, которые уменьшат набор материализованных данных и сохранят при этом семантику запроса. | |Например, фильтры или столбцы, которые нужны только для проекта.

