---
title: оператор mv-apply - Azure Data Explorer Документы Майкрософт
description: В этой статье описывается оператор mv-apply в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.openlocfilehash: f24bf7721707aa1ba3ae9f0aad49b247f08c2498
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81512314"
---
# <a name="mv-apply-operator"></a>Оператор mv-apply

Оператор mv-apply расширяет каждую запись в своей таблице ввода в подтаблицу, применяет подзапрос к каждой подтаблице и возвращает объединение результатов всех подзапросов.

Например, предположим, `T` что `Metric` таблица имеет столбец `dynamic` `real` типа, значения которого представляют собой массивы чисел. Следующий запрос будет находить два самых `Metric` больших значения в каждом значении и возвращать записи, соответствующие этим значениям.

```kusto
T | mv-apply Metric to typeof(real) on (top 2 by Metric desc)
```

В целом, оператор mv-apply можно рассматривать как имеющий следующие шаги обработки:

1. Он использует оператора [mv-expand](./mvexpandoperator.md) для расширения каждой записи в входных данных в подтаблицы.
2. Он применяет подзапрос для каждой из подстолов.
3. Он готовит ноль или больше столбцов к каждой полученной подтаблице, содержащей (повторяющиеся при необходимости) значения столбцов источника, которые не расширяются.
4. Он возвращает союз результатов.

Оператор mv-expand получает следующие входы:

1. Одно или несколько выражений, которые оценивают в динамические массивы для расширения.
   Количество записей в каждой расширенной подтаблице — это максимальная длина каждого из этих динамических массивов. (Если указано несколько выражений, но соответствующие массивы имеют разную длину, при необходимости вводятся нулевые значения.)

2. Дополнительно, имена для присвоения значений выражений, после расширения.
   Они становятся именами столбцов в подтаблицах.
   Если не указано, используется исходное имя столбца (если выражение является ссылкой на столбец) или используется случайное имя (в противном случае).

   > [!NOTE]
   > Рекомендуется использовать имена столбцов по умолчанию.

3. Типы данных элементов этих динамических массивов после расширения.
   Они становятся типами столбцов в подтаблицах.
   Если этот параметр не задан, используется значение `dynamic`.

4. Дополнительно, имя столбца, чтобы добавить к подтаблицы, которые определяют 0-основанный индекс элемента в массиве, что привело к подтаблице записи.

5. Дополнительно, максимальное количество элементов массива для расширения.

Оператор mv-apply можно рассматривать как обобщение оператора [mv-expand](./mvexpandoperator.md) (на самом деле последний может быть реализован первым, если подзапрос включает только прогнозы).

**Синтаксис**

*T* `|` Т `mv-apply` -*Пункт-индекс*- *СтолбыДлярасширитьи* -*РоуЛимит*- `on` `(` *Подкуэри*`)`

Где *ПунктIndex* имеет синтаксис:

`with_itemindex``=` *ИндексКолоблинам*

*ColumnsToExpand* представляет собой запятой разделенный список одного или нескольких элементов формы:

Имя и*фамилия* `=` *ArrayExpression* `to` `typeof` `(`- *Typename*`)`

*RowLimit* просто:

`limit`*RowLimit*

и *Sub'query* имеет тот же синтаксис любого оператора запроса.

**Аргументы**

* *ItemIndex*: При использовании указывает сяруги название столбца типа, `long` приложенных к входной части как часть фазы расширения массива, и указывает 0-основанный индекс массива расширенного значения.

* *Имя*: При использовании имя для присвоения расширенных значений каждого расширенного выражения массива.
  (Если не указано, имя столбца будет использоваться при наличии или случайное имя, генерируемое, если *ArrayExpression* не является простым именем столбца.)

* *ArrayExpression*: Выражение `dynamic` типа, значения которого будут расширены массивом.
  Если выражение — это имя столбца в входной входной части, входной столбец удаляется из ввода и в выводе появится новый столбец того же имени (или *ColumnName,* если указан).

* *Имя тиза*: При использовании используется имя типа, который принимает отдельные элементы `dynamic` массива *ArrayExpression.* Элементы, не соответствующие этому типу, будут заменены нулевую стоимость.
  (Если не `dynamic` указано, используется по умолчанию.)

* *RowLimit*: При использовании ограничение на количество записей для генерации из каждой записи ввода.
  (Если не указано, 2147483647 используется.)

* *Подсукери*: Табулярное выражение запроса с неявным табликовым источником, который наносится на каждый расширенный подстол массива.

**Примечания**

* В отличие от оператора [mv-expand,](./mvexpandoperator.md) оператор mv-apply поддерживает только расширение массива. Там нет поддержки для расширения собственности мешки.

**Примеры**

## <a name="getting-the-largest-element-from-the-array"></a>Получение самого большого элемента из массива

```kusto
let _data =
range x from 1 to 8 step 1
| summarize l=make_list(x) by xMod2 = x % 2;
_data
| mv-apply element=l to typeof(long) on 
(
   top 1 by element
)
```

|xMod2|l           |element|
|-----|------------|-------|
|1    |[1, 3, 5, 7]|7      |
|0    |[2, 4, 6, 8]|8      |

## <a name="calculating-sum-of-largest-two-elments-in-an-array"></a>Расчет суммы крупнейших двух elments в массиве

```kusto
let _data =
range x from 1 to 8 step 1
| summarize l=make_list(x) by xMod2 = x % 2;
_data
| mv-apply l to typeof(long) on
(
   top 2 by l
   | summarize SumOfTop2=sum(l)
)
```

|xMod2|l        |SumOfTop2|
|-----|---------|---------|
|1    |[1,3,5,7]|12       |
|0    |[2,4,6,8]|14       |


## <a name="using-with_itemindex-for-working-with-subset-of-the-array"></a>Использование `with_itemindex` для работы с подмножеством массива

```kusto
let _data =
range x from 1 to 10 step 1
| summarize l=make_list(x) by xMod2 = x % 2;
_data
| mv-apply with_itemindex=index element=l to typeof(long) on 
(
   // here you have 'index' column
   where index >= 3
)
| project index, element
```

|индекс|element|
|---|---|
|3|7|
|4|9|
|3|8|
|4|10|

## <a name="using-mv-apply-operator-to-sort-the-output-of-makelist-aggregate-by-some-key"></a>Использование `mv-apply` оператора для сортировки вывода агрегата `makelist` по некоторым ключевым

```kusto
datatable(command:string, command_time:datetime, user_id:string)
[
    'chmod',        datetime(2019-07-15),   "user1",
    'ls',           datetime(2019-07-02),   "user1",
    'dir',          datetime(2019-07-22),   "user1",
    'mkdir',        datetime(2019-07-14),   "user1",
    'rm',           datetime(2019-07-27),   "user1",
    'pwd',          datetime(2019-07-25),   "user1",
    'rm',           datetime(2019-07-23),   "user2",
    'pwd',          datetime(2019-07-25),   "user2",
]
| summarize commands_details = make_list(pack('command', command, 'command_time', command_time)) by user_id
| mv-apply command_details = commands_details on
(
    order by todatetime(command_details['command_time']) asc
    | summarize make_list(tostring(command_details['command']))
)
| project-away commands_details 
```

|user_id|list_command_details_command|
|---|---|
|user1|[<br>  "ls",<br>  "мкдир",<br>  "хмод",<br>  "дир",<br>  "pwd",<br>  "rm"<br>]|
|user2|[<br>  "rm",<br>  "pwd"<br>]|


**См. также:**

* [mv-расширяющ](./mvexpandoperator.md) оператора.