---
title: Определяемые пользователем функции в Azure Data Explorer | Документация Майкрософт
description: В этой статье описываются определяемые пользователем функции в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/12/2020
ms.localizationpriority: high
ms.openlocfilehash: 92627b3325a7a2ba8e2e4d58a82ebf6db3977221
ms.sourcegitcommit: f49e581d9156e57459bc69c94838d886c166449e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2020
ms.locfileid: "95512882"
---
# <a name="user-defined-functions"></a>Определяемые пользователем функции

**Определяемые пользователем функции** — это повторно используемые вложенные запросы, которые можно определить как часть самого запроса (**специализированные функции**) или сохранить как часть метаданных базы данных (**хранимые функции**). Определяемые пользователем функции вызываются с указанием **имени**, предоставляются с **входными аргументами** (которые могут быть скалярными или табличными) или без них. Кроме того, они выдают одно значение (которое может быть скалярным или табличным) на основе **тела** функции.

Определяемая пользователем функция может принадлежать к одной из двух категорий:

* Скалярные функции 
* табличные функции. 

Входные аргументы и выходные данные функции определяют, является ли она скалярной или табличной, что обуславливает способ ее использования. 

## <a name="scalar-function"></a>Скалярные функции

* Не имеет входных аргументов, или же все ее входные аргументы являются скалярными значениями.
* Выдает одно скалярное значение.
* Может использоваться в тех случаях, если разрешены скалярные выражения.
* Может использовать только контекст строки, в которой она определена.
* Может ссылаться только на таблицы (и представления), которые находятся в доступной схеме.

## <a name="tabular-function"></a>Табличная функция

* Принимает один или несколько табличных входных аргументов и ноль или несколько скалярных входных аргументов.
* Выдает одно табличное значение.

## <a name="function-names"></a>Имена функций

Допустимые имена определяемых пользователем функций должны следовать [правилам именования идентификаторов](../schema-entities/entity-names.md#identifier-naming-rules), которые применяются к другим элементам.

Имя также должно быть уникальным в своей области определения.

> [!NOTE]
> Если хранимая функция и таблица имеют одинаковое имя, при отправке запроса на получение имени таблицы или функции хранимая функция будет переопределена.

## <a name="input-arguments"></a>Входные аргументы

К допустимым определяемым пользователям функциям применяются следующие правила:

* Определяемая пользователем функция имеет строго типизированный список с входными аргументами или без них.
* Входной аргумент имеет имя, тип и (для скалярных аргументов) [значение по умолчанию](#default-values).
* Имя входного аргумента является идентификатором.
* Входной аргумент будет иметь один из типов скалярных данных либо тип табличной схемы.

Синтаксически список входных аргументов представляет собой разделенный запятыми список определений аргументов, заключенный в скобки. Каждое определение аргумента указывается таким образом:

```
ArgName:ArgType [= ArgDefaultValue]
```
 Для табличных аргументов *ArgType* имеет такой же синтаксис, что и определение таблицы (скобки и список пар "имя — тип столбца"), с дополнительной поддержкой отдельного знака `(*)`, обозначающего "любая табличная схема".

Пример:

|Синтаксис                        |Описание списка входных аргументов                                 |
|------------------------------|-----------------------------------------------------------------|
|`()`                          |Без аргументов|
|`(s:string)`                  |Один скалярный аргумент с именем `s`, принимающий значение типа `string`|
|`(a:long, b:bool=true)`       |Два скалярных аргумента, второй из которых имеет значение по умолчанию    |
|`(T1:(*), T2(r:real), b:bool)`|Три аргумента (два табличных и один скалярный)  |

> [!NOTE]
> При одновременном использовании табличных и скалярных входных аргументов следует размещать все табличные входные аргументы перед скалярными.

## <a name="examples"></a>Примеры

Скалярная функция:

```kusto
let Add7 = (arg0:long = 5) { arg0 + 7 };
range x from 1 to 10 step 1
| extend x_plus_7 = Add7(x), five_plus_seven = Add7()
```

Табличная функция, принимающая аргументы:

```kusto
let tenNumbers = () { range x from 1 to 10 step 1};
tenNumbers
| extend x_plus_7 = x + 7
```

Табличная функция, принимающая как табличные, так и скалярные входные аргументы:

```kusto
let MyFilter = (T:(x:long), v:long) {
  T | where x >= v
};
MyFilter((range x from 1 to 10 step 1), 9)
```

|x|
|---|
|9|
|10|

Табличная функция, использующая табличные входные аргументы без указания столбцов.
Функции можно передать любую таблицу, при этом в функции нельзя указывать ссылки на табличные столбцы.

```kusto
let MyDistinct = (T:(*)) {
  T | distinct *
};
MyDistinct((range x from 1 to 3 step 1))
```

|x|
|---|
|1|
|2|
|3|

## <a name="declaring-user-defined-functions"></a>Объявление определяемых пользователем функций

При объявлении определяемой пользователем функции указывается следующее:

* **имя** функции;
* **схема** функции (принимаемые параметры при их наличии);
* **тело** функции.

> [!Note]
> Перегрузка функций не поддерживается. Нельзя создать несколько функций с одним именем и разными входными схемами.

> [!TIP]
> Лямбда-функции не имеют имени, но привязываются к нему с помощью [инструкции let](../letstatement.md). Поэтому их можно считать определяемыми пользователем хранимыми функциями.
> Пример Объявление лямбда-функции, которая принимает два аргумента (`string` с именем `s` и `long` с именем `i`). Она возвращает результат первого аргумента (после преобразования его в число) и второй аргумент. Лямбда-функция привязана к имени `f`:

```kusto
let f=(s:string, i:long) {
    tolong(s) * i
};
```

**Тело** функции включает следующее:

* Ровно одно выражение, которое предоставляет возвращаемое значение функции (скалярное или табличное).
* Любое число (0 или более) [инструкций let](../letstatement.md), областью которых является тело функции. Если инструкции let указаны, они должны предшествовать выражению, определяющему возвращаемое значение функции.
* Любое число (0 или более) [инструкций параметров запросов](../queryparametersstatement.md), которые объявляют параметры запросов, используемые функцией. Если эти инструкции указаны, они должны предшествовать выражению, определяющему возвращаемое значение функции.

> [!NOTE]
> Другие виды [инструкций запросов](../statements.md), которые поддерживаются на "верхнем уровне" запросов, не поддерживаются в теле функции.

### <a name="examples-of-user-defined-functions"></a>Примеры определяемых пользователем функций 

**Определяемая пользователем функция, которая использует инструкцию let**

В следующем примере выполняется привязка имени `Test` к определяемой пользователем функции (лямбда-функция), которая использует три инструкции let. В результате получаем значение `70`:

```kusto
let Test1 = (id: int) {
  let Test2 = 10;
  let Test3 = 10 + Test2 + id;
  let Test4 = (arg: int) {
      let Test5 = 20;
      Test2 + Test3 + Test5 + arg
  };
  Test4(10)
};
range x from 1 to Test1(10) step 1
| count
```

**Определяемая пользователем функция, которая определяет значение по умолчанию для параметра**

В следующем примере демонстрируется функция, которая принимает три аргумента. Два последних имеют значение по умолчанию, при этом их присутствие на месте вызова необязательно.

```kusto
let f = (a:long, b:string = "b.default", c:long = 0) {
  strcat(a, "-", b, "-", c)
};
print f(12, c=7) // Returns "12-b.default-7"
```

## <a name="invoking-a-user-defined-function"></a>Вызов определяемой пользователем функции

Определяемую пользователем функцию, которая не принимает аргументы, можно вызвать по имени либо по ее имени и пустому списку аргументов в скобках.

Примеры

```kusto
// Bind the identifier a to a user-defined function (lambda) that takes
// no arguments and returns a constant of type long:
let a=(){123};
// Invoke the function in two equivalent ways:
range x from 1 to 10 step 1
| extend y = x * a, z = x * a() 
```

```kusto
// Bind the identifier T to a user-defined function (lambda) that takes
// no arguments and returns a random two-by-two table:
let T=(){
  range x from 1 to 2 step 1
  | project x1 = rand(), x2 = rand()
};
// Invoke the function in two equivalent ways:
// (Note that the second invocation must be itself wrapped in
// an additional set of parentheses, as the union operator
// differentiates between "plain" names and expressions)
union T, (T())
```

Определяемую пользователем функцию, которая принимает один или несколько скалярных аргументов, можно вызвать по имени таблицы и конкретного списка аргументов в скобках:

```kusto
let f=(a:string, b:string) {
  strcat(a, " (la la la)", b)
};
print f("hello", "world")
```

Определяемую пользователем функцию, которая принимает один или несколько табличных аргументов (и любое число скалярных аргументов), можно вызвать по имени таблицы и конкретного списка аргументов в скобках:

```kusto
let MyFilter = (T:(x:long), v:long) {
  T | where x >= v 
};
MyFilter((range x from 1 to 10 step 1), 9)
```

Вы также можете использовать оператор `invoke` для вызова определяемой пользователем функции, которая принимает один или несколько табличных аргументов и возвращает таблицу. Эта функция полезна, если первый конкретный табличный аргумент для функции является источником оператора `invoke`:

```kusto
let append_to_column_a=(T:(a:string), what:string) {
    T | extend a=strcat(a, " ", what)
};
datatable (a:string) ["sad", "really", "sad"]
| invoke append_to_column_a(":-)")
```

## <a name="default-values"></a>Значения по умолчанию

Функции могут предоставлять значения по умолчанию для некоторых из своих параметров при следующих условиях:

* Значения по умолчанию могут предоставляться только для скалярных параметров.
* Значения по умолчанию всегда являются литералами (константами). Они не могут быть произвольными вычислениями.
* Параметры без значения по умолчанию всегда предшествуют параметрам, имеющим значения по умолчанию.
* Вызывающие объекты должны предоставлять значения всех параметров без значений по умолчанию, упорядоченных так же, как и объявление функции.
* Вызывающим объектам не нужно предоставлять значения для параметров со значениями по умолчанию, но они могут это делать.
* Вызывающие объекты могут предоставлять аргументы в порядке, который не соответствует порядку параметров. В таком случае они должны присвоить имена аргументам.

В следующем примере возвращается таблица с двумя идентичными записями. При первом вызове `f` аргументы полностью "зашифрованы", поэтому каждому из них явным образом присваивается имя:

```kusto
let f = (a:long, b:string = "b.default", c:long = 0) {
  strcat(a, "-", b, "-", c)
};
union
  (print x=f(c=7, a=12)), // "12-b.default-7"
  (print x=f(12, c=7))    // "12-b.default-7"
```

|x|
|---|
|12-b.default-7|
|12-b.default-7|

## <a name="view-functions"></a>Функции представлений

Определяемая пользователем функция, которая не принимает аргументы и возвращает табличное выражение, может быть помечена как **представление**. Такая метка означает, что функция ведет себя подобно таблице, когда выполняется разрешение имени таблицы с подстановочными знаками.
В следующем примере приведены две определяемые пользователем функции, `T_view` и `T_notview`, а также показано, как разрешается только первая из них с помощью подстановочной ссылки в `union`:

```kusto
let T_view = view () { print x=1 };
let T_notview = () { print x=2 };
union T*
```

## <a name="restrictions"></a>Ограничения

Применяются следующие ограничения:

* Определяемые пользователем функции не могут передаваться в сведения вызова [toscalar()](../toscalarfunction.md), которые зависят от контекста строки, в которой вызывается функция.
* Определяемые пользователем функции, возвращающие табличное выражение, нельзя вызвать с аргументом, который зависит от контекста строки.
* Функция, принимающая хотя бы один табличный ввод, не может быть вызвана в удаленном кластере.
* Скалярная функция не может быть вызвана в удаленном кластере.

Только определяемая пользователем функция может вызываться с аргументом, который зависит от контекста строки, если определяемая пользователем функция состоит только из скалярных функций и не использует `toscalar()`.

**Пример ограничения 1**

```kusto
// Supported:
// f is a scalar function that doesn't reference any tabular expression
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { now() + hours*1h };
Table2 | where Column != 123 | project d = f(10)

// Supported:
// f is a scalar function that references the tabular expression Table1,
// but is invoked with no reference to the current row context f(10):
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { toscalar(Table1 | summarize min(xdate) - hours*1h) };
Table2 | where Column != 123 | project d = f(10)

// Not supported:
// f is a scalar function that references the tabular expression Table1,
// and is invoked with a reference to the current row context f(Column):
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { toscalar(Table1 | summarize min(xdate) - hours*1h) };
Table2 | where Column != 123 | project d = f(Column)
```

**Пример ограничения 2**

```kusto
// Not supported:
// f is a tabular function that is invoked in a context
// that expects a scalar value.
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { range x from 1 to hours step 1 | summarize make_list(x) };
Table2 | where Column != 123 | project d = f(Column)
```

## <a name="features-that-are-currently-unsupported-by-user-defined-functions"></a>Функции, которые в настоящее время не поддерживаются определяемыми пользователем функциями

Для полноты ниже приведены некоторые часто запрашиваемые возможности для определяемых пользователем функций, которые в настоящее время не поддерживаются:

1.  Перегрузка функции: в настоящее время отсутствует способ перегрузки функции (т. е. создание нескольких функций с одинаковым именем и разными входными схемами).

2.  Значения по умолчанию: значение по умолчанию для скалярного параметра функции должно быть скалярным литералом (константой). Кроме того, хранимые функции не могут иметь значение по умолчанию типа `dynamic`.
