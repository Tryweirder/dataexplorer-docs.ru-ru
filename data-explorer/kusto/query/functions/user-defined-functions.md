---
title: Функции, определяемые пользователем - Azure Data Explorer Документы Майкрософт
description: В этой статье описаны функции, определяемые пользователем в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/12/2020
ms.openlocfilehash: e8372be303b1540e1421f226ed0fd0fe74d44545
ms.sourcegitcommit: c4aea69fafa9d9fbb814764eebbb0ae93fa87897
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81610245"
---
# <a name="user-defined-functions"></a>Определяемые пользователем функции

Kusto поддерживает функции, определяемые пользователем, которые являются либо:
* Часть самого запроса **(специальные функции)** 
* Хранится в постоянном порядке в рамках метаданных базы данных **(сохраненные функции)**

Функция, определяемая пользователем, имеет:
* Имя:
    * Должны следовать [правилам именования идентификаторов](../schema-entities/entity-names.md#identifier-naming-rules)
    * Должен быть уникальным в области определения с типом спецификации
* Сильно типидированный список входных параметров:
    * Может быть скалярные или табулярные выражения
    * Параметры Scalar могут быть предоставлены значением по умолчанию, используемым неявно, когда абонент функции не обеспечивает значение для параметра (см. [значения по умолчанию](#default-values), ниже)
* Сильно набраное значение возврата, которое может быть скалярным или таблисным

Входы и вывод функции определяют, как и где она может быть использована:

* **Функция масштабирования:** 
    * Функция без входов, или только с масштабными входными путями, и которая производит вывод scalar
    * Может использоваться там, где допускается скалярное выражение
    * Может использовать только контекст строки, в котором он определен
    * Можно ссылаться только на таблицы (и представления), которые находятся в доступной схеме

Пример.

```kusto
let Add7 = (arg0:long = 5) { arg0 + 7 };
range x from 1 to 10 step 1
| extend x_plus_7 = Add7(x), five_plus_seven = Add7()
```

* **Табулярная функция:** 
    * Функция без входов, или, по крайней мере, один табулярный вход, и производит табличного вывода
    * Может использоваться там, где допускается таблоиское выражение 

> [!NOTE]
> Все табловые параметры должны отображаться до параметров масштабирования.

Пример таблолярной функции, которая не принимает аргументов:

```kusto
let tenNumbers = () { range x from 1 to 10 step 1};
tenNumbers
| extend x_plus_7 = x + 7
```

Пример таблолярной функции, используюейй табулярный вход и ввод скалара:

```kusto
let MyFilter = (T:(x:long), v:long) {
  T | where x >= v 
};
MyFilter((range x from 1 to 10 step 1), 9)
```

|x|
|---|
|9|
|10|

Пример таблоузловой функции, используюейтой табликового ввода без определенного столбца. Любая таблица может быть передана функции, и ни один столбец таблицы не может быть отсылкой внутри функции.

```kusto
let MyDistinct = (T:(*)) {
  T | distinct * 
};
MyDistinct((range x from 1 to 3 step 1))
```

|x|
|---|
|1|
|2|
|3|

## <a name="declaring-user-defined-functions"></a>Объявление функций, определяемых пользователем

Декларация функции, определяемой пользователем, предусматривает:

* **Имя** функции
* **Схема** функции (параметры, которые она принимает, если таковые имеется)
* Функциональное **тело**

> [!Note]
> Функции перегрузки не поддерживаются. Например, нельзя создать несколько функций с одинаковым именем и различными схемами ввода.

> [!TIP]
> Функции Lambda не имеют имени и привязаны к имени, используя [let statement.](../letstatement.md) Таким образом, они могут рассматриваться как пользовательские функции хранения.
> Пример: Декларация для функции лямбды, `string` `s` которая `long` принимает `i`два аргумента (называется и называется ). Он возвращает продукт первого (после преобразования его в число) и второго. Лямбда связана с `f`именем:

```kusto
let f=(s:string, i:long) {
    tolong(s) * i
};
```

Функциональное **тело** включает в себя:

* Ровно одно выражение, которое обеспечивает значение возврата функции (масштабируемое или таблолярное значение).
* Любое число (ноль или более) [пусть операторы](../letstatement.md), сфера которого является областью, что из тела функции. Если указано, операторы let должны предшествовать выражению, определяющему значение возврата функции.
* Любое число (ноль или более) [инструкций параметров запроса,](../queryparametersstatement.md)которые объявляют параметры запроса, используемые функцией. Если указано, они должны предшествовать выражению, определяющему значение возврата функции.

> [!NOTE]
> Другие виды [инструкций запроса,](../statements.md) которые поддерживаются на запросе "верхний уровень", не поддерживаются внутри органа функции.

### <a name="examples-of-user-defined-functions"></a>Примеры функций, определяемых пользователем 

**Функция, определяемая пользователем, используюая оператора let**

Следующий пример связывает `Test` имя с функцией, определяемой пользователем (lambda), которая использует три инструкции let. `70`Выход:

```kusto
let Test1 = (id: int) {
  let Test2 = 10;
  let Test3 = 10 + Test2 + id;
  let Test4 = (arg: int) {
      let Test5 = 20;
      Test2 + Test3 + Test5 + arg
  };
  Test4(10)
};
range x from 1 to Test1(10) step 1
| count
```

**Функция, определяемая пользователем, определяющая значение по умолчанию для параметра**

В следующем примере показана функция, которая принимает три аргумента. Последние два имеют значение по умолчанию и не должны присутствовать на сайте вызова.

```kusto
let f = (a:long, b:string = "b.default", c:long = 0) {
  strcat(a, "-", b, "-", c)
};
print f(12, c=7) // Returns "12-b.default-7"
```

## <a name="invoking-a-user-defined-function"></a>Ссылаясь на функцию, определяемую пользователем

Функция, определяемая пользователем, которая не требует аргументов, может быть вызвана своим именем или именем с пустым списком аргументов в скобках.

Примеры:

```kusto
// Bind the identifier a to a user-defined function (lambda) that takes
// no arguments and returns a constant of type long:
let a=(){123};
// Invoke the function in two equivalent ways:
range x from 1 to 10 step 1
| extend y = x * a, z = x * a() 
```

```kusto
// Bind the identifier T to a user-defined function (lambda) that takes
// no arguments and returns a random two-by-two table:
let T=(){
  range x from 1 to 2 step 1
  | project x1 = rand(), x2 = rand()
};
// Invoke the function in two equivalent ways:
// (Note that the second invocation must be itself wrapped in
// an additional set of parentheses, as the union operator
// differentiates between "plain" names and expressions)
union T, (T())
```

Функция, определяемая пользователем, которая требует одного или нескольких аргументов, может быть вызвана с помощью названия таблицы и конкретного списка аргументов в скобках:

```kusto
let f=(a:string, b:string) {
  strcat(a, " (la la la)", b)
};
print f("hello", "world")
```

Функция, определяемая пользователем, которая принимает один или несколько аргументов таблицы (и любое количество аргументов scalar), может быть вызвана с помощью названия таблицы и конкретного списка аргументов в скобках:

```kusto
let MyFilter = (T:(x:long), v:long) {
  T | where x >= v 
};
MyFilter((range x from 1 to 10 step 1), 9)
```

Оператор также может `invoke` использоваться для того, чтобы вызвать функцию, определяемую пользователем, которая требует одного или нескольких аргументов таблицы и возвращает таблицу. Это полезно, когда первым конкретным аргументом таблицы `invoke` для функции является источник оператора:

```kusto
let append_to_column_a=(T:(a:string), what:string) {
    T | extend a=strcat(a, " ", what)
};
datatable (a:string) ["sad", "really", "sad"]
| invoke append_to_column_a(":-)")
```

## <a name="default-values"></a>Значения по умолчанию

Функции могут предоставлять значения по умолчанию для некоторых из их параметров при следующих условиях:

* Значения по умолчанию могут быть предусмотрены только для параметров масштабирования.
* Значения по умолчанию всегда являются буквальными (константами). Они не могут быть произвольными расчетами.
* Параметры без значения по умолчанию всегда предшествуют параметрам, которые имеют значение по умолчанию.
* Абоненты должны указывать значение всех параметров без значений по умолчанию, расположенных в том же порядке, что и декларация функций.
* Абонентам не нужно предоставлять значение для параметров со значениями по умолчанию, но они могут это сделать.
* Звонящие могут предоставить аргументы в порядке, который не соответствует порядку параметров. Если это так, они должны назвать свои аргументы.

Следующий пример возвращает таблицу с двумя идентичными записями. В первом призыве `f`, аргументы полностью "скремблировали", так что каждый из них явно дано имя:

```kusto
let f = (a:long, b:string = "b.default", c:long = 0) {
  strcat(a, "-", b, "-", c)
};
union
  (print x=f(c=7, a=12)), // "12-b.default-7"
  (print x=f(12, c=7))    // "12-b.default-7"
```

|x|
|---|
|12-b.default-7|
|12-b.default-7|

## <a name="view-functions"></a>Просмотр функций

Функция, определяемая пользователем, которая не требует аргументов и возвращает табулярное выражение, может быть помечено как **представление.** Маркировка функции, определяемой пользователем, как представление означает, что функция ведет себя как таблица всякий раз, когда выполняется разрешение имени таблицы подстановочных знаков.
Следующий пример показывает две функции, определенные пользователем, и `T_view` `T_notview`показывает, как только `union`первый из них решается ссылкой подстановочного знака в :

```kusto
let T_view = view () { print x=1 };
let T_notview = () { print x=2 };
union T*
```

## <a name="user-defined-functions-usage-restrictions"></a>Ограничения на использование функций, определенных пользователем

Применяются следующие ограничения:

* Функции, определяемые пользователем, не могут передаваться в информацию вызова [toscalar()](../toscalarfunction.md) которая зависит от строки-контекста, в котором вызывается функция.
* Функции, определяемые пользователем, возвращающие табулярное выражение, не могут быть вызваны аргументом, который изменяется в зависимости от контекста строки.
* Функция, принимая по крайней мере один табулярный вход, не может быть вызвана в удаленном кластере.
* Функция масштабирования не может быть вызвана в удаленном кластере.

Единственное место, на которое может ссылаться функция, определяемая пользователем, с аргументом, который варьируется в `toscalar()`зависимости от контекста строки, это когда функция, определяемая пользователем, состоит только из функций масштабирования и не использует.

**Пример ограничения 1**

```kusto
// Supported:
// f is a scalar function that doesn't reference any tabular expression
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { now() + hours*1h };
Table2 | where Column != 123 | project d = f(10)

// Supported:
// f is a scalar function that references the tabular expression Table1,
// but is invoked with no reference to the current row context f(10):
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { toscalar(Table1 | summarize min(xdate) - hours*1h) };
Table2 | where Column != 123 | project d = f(10)

// Not supported:
// f is a scalar function that references the tabular expression Table1,
// and is invoked with a reference to the current row context f(Column):
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { toscalar(Table1 | summarize min(xdate) - hours*1h) };
Table2 | where Column != 123 | project d = f(Column)
```

**Пример ограничения 2**

```kusto
// Not supported:
// f is a tabular function that is invoked in a context
// that expects a scalar value.
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { range x from 1 to hours step 1 | summarize make_list(x) };
Table2 | where Column != 123 | project d = f(Column)
```
