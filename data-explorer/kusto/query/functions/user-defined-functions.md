---
title: Определяемые пользователем функции в Azure обозреватель данных | Документация Майкрософт
description: В этой статье описываются определяемые пользователем функции в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/12/2020
ms.openlocfilehash: e9e199631d57f3fd3be8d438e6b0cdbf9bdd4266
ms.sourcegitcommit: 39b04c97e9ff43052cdeb7be7422072d2b21725e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/12/2020
ms.locfileid: "83227365"
---
# <a name="user-defined-functions"></a>Определяемые пользователем функции

**Определяемые пользователем функции** — это многократно используемые вложенные запросы, которые могут быть определены как часть самого запроса (**нерегламентированные функции**) или сохранены как часть метаданных базы данных (**хранимых функций**). Определяемые пользователем функции вызываются через **имя**, предоставляются с нулевым или более **входными аргументами** (которые могут быть скалярными или табличными) и создают одно значение (которое может быть скалярным или табличным) на основе **тела**функции.

Определяемая пользователем функция принадлежит к одной из двух категорий:

* Скалярные функции 
* Табличные функции 

Входные аргументы и выходные данные функции определяют, является ли она скалярной или табличной, которая затем определяет, как она может использоваться. 

## <a name="scalar-function"></a>Скалярные функции

* Содержит нуль входных аргументов или все входные аргументы являются скалярными значениями
* Создает одно скалярное значение
* Можно использовать везде, где разрешено скалярное выражение
* Может использоваться только контекст строки, в котором она определена
* Может ссылаться только на таблицы (и представления), которые находятся в доступной схеме.

## <a name="tabular-function"></a>Табличная функция

* Принимает один или несколько табличных входных аргументов, а также ноль или более скалярных входных аргументов и/или:
* Создает одно табличное значение

## <a name="function-names"></a>Имена функций

Допустимые имена определяемых пользователем функций должны соответствовать тем же [правилам именования идентификаторов](../schema-entities/entity-names.md#identifier-naming-rules) , что и другие сущности.

Имя должно также быть уникальным в области определения.

> [!NOTE]
> Перегрузка функций не поддерживается. Нельзя определить несколько функций с одним и тем же именем.

## <a name="input-arguments"></a>Входные аргументы

Допустимые пользовательские функции соответствуют следующим правилам.

* Определяемая пользователем функция имеет строго типизированный список из нуля или более входных аргументов.
* Входной аргумент имеет имя, тип и (для скалярных аргументов) [значение по умолчанию](#default-values).
* Имя входного аргумента является идентификатором.
* Тип входного аргумента является либо одним из скалярных типов данных, либо табличной схемой.

Синтаксически, список входных аргументов представляет собой разделенный запятыми список определений аргументов, заключенный в круглые скобки. Каждое определение аргумента указывается как

```
ArgName:ArgType [= ArgDefaultValue]
```
 Для табличных аргументов *аргтипе* имеет тот же синтаксис, что и определение таблицы (скобки и список пар "имя столбца/тип") с дополнительной поддержкой одиночные, `(*)` указывающей "любая табличная схема".

Пример:

|Синтаксис                        |Список входных аргументов описание                                 |
|------------------------------|-----------------------------------------------------------------|
|`()`                          |Нет аргументов|
|`(s:string)`                  |Один скалярный аргумент `s` , называемый получением значения типа`string`|
|`(a:long, b:bool=true)`       |Два скалярных аргумента, второй из которых имеет значение по умолчанию    |
|`(T1:(*), T2(r:real), b:bool)`|Три аргумента (два табличных аргумента и один скалярный аргумент)  |

> [!NOTE]
> При использовании как табличных входных аргументов, так и скалярных входных аргументов следует размещать все табличные входные аргументы перед скалярными входными аргументами.

## <a name="examples"></a>Примеры

Скалярная функция:

```kusto
let Add7 = (arg0:long = 5) { arg0 + 7 };
range x from 1 to 10 step 1
| extend x_plus_7 = Add7(x), five_plus_seven = Add7()
```

Табличная функция не принимает аргументы:

```kusto
let tenNumbers = () { range x from 1 to 10 step 1};
tenNumbers
| extend x_plus_7 = x + 7
```

Табличная функция, принимающая как табличные входные данные, так и скалярные входные данные:

```kusto
let MyFilter = (T:(x:long), v:long) {
  T | where x >= v
};
MyFilter((range x from 1 to 10 step 1), 9)
```

|x|
|---|
|9|
|10|

Табличная функция, которая использует табличный ввод без указания столбца.
Любая таблица может быть передана в функцию, а в функции нельзя ссылаться на столбцы таблицы.

```kusto
let MyDistinct = (T:(*)) {
  T | distinct *
};
MyDistinct((range x from 1 to 3 step 1))
```

|x|
|---|
|1|
|2|
|3|

## <a name="declaring-user-defined-functions"></a>Объявление определяемых пользователем функций

Объявление определяемой пользователем функции предоставляет:

* **Имя** функции
* **Схема** функции (параметры, которые она принимает, если таковая имеется)
* **Тело** функции

> [!Note]
> Перегрузка функций не поддерживается. Нельзя создать несколько функций с одинаковым именем и разными входными схемами.

> [!TIP]
> Лямбда-функции не имеют имени и привязываются к имени с помощью [инструкции Let](../letstatement.md). Поэтому их можно рассматривать как пользовательские хранимые функции.
> Пример: объявление для лямбда-функции, принимающей два аргумента ( `string` вызываемый `s` и `long` вызываемый `i` ). Он возвращает произведение первого (после преобразования в число) и второго. Лямбда-выражение привязано к имени `f` :

```kusto
let f=(s:string, i:long) {
    tolong(s) * i
};
```

**Тело** функции включает:

* Ровно одно выражение, которое предоставляет возвращаемое значение функции (скалярное или табличное значение).
* Любое число (ноль или более) [операторов Let](../letstatement.md), область которых равна телу тела функции. Если этот параметр указан, операторы let должны предшествовать выражению, определяющему возвращаемое значение функции.
* Любое число (ноль или более) [операторов параметров запроса](../queryparametersstatement.md), которые объявляют параметры запроса, используемые функцией. Если указано, они должны предшествовать выражению, определяющему возвращаемое значение функции.

> [!NOTE]
> Другие типы [инструкций запросов](../statements.md) , которые поддерживаются в запросе "верхний уровень", не поддерживаются внутри тела функции.

### <a name="examples-of-user-defined-functions"></a>Примеры определяемых пользователем функций 

**Определяемая пользователем функция, использующая инструкцию Let**

В следующем примере имя привязывается `Test` к определяемой пользователем функции (лямбда), использующей три инструкции Let. Выходные данные `70` :

```kusto
let Test1 = (id: int) {
  let Test2 = 10;
  let Test3 = 10 + Test2 + id;
  let Test4 = (arg: int) {
      let Test5 = 20;
      Test2 + Test3 + Test5 + arg
  };
  Test4(10)
};
range x from 1 to Test1(10) step 1
| count
```

**Определяемая пользователем функция, определяющая значение по умолчанию для параметра**

В следующем примере показана функция, которая принимает три аргумента. Два последних имеют значение по умолчанию и не обязательно должны присутствовать в месте вызова.

```kusto
let f = (a:long, b:string = "b.default", c:long = 0) {
  strcat(a, "-", b, "-", c)
};
print f(12, c=7) // Returns "12-b.default-7"
```

## <a name="invoking-a-user-defined-function"></a>Вызов определяемой пользователем функции

Определяемая пользователем функция, которая не принимает аргументы, может быть вызвана либо по имени, либо по имени и пустому списку аргументов в круглых скобках.

Примеры:

```kusto
// Bind the identifier a to a user-defined function (lambda) that takes
// no arguments and returns a constant of type long:
let a=(){123};
// Invoke the function in two equivalent ways:
range x from 1 to 10 step 1
| extend y = x * a, z = x * a() 
```

```kusto
// Bind the identifier T to a user-defined function (lambda) that takes
// no arguments and returns a random two-by-two table:
let T=(){
  range x from 1 to 2 step 1
  | project x1 = rand(), x2 = rand()
};
// Invoke the function in two equivalent ways:
// (Note that the second invocation must be itself wrapped in
// an additional set of parentheses, as the union operator
// differentiates between "plain" names and expressions)
union T, (T())
```

Определяемая пользователем функция, которая принимает один или несколько скалярных аргументов, может быть вызвана с помощью имени таблицы и конкретного списка аргументов в круглых скобках:

```kusto
let f=(a:string, b:string) {
  strcat(a, " (la la la)", b)
};
print f("hello", "world")
```

Определяемая пользователем функция, которая принимает один или несколько табличных аргументов (и любое количество скалярных аргументов), может быть вызвана с помощью имени таблицы и конкретного списка аргументов в круглых скобках:

```kusto
let MyFilter = (T:(x:long), v:long) {
  T | where x >= v 
};
MyFilter((range x from 1 to 10 step 1), 9)
```

Оператор также можно использовать `invoke` для вызова определяемой пользователем функции, которая принимает один или несколько табличных аргументов и возвращает таблицу. Эта функция полезна, когда первый конкретный аргумент таблицы для функции является источником `invoke` оператора:

```kusto
let append_to_column_a=(T:(a:string), what:string) {
    T | extend a=strcat(a, " ", what)
};
datatable (a:string) ["sad", "really", "sad"]
| invoke append_to_column_a(":-)")
```

## <a name="default-values"></a>Значения по умолчанию

Функции могут предоставлять значения по умолчанию некоторым из их параметров при следующих условиях.

* Значения по умолчанию могут предоставляться только для скалярных параметров.
* Значения по умолчанию всегда являются литералами (константами). Они не могут быть произвольными вычислениями.
* Параметры без значения по умолчанию всегда предшествуют параметрам, имеющим значение по умолчанию.
* Вызывающие объекты должны предоставлять значения всех параметров без значений по умолчанию, упорядоченных в том же порядке, что и объявление функции.
* Вызывающим объектам не нужно указывать значения для параметров со значениями по умолчанию, но это может сделать.
* Вызывающие объекты могут предоставлять аргументы в порядке, который не соответствует порядку параметров. Если это так, они должны присвоить имена аргументам.

В следующем примере возвращается таблица с двумя идентичными записями. При первом вызове `f` аргументы полностью «зашифрованы», поэтому каждому из них явным образом присваивается имя:

```kusto
let f = (a:long, b:string = "b.default", c:long = 0) {
  strcat(a, "-", b, "-", c)
};
union
  (print x=f(c=7, a=12)), // "12-b.default-7"
  (print x=f(12, c=7))    // "12-b.default-7"
```

|x|
|---|
|12-б. по умолчанию — 7|
|12-б. по умолчанию — 7|

## <a name="view-functions"></a>Просмотр функций

Определяемая пользователем функция, которая не принимает аргументы и возвращает табличное выражение, может быть помечена как **представление**. Пометка определяемой пользователем функции как представления означает, что функция ведет себя подобно таблице, когда выполняется разрешение имени таблицы с подстановочными знаками.
В следующем примере показаны две определяемые пользователем функции, `T_view` и `T_notview` показано, как только первый из них разрешается с помощью подстановочной ссылки в `union` :

```kusto
let T_view = view () { print x=1 };
let T_notview = () { print x=2 };
union T*
```

## <a name="restrictions"></a>Ограничения

Применяются следующие ограничения:

* Определяемые пользователем функции не могут передавать данные вызова [тоскалар ()](../toscalarfunction.md) , зависящие от контекста строки, в котором вызывается функция.
* Определяемые пользователем функции, возвращающие табличное выражение кан'тбе, вызванное с аргументом, который зависит от контекста строки.
* Функция, принимающая хотя бы один табличный ввод, не может быть вызвана в удаленном кластере.
* Скалярная функция не может быть вызвана в удаленном кластере.

Только определяемая пользователем функция может вызываться с аргументом, который зависит от контекста строки, если определяемая пользователем функция состоит только из скалярных функций и не используется `toscalar()` .

**Пример ограничения 1**

```kusto
// Supported:
// f is a scalar function that doesn't reference any tabular expression
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { now() + hours*1h };
Table2 | where Column != 123 | project d = f(10)

// Supported:
// f is a scalar function that references the tabular expression Table1,
// but is invoked with no reference to the current row context f(10):
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { toscalar(Table1 | summarize min(xdate) - hours*1h) };
Table2 | where Column != 123 | project d = f(10)

// Not supported:
// f is a scalar function that references the tabular expression Table1,
// and is invoked with a reference to the current row context f(Column):
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { toscalar(Table1 | summarize min(xdate) - hours*1h) };
Table2 | where Column != 123 | project d = f(Column)
```

**Пример ограничения 2**

```kusto
// Not supported:
// f is a tabular function that is invoked in a context
// that expects a scalar value.
let Table1 = datatable(xdate:datetime)[datetime(1970-01-01)];
let Table2 = datatable(Column:long)[1235];
let f = (hours:long) { range x from 1 to hours step 1 | summarize make_list(x) };
Table2 | where Column != 123 | project d = f(Column)
```
