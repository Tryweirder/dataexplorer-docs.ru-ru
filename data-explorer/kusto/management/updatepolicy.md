---
title: Политика обновления Kusto для данных, добавляемых в исходный обозреватель данных Azure
description: В этой статье описывается политика обновления в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 08/04/2020
ms.openlocfilehash: 8f19606a75c388917a5195d0ac5cbb0ecf4335f9
ms.sourcegitcommit: 80f0c8b410fa4ba5ccecd96ae3803ce25db4a442
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/30/2020
ms.locfileid: "96321137"
---
# <a name="update-policy-overview"></a>Обзор политики обновления

[Политика обновления](update-policy.md) указывает Kusto автоматически добавлять данные в целевую таблицу при вставке новых данных в исходную таблицу на основе запроса преобразования, выполняющегося на данных, вставленных в исходную таблицу.

:::image type="content" source="images/updatepolicy/update-policy-overview.png" alt-text="Общие сведения о политике обновления в Azure обозреватель данных":::

Например, политика позволяет создать одну таблицу с отфильтрованным представлением другой таблицы. Новая таблица может иметь другую схему, политику хранения и т. д. 

Политика обновления подчиняется тем же ограничениям и рекомендациям, что и при обычном приеме. Политика масштабируется с учетом размера кластера и работает более эффективно, если приемы выполняются в больших массах.

> [!NOTE]
> Исходная таблица и таблица, для которых определена политика обновления, должны находиться в одной базе данных.
> Схема функции обновления политики и Целевая схема таблицы должны совпадать в именах столбцов, типах и порядке.

## <a name="update-policys-query"></a>Обновление запроса политики

Запрос политики обновления выполняется в специальном режиме, в котором он автоматически охватывает только новые принимаемые записи, и в рамках этого запроса нельзя запрашивать данные, которые уже были приняты исходной таблицей. Однако данные, полученные в "границе" политик обновления транзакций, становятся доступными для запроса в одной транзакции. Так как политика обновления определена в целевой таблице, передача данных в одну исходную таблицу может привести к выполнению нескольких запросов к этим данным. Порядок выполнения нескольких политик обновления не определен. 

### <a name="query-limitations"></a>Ограничения запросов 

* Запрос может вызывать хранимые функции, но не может включать запросы между базами данных и между кластерами. 
* Запрос, который выполняется как часть политики обновления, не имеет доступа на чтение к таблицам с включенной [политикой рестриктедвиевакцесс](restrictedviewaccesspolicy.md) или с включенной [политикой безопасность на уровне строк](rowlevelsecuritypolicy.md) .
* При ссылке на `Source` таблицу в `Query` части политики или в функции, на которые ссылается `Query` часть:
   * Не используйте полное имя таблицы. Вместо этого используйте `TableName`. 
   * Не используйте `database("DatabaseName").TableName` или `cluster("ClusterName").database("DatabaseName").TableName` .

> [!WARNING]
> Определение неверного запроса в политике обновления может препятствовать передаче данных в исходную таблицу.

## <a name="the-update-policy-object"></a>Объект политики обновления

С таблицей может быть связано не менее одного или нескольких объектов политики обновления.
Каждый такой объект представлен в виде контейнера свойств JSON со следующими определенными свойствами.

|Свойство |Тип |Описание  |
|---------|---------|----------------|
|IsEnabled                     |`bool`  |Указывает, включена ли политика обновления (true) или отключена (false)                                                                                                                               |
|Источник                        |`string`|Имя таблицы, которая активирует вызов политики обновления                                                                                                                                 |
|Запрос                         |`string`|Запрос Kusto CSL, который используется для получения данных для обновления.                                                                                                                           |
|IsTransactional               |`bool`  |Указывает, является ли политика обновления транзакционной или нет (значение по умолчанию — false). Не удалось запустить политику обновления транзакций, так как исходная таблица не обновляется новыми данными   |
|пропагатеинжестионпропертиес  |`bool`  |Указывает, что свойства приема (Теги экстентов и время создания), заданные во время приема в исходной таблице, также должны применяться к тем, которые относятся к производной таблице.                 |

> [!NOTE]
> Каскадные обновления разрешены ( `TableA` → `TableB` → `TableC` → >...).
>
> Однако, если политики обновления определены в нескольких таблицах циклически, цепочка обновлений будет обрезана. Эта проблема обнаружена во время выполнения. Данные будут приниматься только один раз для каждой таблицы в цепочке затронутых таблиц.

## <a name="update-policy-commands"></a>Команды политики обновления

Ниже приведены команды для управления политикой обновления.

* [`.show table *TableName* policy update`](update-policy.md#show-update-policy) показывает текущую политику обновления таблицы.
* [`.alter table *TableName* policy update`](update-policy.md#alter-update-policy) Задает текущую политику обновления таблицы.
* [`.alter-merge table *TableName* policy update`](update-policy.md#alter-merge-table-tablename-policy-update) добавляет к текущей политике обновления таблицы.
* [`.delete table *TableName* policy update`](update-policy.md#delete-table-tablename-policy-update) добавляет к текущей политике обновления таблицы.

## <a name="update-policy-is-initiated-following-ingestion"></a>Политика обновления инициирована после приема

Политики обновления вступают в силу при приеме или перемещении данных в (экстенты создаются в) определенной исходной таблице с помощью любой из следующих команд:

* [. приема (Pull)](../management/data-ingestion/ingest-from-storage.md)
* [. прием (встроенный)](../management/data-ingestion/ingest-inline.md)
* [. Set |. append |. Set-или-Append |. Set-или-Replace](../management/data-ingestion/ingest-from-query.md)
  * Когда политика обновления вызывается как часть  `.set-or-replace` команды, поведение по умолчанию заключается в том, что данные в производных таблицах заменяются так же, как и в исходной таблице.
* [.move extents](./move-extents.md)
* [.replace extents](./replace-extents.md)
  * `PropagateIngestionProperties`Команда вступает в силу только при операциях приема. Если политика обновления запускается как часть `.move extents` `.replace extents` команды или, этот параметр не действует.

## <a name="regular-ingestion-using-update-policy"></a>Обычное получение с помощью политики обновления

Политика обновления будет вести себя как обычное приема, если выполняются следующие условия.

* Исходная таблица является высокоскоростной таблицей трассировки с интересными данными в виде свободного текстового столбца. 
* Целевая таблица, в которой определена политика обновления, принимает только определенные строки трассировки.
* Таблица имеет хорошо структурированную схему, которая является преобразованием исходных произвольных текстовых данных, созданных [оператором Parse](../query/parseoperator.md).

## <a name="zero-retention-on-source-table"></a>Нулевое хранение в исходной таблице

Иногда данные поступают в исходную таблицу только в качестве пошагового камень в целевую таблицу, и вы не хотите оставаться необработанными данными в исходной таблице. Установите период обратимого удаления, равный 0, в [политике хранения](retentionpolicy.md)исходной таблицы и задайте для политики обновления значение "транзакционная". В этом случае: 

* Исходные данные не подпрашиваются из исходной таблицы. 
* Исходные данные не сохраняются в долговременном хранилище в ходе операции приема. 
* Производительность операционной системы повысится. 
* Ресурсы после приема для фоновых операций очистки будут сокращены. Эти операции выполняются с [экстентами](../management/extents-overview.md) в исходной таблице.

## <a name="performance-impact"></a>Влияние на производительность

Политики обновления могут влиять на производительность кластера Kusto. Политика обновления влияет на любые приемы в исходной таблице. Прием нескольких экстентов данных умножается на количество целевых таблиц. Поэтому важно, `Query` чтобы часть политики обновления была оптимизирована для работы. Можно протестировать дополнительное влияние политики обновления на операцию приема. Вызовите политику в конкретных и уже существующих экстентах, прежде чем создавать или изменять политику или функцию, которые она использует в своей `Query` части.

### <a name="evaluate-resource-usage"></a>Оценка использования ресурсов

Используйте [`.show queries`](../management/queries.md) , чтобы оценить использование ресурсов (ЦП, память и т. д.) в следующем сценарии:
* Имя исходной таблицы ( `Source` свойство политики обновления) имеет значение `MySourceTable` .
* `Query`Свойство политики обновления вызывает функцию с именем `MyFunction()` .

```kusto
.show table MySourceTable extents;
// The following line provides the extent ID for the not-yet-merged extent in the source table which has the most records
let extentId = $command_results | where MaxCreatedOn > ago(1hr) and MinCreatedOn == MaxCreatedOn | top 1 by RowCount desc | project ExtentId;
let MySourceTable = MySourceTable | where extent_id() == toscalar(extentId);
MyFunction()
```

## <a name="failures"></a>Сбои

По умолчанию сбой запуска политики обновления не влияет на прием данных в исходную таблицу. Однако если политика обновления определена как `IsTransactional` true, сбой запуска политики принудительно приводит к сбою приема данных в исходной таблице. В некоторых случаях прием данных в исходную таблицу завершается успешно, но во время приема в целевую таблицу произошел сбой политики обновления.

Ошибки, возникающие при обновлении политик, можно получить с помощью [ `.show ingestion failures` команды](../management/ingestionfailures.md).
 
```kusto
.show ingestion failures 
| where FailedOn > ago(1hr) and OriginatesFromUpdatePolicy == true
```

### <a name="treatment-of-failures"></a>Обработка сбоев

#### <a name="non-transactional-policy"></a>Нетранзакционная политика 

Ошибка игнорируется Kusto. Любая повторная попытка является обязанностью владельца процесса приема данных.  

#### <a name="transactional-policy"></a>Транзакционная политика

Исходная операция приема, вызвавшая обновление, также завершится ошибкой. Исходная таблица и база данных не будут изменены новыми данными.
Если метод приема равен `pull` (служба управление данными Kusto участвует в процессе приема), то существует автоматическая повторная попытка для всей операции приема, управляемой управление данными службой Kusto, в соответствии со следующей логикой:
* Повторные попытки выполняются до тех пор, пока не будет достигнуто самое раннее между `DataImporterMaximumRetryPeriod` (по умолчанию — 2 дня) и `DataImporterMaximumRetryAttempts` (значение по умолчанию — 10).
* Оба указанных выше параметра можно изменить в конфигурации службы Управление данными.
* Период отсрочки начинается с 2 минут и растет экспоненциально (2-> 4-> 8-> 16... тезис

В любом другом случае ответственность за повторные попытки несет владелец данных.