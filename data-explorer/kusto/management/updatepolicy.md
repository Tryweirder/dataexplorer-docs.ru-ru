---
title: Политика обновления - Azure Data Explorer Документы Майкрософт
description: В этой статье описывается политика обновления в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/19/2020
ms.openlocfilehash: 812a5af932f69d898bb419631fa6ea3c6bc0795e
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81519403"
---
# <a name="update-policy"></a>изменение политики;

Политика обновления устанавливается на **целевую таблицу,** которая поручает Kusto автоматически прижигать к нему данные всякий раз, когда новые данные вставляются в **исходную таблицу.** **Запрос политики** обновления выполняется на данных, вставленных в исходную таблицу. Это позволяет, например, создать одну таблицу в виде отфильтрованного представления другой таблицы, возможно, с другой схемой, политикой удержания и так далее.

По умолчанию сбой в выполнении политики обновления не влияет на проглатывание данных в исходную таблицу. Если политика обновления определяется как **транзакционная,** отказ от выполнения политики обновления вынуждает также заглаждать данные в исходную таблицу. (Уход должен использоваться, когда это делается, поскольку некоторые пользовательские ошибки, такие как определение неправильного запроса в политике обновления, могут предотвратить попадание **любых** данных в исходную таблицу.) Данные, понижаемые в "границе" политик и обновления транзакций, становятся доступными для запроса в одной транзакции.

Запрос политики обновления работает в специальном режиме, в котором он «видит» только вновь понижаемые данные в исходную таблицу. В рамках этого запроса невозможно задать запрос на уже полученные данные исходной таблицы. Это быстро приводит к квадратно-времени глотания.

Поскольку политика обновления определяется в таблице назначения, втисвание данных в одну таблицу исходного кода может привести к запуску нескольких запросов на этих данных. Порядок выполнения политик обновления не определен.

Например, предположим, что таблица исходного кода представляет собой высокоскоростную таблицу трассировки с интересными данными, отформатированными как столбец свободного текста. Также предположим, что целевая таблица (на которой определена политика обновления) принимает только конкретные [линии](../query/parseoperator.md)трассировки, а с хорошо структурированной схемой, которая представляет собой преобразование исходных данных свободного текста с помощью оператора анализа Kusto.

Политика обновления ведет себя аналогично регулярному проглатыванию и подчиняется тем же ограничениям и передовой практике. Например, он масштабируется с размером кластера и работает более эффективно, если глотания выполняются крупными объемами.

## <a name="commands-that-trigger-the-update-policy"></a>Команды, запускающие политику обновления

Политики обновления вспридаются при поглосании или перемещении данных в таблицу (в ней создаются размеры) с использованием любой из следующих команд:

* [.ingest (тянуть)](../management/data-ingestion/ingest-from-storage.md)
* [.ingest (вливый)](../management/data-ingestion/ingest-inline.md)
* [.set .append .set-or-append .set-or-replace](../management/data-ingestion/ingest-from-query.md)
* [.move степени](../management/extents-commands.md#move-extents)
* [.replace объемы](../management/extents-commands.md#replace-extents)

## <a name="the-update-policy-object"></a>Объект политики обновления

Таблица может иметь ноль, один или несколько объектов политики обновления, связанные с ней.
Каждый такой объект представлен как пакет свойств JSON, со следующими свойствами, определенными:

|Свойство |Тип |Описание  |
|---------|---------|----------------|
|IsEnabled                     |`bool`  |Государства, если политика обновления включена (истинная) или отключена (ложная)                                                                                                                               |
|Источник                        |`string`|Название таблицы, вызываемой политикой обновления для вызова                                                                                                                                 |
|Запрос                         |`string`|Запрос Kusto CSL, используемый для получения данных для обновления                                                                                                                           |
|Испрослик               |`bool`  |Государства, если политика обновления транзакционная или нет (по умолчанию ложным). Неспособность выполнить политику обновления транзакций приводит к тому, что исходная таблица также не будет обновлена новыми данными.   |
|ПропагандаIngestionСвойства  |`bool`  |Государства, если свойства приема (теги размера и время создания), указанные во время приема в исходную таблицу, также должны применяться к свойствам в таблице, полученной.                 |

> [!NOTE]
>
> * Таблица исходных источников и таблица, для которой определена политика обновления, **должны находиться в одной и той же базе данных.**
> * Запрос **не** может включать в себя кросс-базы данных или кросс-кластерные запросы.
> * Запрос может вызывать сохраненные функции.
> * Запрос автоматически охватывает только вновь познаваемые записи.
> * Каскадные обновления разрешены (TableA`[update]`--> TableB`[update]`---> TableC --`[update]`--> ...)
> * В случае, если политики обновления определяются по нескольким таблицам в круговой основе, это обнаруживается во время выполнения и цепочка обновлений сокращается (имеется в виду, данные будут потитраться только один раз в каждую таблицу в цепочке затронутых таблиц).
> * При упоминании `Source` таблицы `Query` в части политики (или в функциях, на которые ссылается последняя), убедитесь, что `TableName` вы **не** используете квалифицированное название таблицы (имеется в виду, использовать и **не** `database("DatabaseName").TableName` использовать). `cluster("ClusterName").database("DatabaseName").TableName`
> * Запрос политики обновления не может ссылаться на таблицу с [включенной политикой безопасности уровня строки.](./rowlevelsecuritypolicy.md)
> * Запрос, запущенный как часть политики обновления, **не** имеет доступа к таблицам с [включенной политикой RestrictedViewAccess.](restrictedviewaccesspolicy.md)
> * `PropagateIngestionProperties`вступает в силу только при операциях по проглатывания. Когда политика обновления срабатывает `.move extents` как `.replace extents` часть команды или команды, эта опция не имеет **эффекта.**
> * При вызове политики обновления как `.set-or-replace` части команды поведение по умолчанию заключается в том, что данные в таблице находного (ы) также заменяются, так как они есть в исходной таблице.

## <a name="retention-policy-on-the-source-table"></a>Политика удержания в таблице исходных источников

Чтобы не сохранять исходные данные в исходной таблице, можно установить период мягкого удаления 0 в [политике удержания](retentionpolicy.md)исходной таблицы, устанавливая политику обновления как транзакционную.

Это приведет к:
* Исходные данные не доступен для запроса из исходной таблицы.
* Исходные данные не сохраняются для прочного хранения в рамках операции по проглатывания.
* Улучшение производительности операции.
* Сокращение ресурсов, используемых после приема, для фоновых операций по уходу, выполненных по [объемам](../management/extents-overview.md) в исходной таблице.

## <a name="failures"></a>Сбои

В некоторых случаях, ввоз данных в исходную таблицу удается, но политика обновления не удается во время приема в целевую таблицу.

Сбои, возникающие во время обновления политик, могут быть извлечены с помощью [команды сбоев проглатывания .show:](../management/ingestionfailures.md)
 
```kusto
.show ingestion failures 
| where FailedOn > ago(1hr) and OriginatesFromUpdatePolicy == true
```

Неудачи рассматриваются следующим образом:

* **Нетранзакционная политика**: Сбой игнорируется Kusto. Любая повторная попытка является ответственностью владельца данных.  
* **Транзакционная политика**: Исходная операция приема, которая вызвала обновление, также выйдет из строя. Таблица исходных источников и база данных не будут изменены новыми данными.
  * В случае, если метод `pull` приема (служба управления данными Kusto участвует в процессе приема), есть автоматизированная повторная попытка на всю операцию приема, организованная службой управления данными Kusto, в соответствии со следующей логикой:
    * Повторные работы выполняются `DataImporterMaximumRetryPeriod` до достижения самого раннего (по умолчанию - 2 дня) и `DataImporterMaximumRetryAttempts` (по умолчанию - 10).
    * Оба приведенных выше настройки могут быть изменены в конфигурации службы управления данными, KustoOps.
    * Период отсылки начинается с 2 минут, и растет в геометрической прогрессии (2 -> 4 -> 8 -> 16 ... минуты)
  * В любом другом случае любая повторная попытка является обязанностью владельца данных.



## <a name="control-commands"></a>Команды управления

* Используйте [обновление политики таблицы TABLE .show,](../management/update-policy.md#show-update-policy) чтобы показать текущую политику обновления таблицы.
* Используйте [обновление политики table TABLE .alter](../management/update-policy.md#alter-update-policy) для настройки текущей политики обновления таблицы.
* Используйте [обновление таблицы TABLE .alter-merge,](../management/update-policy.md#alter-merge-table-table-policy-update) чтобы придатиться к текущей политике обновления таблицы.
* Используйте [обновление политики таблицы TABLE .delete,](../management/update-policy.md#delete-table-table-policy-update) чтобы придатиться к текущей политике обновления таблицы.

## <a name="testing-an-update-policys-performance-impact"></a>Тестирование влияния политики обновления на производительность

Определение политики обновления может повлиять на производительность кластера Kusto, поскольку оно влияет на любое проглатывание в исходную таблицу. Настоятельно рекомендуется оптимизировать `Query` часть политики обновления, чтобы хорошо работать.
Вы можете проверить дополнительное влияние политики обновления на операцию приема, ссылаясь на ее конкретные и уже существующие масштабы, прежде `Query` чем создавать или изменять политику и/или функцию, которую она использует в своей части.

В нем предполагается следующее:

* Имя исходной таблицы `Source` (свойство политики обновления) — `MySourceTable`это .
* Свойство `Query` политики обновления вызывает `MyFunction()`функцию под названием .

Используя [запросы .show,](../management/queries.md)вы можете оценить использование ресурсов (CPU, память и т.д.) следующего запроса и/или нескольких его выполнения.

```kusto
.show table MySourceTable extents;
// The following line provides the extent ID for the not-yet-merged extent in the source table which has the most records
let extentId = $command_results | where MaxCreatedOn > ago(1hr) and MinCreatedOn == MaxCreatedOn | top 1 by RowCount desc | project ExtentId;
let MySourceTable = MySourceTable | where extent_id() == toscalar(extentId);
MyFunction()
```