---
title: Экстенты (сегменты данных) — Azure обозреватель данных | Документация Майкрософт
description: В этой статье описываются экстенты (сегменты данных) в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 35ba47fde9c1bdd5adf0f57ed40d028f4dc520c2
ms.sourcegitcommit: 39b04c97e9ff43052cdeb7be7422072d2b21725e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/12/2020
ms.locfileid: "83227763"
---
# <a name="extents-data-shards"></a>Экстенты (сегменты данных)

## <a name="overview"></a>Обзор

Kusto построен для поддержки таблиц с большим количеством записей (строк) и большого количества данных. Чтобы иметь возможность обрабатывать такие большие таблицы, Kusto делит данные каждой таблицы на небольшие "планшеты", называемые **сегментами данных** или **экстентами** (эти два термина являются синонимами), так что объединение всех экстентов таблицы содержит данные таблицы. Отдельные экстенты сохраняются меньше, чем емкость одного узла, а экстенты распределяются по узлам кластера, что достигается за счет горизонтального масштабирования. 

Один из них может представлять экстент как разновидность мини-таблицы. Экстент содержит метаданные (указывающие схему данных в экстенте и дополнительные сведения, такие как время создания и необязательные теги, связанные с данными в экстенте) и данные. Кроме того, экстент обычно содержит сведения, позволяющие Kusto эффективно запрашивать данные, например индекс для каждого столбца данных в экстенте, и словарь кодирования, если данные столбца кодируются. Таким результатом, данные таблицы представляют собой объединение всех данных в экстентах таблицы.

Экстенты являются *неизменяемыми*. После создания экстент никогда не изменяется, и экстент может запрашиваться, переназначаться другому узлу или удаляться из таблицы. Изменение данных происходит путем создания одного или нескольких новых экстентов и транзакционной замены старых экстентов новыми экстентами.

Экстенты хранят коллекцию записей, физически упорядоченных по столбцам.
Этот метод ( **хранилище столбцов**) позволяет эффективно кодировать и сжимать данные (поскольку разные значения из одного столбца часто «похожи») и делают запросы для больших диапазонов данных более эффективными, так как только столбцы, используемые запросом, должны быть загружены. На внутреннем уровне каждый столбец данных в экстенте делится на сегменты, а сегменты — на блоки. Это деление (которое недоступно для наблюдения за запросами) позволяет Kusto оптимизировать сжатие и индексирование столбцов.

Чтобы обеспечить эффективность запросов, небольшие экстенты объединяются в большие экстенты.
Это выполняется автоматически Kusto в качестве фонового процесса в соответствии с настроенной [политикой слияния](mergepolicy.md) и [политикой сегментирования](shardingpolicy.md).
Слияние экстентов сокращает затраты на управление, связанные с наличием большого количества экстентов, которые следует отслеживанию, но, что более важно, позволяет Kusto оптимизировать свои индексы и улучшить сжатие. Слияние экстентов прекращается, когда экстент достигает определенных ограничений, таких как размер, за исключением некоторых экстентов слияния точек, а не повышает эффективность.

Если в таблице определена [Политика секционирования данных](partitioningpolicy.md) , то экстенты проходят через другой фоновый процесс после их создания (после приема). Этот процесс повторно принимает данные из исходных экстентов и создает *однородные* экстенты, в которых значения столбца, который является *ключом секции* таблицы, принадлежат к одной секции. Если политика включает *ключ хэш-секции*, гарантируется, что все однородные экстенты, принадлежащие к одной и той же секции, будут назначены одному и тому же узлу данных в кластере.

> [!NOTE]
> Операции уровня экстента, такие как объединение, изменение тегов экстента и т. д., не изменяют существующие экстенты.
> Вместо этого в этих операциях создаются новые экстенты, основанные на существующих исходных экстентах, а затем эти новые экстенты заменяют свои форефасерс в одной транзакции.

Таким образом, "жизненный цикл" экстента:

1. Экстент создается операцией **приема** .
2. Экстент объединяется с другими экстентами. Если объединяемые экстенты небольшие, Kusto на самом деле выполняет на них процесс приема (это называется **перестроением**). Когда экстенты достигнут определенного размера, слияние выполняется только для индексов, а артефакты данных экстентов в хранилище не изменяются.
3. Объединенный экстент (возможно, который отслеживает журнал преобразований в другие Объединенные экстенты и т. д.) в конечном итоге отбрасывается из-за политики хранения. Когда экстенты отбрасываются в зависимости от времени (более старые x часов/дней), в вычисление передается Дата создания нового экстента внутри Объединенного.

## <a name="extent-creation-time"></a>Время создания экстента

Одним из наиболее важных сведений для каждого экстента является время его создания. Это время используется Kusto для:

1. Хранение (ранее созданные экстенты будут удалены ранее).
2. Кэширование (недавно созданные экстенты будут храниться в [оперативном кэше](cachepolicy.md)).
3. Выборка (при использовании операций запроса, таких как `take` , предпочтительно использовать последние экстенты).

Фактически Kusto отслеживает два `datetime` значения на экстент: `MinCreatedOn` и `MaxCreatedOn` .
Эти значения начинаются одинаково, но при слиянии экстента с другими экстентами результирующие значения экстента являются минимальным и максимальным значением, соответственно, значениями для всех Объединенных экстентов.

Обычно время создания экстента устанавливается в соответствии с временем приема данных в экстенте. Клиенты могут дополнительно переопределить время создания экстента, предоставляя альтернативное время создания в [свойствах приема](../../ingestion-properties.md) (это полезно, например, если клиент хочет повторно принять данные и не хочет, чтобы повторно принимаемые данные отображались как будто они приступили к опозданию, например в целях хранения).    

## <a name="extent-tagging"></a>Добавление тегов к экстентам

Как часть метаданных, хранящихся в экстенте, Kusto поддерживает присоединение нескольких необязательных *тегов экстентов* к экстенту. Тег экстента (или просто *тег*) — это строка, связанная с экстентом. Можно использовать команды [. Показать экстенты](extents-commands.md#show-extents) , чтобы просмотреть теги, связанные с экстентом, и функцию [экстента ()](../query/extenttagsfunction.md) , чтобы просмотреть теги, связанные с записями в экстенте.
Теги экстента можно использовать для эффективного описания свойств, относящихся ко всем данным в экстенте.
Например, можно добавить тег экстента во время приема, указывающий источник принимаемых данных, и позднее использовать этот тег. Так как они описывают данные, при слиянии двух или более экстентов их связанные теги также объединяются путем того, что теги результирующего экстента являются объединением всех тегов экстентов объединяемых экстентов.

Kusto назначает особое значение всем тегам экстентов, значение которых имеет *суффикс* *префикса* формата, где *префикс* является одним из следующих:

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>Теги экстента "Drop-By:"

Теги, начинающиеся с **`drop-by:`** префикса, можно использовать для управления тем, к каким другим экстентам следует выполнять слияние; экстенты с заданным `drop-by:` тегом можно объединить вместе, но они не будут объединены с другими экстентами. Это позволяет пользователю выдать команду для удаления экстентов в соответствии с их `drop-by:` тегом, например следующей командой:

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>Заметки о производительности

* Не рекомендуется использовать теги чрезмерного использования `drop-by` . Поддержка удаления данных указанным выше образом предназначена для редко встречающихся событий, не для замены данных на уровне записи, а также для критически важности того, что данные, помеченные таким способом, имеют вид «небольшого объема». Попытка предоставить другой тег для каждой записи или небольшое число записей может привести к серьезному снижению производительности.
* В случаях, когда такие теги не требуются в течение некоторого периода времени после приема данных, рекомендуется [удалить теги](extents-commands.md#drop-extent-tags).

### <a name="ingest-by-extent-tags"></a>Теги экстентов приема:

Теги, начинающиеся с **`ingest-by:`** префикса, можно использовать для того, чтобы данные принимались только один раз. Пользователь может выдать команду приема, которая не позволяет принимать данные, если уже существует экстент с этим конкретным `ingest-by:` тегом с помощью **`ingestIfNotExists`** Свойства.
Значения для `tags` и `ingestIfNotExists` являются массивами строк, сериализованных как JSON.

В следующем примере данные принимаются только один раз (команды 2 и 3 не выполняют никаких действий):

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> В общем случае команда приема может включать как тег, так `ingest-by:` и `ingestIfNotExists` свойство, устанавливая одно и то же значение (как показано в третьей команде выше).

#### <a name="performance-notes"></a>Заметки о производительности

- Использование `ingest-by` тегов не рекомендуется.
Если известно, что конвейер, подающий Kusto, имеет дубликаты данных, рекомендуется максимально устранить их до приема данных в Kusto и использовать `ingest-by` теги в Kusto только в тех случаях, когда часть, принимающая данные в Kusto, может содержать дубликаты сами по себе (например, механизм повтора, который может пересекаться с уже выполняемыми вызовами приема). Попытка задать уникальный `ingest-by` тег для каждого вызова приема может привести к серьезному снижению производительности.
- В случаях, когда такие теги не требуются в течение некоторого периода времени после приема данных, рекомендуется [удалить теги](extents-commands.md#drop-extent-tags).
