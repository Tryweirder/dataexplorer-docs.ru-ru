---
title: Масштабы (осколки данных) - Azure Data Explorer Документы Майкрософт
description: В этой статье описаны масштабы (осколки данных) в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 16afb2dc7d2310e9e63ec3465937ac84c96b27e4
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81521018"
---
# <a name="extents-data-shards"></a>Размеры (осколки данных)

## <a name="overview"></a>Обзор

Kusto создан для поддержки таблиц с огромным количеством записей (строки) и большим количеством данных. Чтобы иметь возможность обрабатывать такие большие таблицы, Kusto делит данные каждой таблицы на более мелкие "таблетки", называемые **осколками или** **сведениями** данных (два термина являются синонимами), таким образом, что объединение всех уровней таблицы удерживает данные таблицы. Индивидуальные степени затем хранятся меньше, чем емкость одного узла, и степени распределены по узлам кластера, достигая масштабирования. 

Можно думать о степени, как своего рода мини-стол. Степень содержит метаданные (с указанием схемы данных в объеме и дополнительной информации, такой как время их создания и дополнительные теги, связанные с данными в объеме) и данные. Кроме того, в объеме обычно содержится информация, позволяющая Kusto эффективно заготавливать данные, например индекс для каждого столбца данных в определенности и словарь кодирования, если данные столбца закодированы. Таким образом, данные таблицы — это объединение всех данных в объемах таблицы.

Размеры *неизменяемы.* После создания степень никогда не изменяется, и степень может быть запрошена только в другом узлах или исключена из таблицы. Изменение данных происходит путем создания одной или нескольких новых объемов и транзакционного обмена старых масштабов (ы) с новой степенью (ы).

В размерах имеется коллекция записей, физически расположенных в столбцах.
Этот метод (называемый **columnar store)** позволяет эффективно кодировать и сжимать данные (потому что различные значения из одного и того же столбца часто "напоминают" друг друга) и делает запрос на большие промежутки данных более эффективным, поскольку только столбцы, используемые запросом, должны быть загружены. Внутри каждого столбца данных в объеме подразделяется на сегменты, а сегменты на блоки. Это разделение (которое не обслуживается для запросов) позволяет Kusto оптимизировать сжатие столбцов и индексацию.

Для поддержания эффективности запросов меньшие объемы объединяются в более широкие масштабы.
Это выполняется автоматически Kusto, как фоновый процесс, в соответствии с настроенной [политикой слияния](mergepolicy.md) и [политики осколков.](shardingpolicy.md)
Слияние масштабов вместе уменьшает накладные расходы управления, имеющие большое количество степени для отслеживания, но что более важно, это позволяет Kusto оптимизировать свои индексы и улучшить сжатие. Значительное слияние останавливается, как только степень достигает определенных пределов, таких как размер, так как за пределами определенной точки слияния масштабы уменьшает, а не повышает эффективность.

При [определении политики раздела данных](partitioningpolicy.md) на столе объемы проходят через другой фоновый процесс после их создания (после приема). Этот процесс повторно глотает данные из объема источника и создает *однородные* степени, в которых значения столбца, являющейся *ключом раздела* таблицы, принадлежат к одному и тому же разделу. Если политика включает *ключ раздела хэша,* гарантируется, что все однородные степени, принадлежащие к одному и тому же разделу, назначаются одному и тому же узлом данных в кластере.

> [!NOTE]
> Операции уровня размера, такие как слияние, изменение тегов степени и т.д., не изменяют существующие размеры.
> Скорее, в этих операциях создаются новые степени, основанные на существующих объемах источников, а затем эти новые степени заменяют их предков в одной транзакции.

Таким образом, общим "жизненным циклом" такого масштаба является:

1. Степень создается операцией **по проглатыванию.**
2. Степень сливается с другими масштабами. Когда объемы сливаются малы, Kusto фактически выполняет процесс приема на них (это называется **восстановление).** Как только размеры достигают определенного размера, слияние осуществляется только для индексов, а артефакты данных в хранилище не изменяются.
3. Слияние (возможно, тот, который отслеживает его линию в другие объединенные степени и так далее) в конечном итоге снижается из-за политики удержания. Когда степени сброшены на основе времени (старые часы x/days) дата создания новейшей степени внутри объединенного учитывается.

## <a name="extent-ingestion-time"></a>Значительное время приема

Одним из наиболее важных частей информации для каждого размера является время приема. Это время используется Кусто для:

1. Удержание (объемы, которые были проглочены ранее, будут удалены ранее).
2. Кэширование (объемы, которые были попадает в последнее время будет жарче).
3. Выборка (при использовании `take`операций запроса, таких как, последние степени являются благоприятствования).

В самом деле, Кусто отслеживает `datetime` два `MinCreatedOn` `MaxCreatedOn`значения в размахе: и .
Эти значения начинаются одинаково, но когда степень сливается с другими масштабами, значения полученной степени являются минимальными и максимальными, соответственно, значениями по всем объединенным размерам.

Время приема может быть установлено одним из трех способов:

1. Обычно узла, выполняющего проглатывание, устанавливает это значение в соответствии с его локальными часами.
2. Если на столе установлена **политика времени приема,** узла, выполняющего проглатку, устанавливает это значение в соответствии с локальными часами локального узла админного узла кластера, гарантируя, что все последующие проглатывания будут иметь более высокое значение времени приема.
3. Клиент может установить это время. (Это полезно, например, если клиент хочет повторно проемить данные и не хочет, чтобы повторно прогнанные данные выглядели так, как будто они поступили с опозданием, например для целей удержания).    

## <a name="extent-tagging"></a>Помечание степени

Как часть метаданных, хранящихся с определенной степенью, Kusto поддерживает присоединение нескольких факультативных *тегов степени.* Тег степени (или просто *тег),* это строка, которая связана с степенью. Можно использовать команды [уровней .show,](extents-commands.md#show-extents) чтобы увидеть теги, связанные с уровнем, и функцию [«метки размера» ()](../query/extenttagsfunction.md) для просмотра тегов, связанных с записями в определенной степени.
Помечание метки можно использовать для эффективного описания свойств, относящихся ко всем данным в определенности.
Например, можно добавить тег степени во время приема, который указывает источник данных, посягающих на него, а затем использовать этот тег. По мере того как они описывают данные, когда 2 или больше размеров слиты их связанные теги также сливать путем иметь в результате теги размеров быть соединением всех меток размера слива.

Кусто присваивает особое значение во всех областях теги, значение которого имеет формат *префикс* *суффикс*, где *префикс* является одним из:

* `drop-by:`
* `ingest-by:`

## <a name="drop-by-extent-tags"></a>'капля-на:' степень теги

Теги, начинаюющиеся с **`drop-by:`** префикса, могут использоваться для контроля, с какими другими степени мислисироваться; степени, которые имеют `drop-by:` данный тег могут быть объединены вместе, но они не будут объединены с другими масштабами. Это позволяет пользователю выдавать команду для отсева в соответствии с их `drop-by:` тегом, например следующей командой:

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

### <a name="performance-notes"></a>Примечания к производительности

* Переиспользование `drop-by` тегов не рекомендуется. Поддержка отбрасывания данных в указанном выше виде предназначена для редко происходящих событий, не предназначена для замены данных уровня записи и критически зависит от того факта, что данные, отмечаемые таким образом, являются "объемными". Попытка дать другой тег для каждой записи или небольшое количество записей может привести к серьезному воздействию на производительность.
* В тех случаях, когда такие метки не требуются через какой-то период времени после поступления данных, рекомендуется [отказаться от тегов.](extents-commands.md#drop-extent-tags)

## <a name="ingest-by-extent-tags"></a>'ingest-by:' теги степени

Теги, начинающиеся с **`ingest-by:`** префикса, могут быть использованы для обеспечения поступления данных только один раз. Пользователь может выдать команду по глотанию, которая предотвращает поимку данных, `ingest-by:` если с **`ingestIfNotExists`** помощью этого конкретного тега уже есть степень с этим конкретным тегом.
Значения для `tags` обоих `ingestIfNotExists` и массивы строк, сериализованные как JSON.

Следующий пример глотает данные только один раз (2-я и 3-я команды ничего не сделают):

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> В обычном случае команда ingest, скорее `ingest-by:` всего, `ingestIfNotExists` будет включать как тег, так и свойство, установленное на то же значение (как показано в 3-й команде выше).

### <a name="performance-notes"></a>Примечания к производительности

- Чрезмерное `ingest-by` использование тегов не рекомендуется.
Если трубопровод кормления Кусто, как известно, данные дублирования, рекомендуется решить их как можно больше, прежде чем глотать `ingest-by` данные в Кусто, и использовать теги в Кусто только в тех случаях, когда часть, которая глотает в Кусто может ввести дубликаты сам по себе (например, есть механизм повтора, который может перекрываться с уже в процессе приема вызовов). Попытка установить уникальный `ingest-by` тег для каждого вызова приема может привести к серьезному воздействию на производительность.
- В тех случаях, когда такие метки не требуются через какой-то период времени после поступления данных, рекомендуется [отказаться от тегов.](extents-commands.md#drop-extent-tags)