---
title: Экстенты (сегменты данных) — Azure обозреватель данных
description: В этой статье описываются экстенты (сегменты данных) в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 6c7910a222227dbb6b22e1fc4f0f4136897a0ef9
ms.sourcegitcommit: be1bbd62040ef83c08e800215443ffee21cb4219
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/10/2020
ms.locfileid: "84665118"
---
# <a name="extents-data-shards"></a>Экстенты (сегменты данных)

## <a name="overview"></a>Обзор

Kusto построен для поддержки таблиц с большим количеством записей (строк) и большими объемами данных. Для работы с большими таблицами данные каждой таблицы делятся на небольшие "планшеты", называемые **сегментами данных** или **экстентами** (два термина являются синонимами). Объединение всех экстентов таблицы содержит данные таблицы. Отдельные экстенты хранятся меньше, чем емкость одного узла, а экстенты распределяются по узлам кластера, что обеспечивает горизонтальное масштабирование.

Экстент аналогичен типу мини-таблицы. Он содержит данные и метаданные, а также такие сведения, как время создания и необязательные теги, связанные с данными. Кроме того, экстент обычно содержит информацию, которая позволяет Kusto запрос данных эффективно.
Например, индекс для каждого столбца данных в экстенте и словарь кодирования, если данные столбца кодируются. В результате данные таблицы представляют собой объединение всех данных в экстентах таблицы.

Экстенты являются неизменяемыми и никогда не могут быть изменены. Его можно запрашивать, переназначить другому узлу или удалить из таблицы. Изменение данных происходит путем создания одного или нескольких новых экстентов и транзакционной замены старых экстентов новыми.

Экстенты хранят коллекцию записей, которые физически упорядочены по столбцам.
Этот метод называется **хранилищем столбцов**. Он обеспечивает эффективную кодировку и сжатие данных, поскольку разные значения из одного и того же столбца часто «похожи» друг на друга. Это также делает запрос к большим диапазонам данных более эффективным, поскольку необходимо загрузить только столбцы, используемые запросом. На внутреннем уровне каждый столбец данных в экстенте делится на сегменты, а сегменты — на блоки. Это деление не является наблюдаемым для запросов и позволяет Kusto оптимизировать сжатие столбцов и индексирование.

Чтобы обеспечить эффективность запросов, небольшие экстенты объединяются в большие экстенты.
Слияние выполняется автоматически в качестве фонового процесса в соответствии с настроенной [политикой слияния](mergepolicy.md) и [политикой сегментирования](shardingpolicy.md).
Объединение экстентов сокращает затраты на управление наличием большого количества экстентов. Что более важно, это позволяет Kusto оптимизировать свои индексы и улучшить сжатие.

Слияние экстентов останавливается, когда экстент достигает определенных ограничений, например размера, начиная с определенной точки, объединение сокращается, а не повышает эффективность.

Если в таблице определена [Политика секционирования данных](partitioningpolicy.md) , то экстенты проходят через другой фоновый процесс после их создания (после приема). Этот процесс повторно принимает данные из исходных экстентов и создает *однородные* экстенты, в которых значения столбца, который является *ключом секции* таблицы, принадлежат к одной секции. Если политика включает *ключ хэш-секции*, все однородные экстенты, принадлежащие к одному и тому же разделу, будут назначены одному и тому же узлу данных в кластере.

> [!NOTE]
> Операции уровня экстента, такие как объединение или изменение тегов экстентов, не изменяют существующие экстенты.
> Вместо этого в этих операциях создаются новые экстенты, основанные на существующих исходных экстентах. Новые экстенты заменяют свои форефасерс в одной транзакции.

Общий жизненный цикл экстентов:

1. Экстент создается операцией **приема** .
1. Экстент объединяется с другими экстентами. Если объединяемые экстенты небольшие, Kusto фактически выполняет процесс приема на них, именуемый **перестроением**. Когда экстенты достигнут определенного размера, слияние выполняется только для индексов. Артефакты данных экстентов в хранилище не изменяются.
1. Объединенный экстент (возможно, который отслеживает журнал преобразований в другие Объединенные экстенты и т. д.) в конечном итоге удаляется из-за политики хранения. 
   Когда экстенты отбрасываются, в зависимости от времени (более старые x часов/дней) в вычислении используется Дата создания нового экстента в объединенном виде.

## <a name="extent-creation-time"></a>Время создания экстента

Одним из наиболее важных сведений для каждого экстента является время его создания. Это время используется для:

1. Ранее созданные экстенты **хранения** будут удалены ранее.
1. **Кэширование** . созданные ранее экстенты будут храниться в [оперативном кэше](cachepolicy.md).
1. **Выборка** — последние экстенты предпочтительнее при использовании операций запросов, таких как`take`

Фактически Kusto отслеживает два `datetime` значения на экстент: `MinCreatedOn` и `MaxCreatedOn` .
Изначально два значения одинаковы. При объединении экстента с другими экстентами новые значения зависят от исходных минимальных и максимальных значений Объединенных экстентов.

Обычно время создания экстента устанавливается в соответствии с временем приема данных в экстенте. Клиенты могут дополнительно перезаписать время создания экстента, предоставляя альтернативное время создания в [свойствах приема](../../ingestion-properties.md).
Перезапись полезна, например, в целях хранения, если клиент хочет возиспользовать данные и не должен отображаться так, как если бы он был получен в конце.

## <a name="extent-tagging"></a>Добавление тегов к экстентам

Kusto поддерживает присоединение нескольких необязательных *тегов экстента* к экстенту в составе метаданных. Тег экстента (или просто *тег*) — это строка, связанная с экстентом. Можно использовать команды [. Показать экстенты](extents-commands.md#show-extents) , чтобы просмотреть теги, связанные с экстентом, и функцию [экстента ()](../query/extenttagsfunction.md) , чтобы просмотреть теги, связанные с записями в экстенте.
Теги экстентов можно использовать для эффективного описания свойств, общих для всех данных в экстенте.
Например, можно добавить тег экстента во время приема, который указывает источник принимаемых данных, и использовать этот тег позже. Так как экстенты описывают данные при двух или более слияниях, связанные с ними Теги также объединяются. В результате Теги экстента будут объединять все теги этих Объединенных экстентов.

Kusto назначает особое значение всем тегам экстентов, значение которых имеет *суффикс* *префикса* формата, где *префикс* является одним из следующих:

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>Теги экстента "Drop-By:"

Теги, начинающиеся с `drop-by:` префикса, можно использовать для управления тем, с какими другими экстентами следует выполнить слияние. Экстенты, имеющие заданный `drop-by:` тег, можно объединить вместе, но они не будут объединяться с другими экстентами. Затем можно выдать команду, чтобы удалить экстенты в соответствии с их `drop-by:` тегами.

Пример.

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>Заметки о производительности

* Не изменяйте `drop-by` теги. Удаление данных описанным выше способом предназначено для редко встречающихся событий. Он не предназначен для замены данных на уровне записи и основан на том, что данные, помеченные таким способом, являются небольшого объема. Попытка предоставить другой тег для каждой записи или небольшое число записей может привести к серьезному снижению производительности.
* Если `drop-by` теги не нужны в течение определенного периода времени после приема данных, рекомендуется [удалить теги](extents-commands.md#drop-extent-tags).

### <a name="ingest-by-extent-tags"></a>Теги экстентов приема:

Теги, начинающиеся с `ingest-by:` префикса, можно использовать для того, чтобы данные принимались только один раз. Можно выдать **`ingestIfNotExists`** команду Свойства, которая не позволяет принимать данные, если уже существует экстент с этим конкретным `ingest-by:` тегом.
Значения для `tags` и `ingestIfNotExists` являются массивами строк, сериализованных как JSON.

В следующем примере данные принимаются только один раз. Вторая и третья команды не выполняют никаких действий:

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> Как правило, команда приема может включать как тег, так `ingest-by:` и `ingestIfNotExists` свойство, устанавливая одно и то же значение, как показано в третьей команде выше.

#### <a name="performance-notes"></a>Заметки о производительности

* Использование `ingest-by` тегов не рекомендуется.
Если известно, что конвейер, подающий Kusto, имеет дубликаты данных, рекомендуется разрешить эти дубликаты как можно больше, прежде чем приступать к передаче данных в Kusto. Кроме того, используйте `ingest-by` теги в Kusto только в том случае, когда часть, принимающая в Kusto, может вводить дубликаты сами по себе (например, существует механизм повтора, который может пересекаться с уже выполняемыми вызовами приема). Попытка задать уникальный `ingest-by` тег для каждого вызова приема может привести к серьезному снижению производительности.
* Если такие теги не требуются в течение некоторого периода времени после приема данных, рекомендуется [удалить эти теги](extents-commands.md#drop-extent-tags).
 
