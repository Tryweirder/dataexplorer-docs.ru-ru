---
title: Политика секционирования данных — Azure обозреватель данных
description: В этой статье описывается политика секционирования данных в обозреватель данных Azure, а также его использование для повышения производительности запросов.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 06/10/2020
ms.openlocfilehash: 1d2960e4fa8274d9e39aba935a49fd8d14d166e9
ms.sourcegitcommit: a7458819e42815a0376182c610aba48519501d92
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/28/2020
ms.locfileid: "92902662"
---
# <a name="partitioning-policy"></a>Политика секционирования

Политика секционирования определяет, как и как [экстенты (сегменты данных)](../management/extents-overview.md) должны быть секционированы для конкретной таблицы.

Основной целью политики является повышение производительности запросов, которые позволяют уменьшить набор данных. Например, запросы, фильтрующиеся по секционированным столбцам, используют статистическое выражение или соединение в столбце строки с большим количеством элементов. Кроме того, политика может привести к более эффективному сжатию данных.

> [!CAUTION]
> Жестко запрограммированные ограничения на количество таблиц с определенной политикой секционирования не заданы. Однако каждая дополнительная таблица добавляет издержки на фоновый процесс секционирования данных, который выполняется на узлах кластера. Добавление таблиц может привести к тому, что будут использоваться больше ресурсов кластера. Дополнительные сведения см. в разделе [мониторинг](#monitor-partitioning) и [емкость](#partition-capacity).

## <a name="partition-keys"></a>Ключи секции

Поддерживаются следующие виды ключей секций.

|Kind                                                   |Тип столбца |Свойства раздела                    |Значение секции                                        |
|-------------------------------------------------------|------------|----------------------------------------|----------------------|
|[Хэш](#hash-partition-key)                            |`string`    |`Function`, `MaxPartitionCount`, `Seed` | `Function`(`ColumnName`, `MaxPartitionCount`, `Seed`) |
|[Однородный диапазон](#uniform-range-datetime-partition-key) |`datetime`  |`RangeSize`, `Reference`                | `bin_at`(`ColumnName`, `RangeSize`, `Reference`)      |

### <a name="hash-partition-key"></a>Ключ хэш-секции

> [!NOTE]
> Применить ключ хэш-секции к `string` столбцу типа в таблице только в следующих экземплярах:
> * Если в большинстве запросов используются фильтры равенства ( `==` , `in()` ).
> * Большинство запросов объединены или объединены по `string` столбцу с определенным типом *больших измерений* (кратность 10 миллионов или выше), например, `application_ID` `tenant_ID` или `user_ID` .

* Для секционирования данных используется функция хэширования по модулю.
* Данные в однородных (секционированных) экстентах упорядочиваются по ключу хэш-секции.
  * Не нужно включать ключ хэш-секции в [политику порядка строк](roworderpolicy.md), если он определен для таблицы.
* Запросы, использующие [стратегию случайного](../query/shufflequery.md)переключения, в которой `shuffle key` используется в `join` `summarize` или `make-series` является ключом хэш-секции таблицы, должны выполняться лучше, так как объем данных, необходимых для перемещения между узлами кластера, уменьшается.

#### <a name="partition-properties"></a>Свойства раздела

|Свойство | Описание | Поддерживаемые значения| Рекомендуемое значение |
|---|---|---|---|
| `Function` | Имя функции хэш-кода для использования.| `XxHash64` | |
| `MaxPartitionCount` | Максимальное число создаваемых секций (аргумент остатка для функции hash-остатка) за период времени. | В диапазоне `(1,2048]` . <br>  Больше чем в пять раз больше, чем количество узлов в кластере, и меньше, чем количество элементов в столбце. |  Более высокие значения приводят к увеличению затрат на процесс секционирования данных на узлах кластера и большее количество экстентов для каждого периода времени. Для кластеров с менее чем 50 узлами Начните с `256` . Измените значение на основе этих соображений или в зависимости от преимуществ производительности запросов и издержек, касающихся секционирования данных после приема.
| `Seed` | Используется для случайного значения хэша. | Положительное целое число. | `1`, который также является значением по умолчанию. |
| `PartitionAssignmentMode` | Режим, используемый для назначения секций узлам в кластере. | `Default`: Все однородные (секционированные) экстенты, принадлежащие к одной секции, назначаются одному и тому же узлу. <br> `Uniform`: Значения раздела экстентов не учитываются. Экстенты равномерно назначаются узлам кластера. | Если запросы не объединяются или не выполняют статистическую обработку в ключе хэш-секции, используйте `Uniform` . В противном случае используйте коллекцию `Default`. |

#### <a name="hash-partition-key-example"></a>Пример ключа хэш-секции

Ключ хэш-секции для `string` столбца с именем `tenant_id` .
Он использует `XxHash64` хэш-функцию с параметром `MaxPartitionCount` `256` , а значение по умолчанию — `Seed` `1` .

```json
{
  "ColumnName": "tenant_id",
  "Kind": "Hash",
  "Properties": {
    "Function": "XxHash64",
    "MaxPartitionCount": 256,
    "Seed": 1,
    "PartitionAssignmentMode": "Default"
  }
}
```

### <a name="uniform-range-datetime-partition-key"></a>Ключ секции DateTime с равномерным диапазоном

> [!NOTE] 
> Применение ключа секции даты и времени с равномерным диапазоном к `datetime` типизированному столбцу в таблице, если данные, полученные в таблице, вряд ли упорядочиваются в соответствии с этим столбцом.

В таких случаях можно переключать данные между экстентами, чтобы каждый экстент включал записи из ограниченного диапазона времени. Этот процесс приводит к `datetime` более эффективному применению фильтров к столбцу во время запроса.

Используемая функция секционирования — [bin_at ()](../query/binatfunction.md) и не может быть настраиваемой.

#### <a name="partition-properties"></a>Свойства раздела

|Свойство | Описание | Рекомендуемое значение |
|---|---|---|---|
| `RangeSize` | `timespan`Скалярная константа, указывающая размер каждой секции DateTime. | Начните со значения `1.00:00:00` (один день). Не задавайте более короткое значение, так как это может привести к тому, что таблица будет иметь большое количество небольших экстентов, которые невозможно объединить.
| `Reference` | `datetime`Скалярная константа, указывающая фиксированный момент времени, в соответствии с которой размещаются секции даты и времени. | Начните с метода `1970-01-01 00:00:00`. Если имеются записи, в которых ключ секции даты имеет `null` значения, то для их значения секции задается значение `Reference` . |

#### <a name="uniform-range-datetime-partition-example"></a>Пример универсального диапазона DateTime Partition

Фрагмент кода показывает универсальный ключ секции с диапазоном DateTime для `datetime` типизированного столбца с именем `timestamp` .
Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "ColumnName": "timestamp",
  "Kind": "UniformRange",
  "Properties": {
    "Reference": "1970-01-01T00:00:00",
    "RangeSize": "1.00:00:00"
  }
}
```

## <a name="the-policy-object"></a>Объект политики

По умолчанию политика секционирования данных в таблице имеет значение `null` , в этом случае данные в таблице не будут секционированы.

Политика секционирования данных имеет следующие основные свойства.

* **Партитионкэйс** :
  * Коллекция [ключей разделов](#partition-keys) , определяющих способ секционирования данных в таблице.
  * Таблица может содержать `2` ключи до секций с одним из следующих вариантов:
    * Один [ключ хэш-секции](#hash-partition-key).
    * Один [универсальный ключ секции даты и времени](#uniform-range-datetime-partition-key).
    * Один ключ [хэш-секции](#hash-partition-key) и один [ключ секции DateTime с одинаковым диапазоном](#uniform-range-datetime-partition-key).
  * Каждый ключ секции имеет следующие свойства.
    * `ColumnName`: `string ` — Имя столбца, в соответствии с которым будут секционированы данные.
    * `Kind`: `string` — Тип секционирования данных для применения ( `Hash` или `UniformRange` ).
    * `Properties`: `property bag` — Определяет параметры, в соответствии с которыми выполняется секционирование.

* **Еффективедатетиме** :
  * Дата и время (в формате UTC), с которых действует политика.
  * Это свойство необязательно. Если он не указан, политика вступит в силу на данных, полученных после применения политики.
  * Все однородные (несекционированные) экстенты, которые могут быть удалены из-за удержания, игнорируются процессом секционирования. Экстенты игнорируются, так как время их создания предшествует 90% от периода бездействия обратимого удаления таблицы.
    > [!NOTE]
    > Можно задать значение DateTime в прошлом и секционировать уже полученные данные. Однако такой подход может значительно увеличить ресурсы, используемые в процессе секционирования. 

### <a name="data-partitioning-example"></a>Пример секционирования данных

Объект политики секционирования данных с двумя ключами секции.
1. Ключ хэш-секции для `string` столбца с именем `tenant_id` .
    * Он использует `XxHash64` хэш-функцию с значением `MaxPartitionCount` 256 и значением по умолчанию `Seed` `1` .
1. Ключ секции одинакового диапазона дат и времени для `datetime` столбца типа с именем `timestamp` .
    * Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "PartitionKeys": [
    {
      "ColumnName": "tenant_id",
      "Kind": "Hash",
      "Properties": {
        "Function": "XxHash64",
        "MaxPartitionCount": 256,
        "Seed": 1,
        "PartitionAssignmentMode": "Default"
      }
    },
    {
      "ColumnName": "timestamp",
      "Kind": "UniformRange",
      "Properties": {
        "Reference": "1970-01-01T00:00:00",
        "RangeSize": "1.00:00:00"
      }
    }
  ]
}
```

## <a name="additional-properties"></a>Дополнительные свойства

Следующие свойства могут быть определены как часть политики. Эти свойства являются необязательными, поэтому рекомендуется не изменять их.

|Свойство | Описание | Рекомендуемое значение | Значение по умолчанию |
|---|---|---|---|
| **минровкаунтпероператион** |  Минимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных. | | `0` |
| **максровкаунтпероператион** |  Максимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных. | Установите значение ниже 5 мин, если вы видите, что операции секционирования потребляют большой объем памяти или ЦП на операцию. Дополнительные сведения см. в разделе [мониторинг](#monitor-partitioning). | `0`с целевым объектом по умолчанию 5 000 000 записей. |

## <a name="the-data-partitioning-process"></a>Процесс секционирования данных

* Секционирование данных выполняется как фоновый процесс приема, выполняемый в кластере.
  * В таблице, которая постоянно принимается в, ожидается "хвостовая" данных, которые еще должны быть секционированы (однородные экстенты).
* Секционирование данных выполняется только в активных экстентах независимо от значения `EffectiveDateTime` свойства в политике.
  * Если требуется секционирование холодного экстента, необходимо временно настроить [политику кэширования](cachepolicy.md).

## <a name="monitor-partitioning"></a>Мониторинг секционирования

Используйте команду [. показывать диагностику](../management/diagnostics.md#show-diagnostics) , чтобы отслеживать ход выполнения или состояние секционирования в кластере.

```kusto
.show diagnostics
| project MinPartitioningPercentageInSingleTable, TableWithMinPartitioningPercentage
```

Выходные данные включают:

  * `MinPartitioningPercentageInSingleTable`: Минимальный процент секционированных данных во всех таблицах, имеющих политику секционирования данных в кластере.
    * Если этот процент постоянно находится под 90%, оцените [емкость](partitioningpolicy.md#partition-capacity)секционирования кластера.
  * `TableWithMinPartitioningPercentage`— Полное имя таблицы, в которой показано процент секционирования.

Используйте [команды. показ команд](commands.md) для наблюдения за командами секционирования и их использованием ресурсов. Пример:

```kusto
.show commands 
| where StartedOn > ago(1d)
| where CommandType == "ExtentsPartition"
| parse Text with ".partition async table " TableName " extents" *
| summarize count(), sum(TotalCpu), avg(tolong(ResourcesUtilization.MemoryPeak)) by TableName, bin(StartedOn, 15m)
| render timechart with(ysplit = panels)
```

## <a name="partition-capacity"></a>Емкость раздела

* Процесс секционирования данных приводит к созданию большего количества экстентов. Кластер может постепенно увеличить [емкость объединения](../management/capacitypolicy.md#extents-merge-capacity), чтобы процесс [объединения экстентов](../management/extents-overview.md) мог быть завершен.
* Если имеется высокая пропускная способность приема или большое количество таблиц, для которых определена политика секционирования, то кластер может постепенно увеличить [емкость раздела](../management/capacitypolicy.md#extents-partition-capacity), чтобы [процесс секционирования](#the-data-partitioning-process) мог оказаться в курсе.
* Чтобы не потреблять слишком много ресурсов, эти динамические увеличения будут ограничены. Может потребоваться постепенное и линейное увеличение их сверх ограничения, если они полностью используются.
  * Если увеличение емкости приводит к значительному увеличению использования [ресурсов кластера, можно масштабировать кластер](../../manage-cluster-vertical-scaling.md) / [out](../../manage-cluster-horizontal-scaling.md)вручную или включить Автомасштабирование.

## <a name="outliers-in-partitioned-columns"></a>Выбросы в секционированных столбцах

* Следующие ситуации могут повлиять на несбалансированное распределение данных между узлами кластера и снизить производительность запросов:
    * Если ключ хэш-секции содержит значения, которые гораздо более распространены, чем другие, например пустая строка или универсальное значение (например, `null` или `N/A` ).
    * Значения представляют сущность (например `tenant_id` ,), которая более распространена в наборе данных.
* Если ключ секции даты и времени с равномерным диапазоном имеет достаточно большой процент значений из большинства значений в столбце, издержки в процессе секционирования данных увеличиваются и могут привести к большому количеству небольших экстентов, которые необходимо отследить в кластере. Примером такой ситуации являются значения даты и времени из удаленных или будущих версий.

В обоих случаях следует либо исправить данные, либо отфильтровать любые несущественные записи в данных до или во время приема, чтобы снизить издержки на секционирование данных в кластере. Например, используйте [политику обновления](updatepolicy.md).

## <a name="next-steps"></a>Дальнейшие действия

Используйте [команды управления политиками секционирования](../management/partitioning-policy.md) для управления политиками секционирования данных для таблиц.
