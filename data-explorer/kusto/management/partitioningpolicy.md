---
title: Политика секционирования данных (Предварительная версия) — Azure обозреватель данных | Документация Майкрософт
description: В этой статье описывается политика секционирования данных (Предварительная версия) в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
ms.openlocfilehash: 564ce0677f3d280fed27c0b6ce1328cb35188c4f
ms.sourcegitcommit: 39b04c97e9ff43052cdeb7be7422072d2b21725e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/12/2020
ms.locfileid: "83225893"
---
# <a name="data-partitioning-policy-preview"></a>Политика секционирования данных (Предварительная версия)

Политика секционирования определяет, следует ли секционировать [экстенты (сегменты данных)](../management/extents-overview.md) для определенной таблицы.

> [!NOTE]
> Функция секционирования данных доступна в *предварительной версии*.

Основной целью политики является повышение производительности запросов, которые можно сократить до небольшого подмножества значений в секционированных столбцах и (или) статистической обработки или объединения в столбце с большим количеством элементов. Вторичное потенциальное преимущество — это лучшее сжатие данных.

> [!WARNING]
> В то время как не существует жестко заданных ограничений на объем таблиц, для которых может быть определена политика, во всех дополнительных таблицах в фоновый процесс секционирования данных, выполняющийся на узлах кластера, добавляются дополнительные ресурсы, которые могут потребовать дополнительных ресурсов кластера. см. раздел [емкость](#capacity).

## <a name="partition-keys"></a>Ключи секции

Поддерживаются следующие виды ключей разделов:

|Вид                                                   |Тип столбца |Свойства раздела                    |Значение секции                                        |
|-------------------------------------------------------|------------|----------------------------------------|-------------------------------------------------------|
|[Хэш](#hash-partition-key)                            |`string`    |`Function`, `MaxPartitionCount`, `Seed` | `Function`(`ColumnName`, `MaxPartitionCount`, `Seed`) |
|[Однородный диапазон](#uniform-range-datetime-partition-key) |`datetime`  |`RangeSize`, `Reference`                | `bin_at`(`ColumnName`, `RangeSize`, `Reference`)      |

### <a name="hash-partition-key"></a>Ключ хэш-секции

Применение ключа хэш-секции к `string` столбцу с типом данных в таблице уместно, если в *большинстве* запросов используются фильтры равенства ( `==` , `in()` ) и (или) статистическое выражение или объединение по определенному `string` типизированному столбцу *большого измерения* (кратность 10 миллионов или выше), например `application_ID` , `tenant_ID` или `user_ID` .

* Для секционирования данных используется функция хэширования по модулю.
* Все *однородные* (секционированные) экстенты, принадлежащие к одной секции, назначаются одному и тому же узлу данных.
* Данные в *однородных* (секционированных) экстентах упорядочиваются по ключу хэш-секции.
  * Не обязательно включать ключ секции в [политику порядка строк](roworderpolicy.md), если он определен для таблицы.
* Запросы, использующие [стратегию случайного](../query/shufflequery.md)переключения, в которой `shuffle key` используется в `join` `summarize` или `make-series` является ключом хэш-секции таблицы, должны выполняться лучше, так как объем данных, необходимых для перемещения между узлами кластера, значительно уменьшился.

#### <a name="partition-properties"></a>Свойства раздела

* `Function`имя функции хэш-кода для использования.
  * Поддерживаемое значение: `XxHash64` .
* `MaxPartitionCount`Максимальное количество создаваемых секций (аргумент-остаток функции hash-остатка) за период времени.
  * Поддерживаются значения в диапазоне `(1,1024]` .
    * Ожидается значение:
      * Больше, чем число узлов в кластере
      * Меньше, чем количество элементов в столбце.
    * Чем выше значение, тем больше издержек в процессе секционирования данных на узлах кластера, а чем больше количество экстентов для каждого периода времени.
    * Рекомендуемое значение для начала — `256` .
      * При необходимости ее можно скорректировать (обычно в обратном порядке), основываясь на упомянутых выше вопросах, и (или) на основе измерения преимуществ производительности запросов и затрат на секционирование данных после приема.
* `Seed`значение, используемое для случайного значения хэша.
  * Значение должно быть положительным целым числом.
  * Рекомендуемое значение (и по умолчанию, если оно не указано) равно `1` .

#### <a name="example"></a>Пример

Ниже приведен ключ хэш-секции для столбца с `string` именем `tenant_id` .

Он использует `XxHash64` хэш-функцию с параметром `MaxPartitionCount` `256` , а значение по умолчанию — `Seed` `1` .

```json
{
  "ColumnName": "tenant_id",
  "Kind": "Hash",
  "Properties": {
    "Function": "XxHash64",
    "MaxPartitionCount": 256,
    "Seed": 1
  }
}
```

### <a name="uniform-range-datetime-partition-key"></a>Ключ секции DateTime с равномерным диапазоном

Применение ключа секции даты и времени с равномерным диапазоном для `datetime` столбца с типом в таблице уместно, если данные, полученные в таблице, *вряд* ли будут упорядочены в соответствии с этим столбцом. В таких случаях может оказаться полезным повторное перемещение данных между экстентами, чтобы каждый экстент мог включать записи из ограниченного диапазона времени, что приведет к более эффективной работе с фильтрами для `datetime` столбца во время запроса.

* Используемая функция секционирования — [bin_at ()](../query/binatfunction.md) и не может быть настраиваемой.

#### <a name="partition-properties"></a>Свойства раздела

* `RangeSize``timespan`Скалярная константа, указывающая размер каждой секции DateTime.
  * Рекомендуемое значение для начала — `1.00:00:00` (один день).
  * Установка значения значительно короче, *чем рекомендуется, так как это может* привести к созданию таблицы с большим количеством небольших экстентов, которые нельзя объединить вместе.
* `Reference`— Это `datetime` Скалярная константа типа, указывающая фиксированную точку во времени в соответствии с тем, какие секции даты и времени вычисляются.
  * Рекомендуемое значение для начала — `1970-01-01 00:00:00` .
  * Если имеются записи, в которых ключ секции даты имеет `null` значения, то для их значения секции задается значение `Reference` .

#### <a name="example"></a>Пример

Ниже приведен универсальный ключ секции с диапазоном DateTime для `datetime` типизированного столбца с именем`timestamp`

Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "ColumnName": "timestamp",
  "Kind": "UniformRange",
  "Properties": {
    "Reference": "1970-01-01T00:00:00",
    "RangeSize": "1.00:00:00"
  }
}
```

## <a name="the-policy-object"></a>Объект политики

По умолчанию политика секционирования данных таблицы имеет значение `null` , в этом случае данные в таблице не будут секционированы.

Политика секционирования данных имеет следующие основные свойства.

* **Партитионкэйс**:
  * Коллекция [ключей разделов](#partition-keys) , определяющих способ секционирования данных в таблице.
  * В таблице может быть `2` несколько ключей секционирования с одним из следующих трех параметров:
    * 1 [ключ хэш-секции](#hash-partition-key).
    * 1 [универсальный ключ секции DateTime с диапазоном](#uniform-range-datetime-partition-key).
    * 1 [ключ хэш-секции](#hash-partition-key) и 1 [однородный ключ секции DateTime](#uniform-range-datetime-partition-key).
  * Каждый ключ секции имеет следующие свойства.
    * `ColumnName`: `string ` — Имя столбца, в соответствии с которым будут секционированы данные.
    * `Kind`: `string` — Тип секционирования данных для применения ( `Hash` или `UniformRange` ).
    * `Properties`: `property bag` — определяет параметры, в соответствии с которыми выполняется секционирование.

* **Еффективедатетиме**:
  * Дата и время (в формате UTC), с которых действует политика.
  * Это свойство является *необязательным* . Если не указано, политика вступит в силу при применении данных после применения политики.
  * Все односторонние (несекционированные) экстенты, которые привязаны к скорому завершению, отбрасываются из-за удержания (т. е. время создания предшествует 90% периода бездействия обратимого удаления таблицы), не учитывается процессом секционирования.

### <a name="example"></a>Пример

Ниже приведен объект политики секционирования данных с двумя ключами раздела:
1. Ключ хэш-секции для `string` столбца с именем `tenant_id` .
    - Он использует `XxHash64` хэш-функцию с значением `MaxPartitionCount` 256 и значением по умолчанию `Seed` `1` .
2. Универсальный ключ секции с диапазоном DateTime для `datetime` типизированного столбца с именем`timestamp`
    - Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "PartitionKeys": [
    {
      "ColumnName": "tenant_id",
      "Kind": "Hash",
      "Properties": {
        "Function": "XxHash64",
        "MaxPartitionCount": 256,
        "Seed": 1
      }
    },
    {
      "ColumnName": "timestamp",
      "Kind": "UniformRange",
      "Properties": {
        "Reference": "1970-01-01T00:00:00",
        "RangeSize": "1.00:00:00"
      }
    }
  ]
}
```

### <a name="additional-properties"></a>Дополнительные свойства

Следующие свойства могут быть определены как часть политики, но являются *необязательными* , и их не рекомендуется изменять.

* **Минровкаунтпероператион**:
  * Минимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это свойство является *необязательным*и имеет значение по умолчанию `0` .

* **Максровкаунтпероператион**:
  * Максимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это свойство является *необязательным*и имеет значение по умолчанию `0` (в этом случае действует целевой объект по умолчанию 5 000 000 записей).

## <a name="notes"></a>Примечания

### <a name="the-data-partitioning-process"></a>Процесс секционирования данных

* Секционирование данных выполняется как фоновый процесс приема, выполняемый в кластере.
  * В таблице, которая постоянно принимается в, ожидается "хвост" данных, которые еще должны быть секционированы (*однородные* экстенты).
* Секционирование данных выполняется только в активных экстентах независимо от значения `EffectiveDateTime` свойства в политике.
  * Если требуется секционирование холодных экстентов, необходимо временно настроить [политику кэширования](cachepolicy.md) .

#### <a name="monitoring"></a>Наблюдение

* Вы можете отслеживать ход выполнения или состояние секционирования в кластере с помощью команды [. показывать диагностику](../management/diagnostics.md#show-diagnostics) :

```kusto
.show diagnostics
| project MinPartitioningPercentageInSingleTable,
          TableWithMinPartitioningPercentage
```

Выходные данные включают:

  * `MinPartitioningPercentageInSingleTable`: минимальный процент секционированных данных во всех таблицах, имеющих политику секционирования данных в кластере.
      * Если этот процент постоянно находится в течение 90%, оцените емкость секционирования кластера (см. [ниже](partitioningpolicy.md#capacity)).
  * `TableWithMinPartitioningPercentage`— полное имя таблицы, в которой показано процент секционирования.

#### <a name="capacity"></a>Capacity

* Процесс секционирования данных приводит к созданию большего количества экстентов. Кластер может постепенно увеличить [емкость объединения](../management/capacitypolicy.md#extents-merge-capacity), чтобы процесс [объединения экстентов](../management/extents-overview.md) мог быть завершен.
* В случае высокой пропускной способности приема и (или) большого количества таблиц, для которых определена политика секционирования, кластер может постепенно увеличить [емкость раздела](../management/capacitypolicy.md#extents-partition-capacity), чтобы [процесс секционирования](#the-data-partitioning-process) мог оказаться в курсе.
* Чтобы не потреблять слишком много ресурсов, эти динамические увеличения будут ограничены. Возможно, вам потребуется (постепенно и линейно) увеличить их за пределами ограничения, если они израсходован.
  * Если увеличение емкости приводит к значительному увеличению использования [ресурсов кластера, можно масштабировать кластер](../../manage-cluster-vertical-scaling.md) / [out](../../manage-cluster-horizontal-scaling.md)вручную или включить автоматическое масштабирование.

### <a name="outliers-in-partitioned-columns"></a>Выбросы в секционированных столбцах

* Если ключ хэш-секции имеет большой процент значений, которые не заполнены должным образом (например, они пусты или имеют общее значение), это может повлиять на несбалансированное распределение данных между узлами кластера.
* Если ключ секции даты и времени с равномерным диапазоном имеет большой процент значений, которые являются "далеко" от большинства значений в столбце (например, значения DateTime из удаленных или будущих периодов).

В обоих случаях следует либо исправить данные, либо отфильтровать любые несущественные записи в данных до или во время приема (например, с помощью [политики обновления](updatepolicy.md)), чтобы снизить затраты на секционирование данных в кластере.

## <a name="next-steps"></a>Дальнейшие действия

Используйте [команды управления политиками секционирования](../management/partitioning-policy.md) для управления политиками секционирования данных для таблиц.
