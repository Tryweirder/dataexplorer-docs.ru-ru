---
title: Политика секционирования данных (Предварительная версия) — Azure обозреватель данных
description: В этой статье описывается политика секционирования данных (Предварительная версия) в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
ms.openlocfilehash: f17bd3736d2a154dd287459bd779088517eebcbc
ms.sourcegitcommit: 41cd88acc1fd79f320a8fe8012583d4c8522db78
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84294497"
---
# <a name="data-partitioning-policy-preview"></a>Политика секционирования данных (Предварительная версия)

Политика секционирования определяет, следует ли секционировать [экстенты (сегменты данных)](../management/extents-overview.md) для определенной таблицы.

> [!NOTE]
> Функция секционирования данных доступна в *предварительной версии*.

Основная цель политики — повысить производительность запросов, которые известны для ограничения набора данных значений в секционированных столбцах, или статистической обработки или объединения в столбце с большим количеством элементов. Кроме того, политика может привести к более эффективному сжатию данных.

> [!CAUTION]
> Жестко запрограммированные ограничения на количество таблиц, для которых может быть определена политика, не заданы. Однако каждая дополнительная таблица добавляет издержки на фоновый процесс секционирования данных, который выполняется на узлах кластера. Это может привести к тому, что будут использоваться больше ресурсов кластеров. Дополнительные сведения см. в разделе [Capacity](#capacity).

## <a name="partition-keys"></a>Ключи секции

Поддерживаются следующие виды ключей секций.

|Вид                                                   |Тип столбца |Свойства раздела                    |Значение секции                                        |
|-------------------------------------------------------|------------|----------------------------------------|----------------------|
|[Hash](#hash-partition-key)                            |`string`    |`Function`, `MaxPartitionCount`, `Seed` | `Function`(`ColumnName`, `MaxPartitionCount`, `Seed`) |
|[Однородный диапазон](#uniform-range-datetime-partition-key) |`datetime`  |`RangeSize`, `Reference`                | `bin_at`(`ColumnName`, `RangeSize`, `Reference`)      |

### <a name="hash-partition-key"></a>Ключ хэш-секции

Применение ключа хэш-секции к `string` столбцу-типу в таблице уместно, когда большинство запросов использует фильтры равенства ( `==` , `in()` ) или когда они объединены или объединены в определенном `string` столбце *большого размера* (кратность 10 миллионов или выше), например, `application_ID` `tenant_ID` или `user_ID` .

* Для секционирования данных используется функция хэширования по модулю.
* Все однородные (секционированные) экстенты, принадлежащие к одной секции, назначаются одному и тому же узлу данных.
* Данные в однородных (секционированных) экстентах упорядочиваются по ключу хэш-секции.
  * Не нужно включать ключ хэш-секции в [политику порядка строк](roworderpolicy.md), если он определен для таблицы.
* Запросы, использующие [стратегию случайного](../query/shufflequery.md)переключения, в которой `shuffle key` используется в `join` `summarize` или `make-series` является ключом хэш-секции таблицы, должны выполняться лучше, так как объем данных, необходимых для перемещения между узлами кластера, значительно уменьшился.

#### <a name="partition-properties"></a>Свойства раздела

* `Function`имя функции хэш-кода для использования.
  * Поддерживаемое значение: `XxHash64` .
* `MaxPartitionCount`Максимальное количество создаваемых секций (аргумент-остаток функции hash-остатка) за период времени.
  * Поддерживаемые значения находятся в диапазоне `(1,1024]` .
    * Ожидается значение:
      * Больше, чем число узлов в кластере
      * Меньше, чем количество элементов в столбце.
    * Чем выше значение, тем больше накладных расходов на узлы кластера и чем выше число экстентов для каждого периода времени.
    * Рекомендуется начинать со значения `256` .
      * Измените значение по своему усмотрению, исходя из приведенных выше соображений, или в зависимости от преимуществ производительности запросов и затрат на секционирование данных после приема.
* `Seed`значение, используемое для случайного значения хэша.
  * Значение должно быть положительным целым числом.
  * Рекомендуемое значение — `1` , которое является значением по умолчанию, если не указано.

#### <a name="example"></a>Пример

Ключ хэш-секции для `string` столбца с именем `tenant_id` .
Он использует `XxHash64` хэш-функцию с параметром `MaxPartitionCount` `256` , а значение по умолчанию — `Seed` `1` .

```json
{
  "ColumnName": "tenant_id",
  "Kind": "Hash",
  "Properties": {
    "Function": "XxHash64",
    "MaxPartitionCount": 256,
    "Seed": 1
  }
}
```

### <a name="uniform-range-datetime-partition-key"></a>Ключ секции DateTime с равномерным диапазоном

Применение ключа секции даты и времени с равномерным диапазоном для `datetime` столбца с типом в таблице уместно, если данные, полученные в таблице, вряд ли будут упорядочены в соответствии с этим столбцом. Может быть полезно переключить данные между экстентами так, чтобы каждый экстент мог включать записи из ограниченного диапазона времени. Перегруппировка приводит к `datetime` более эффективному использованию фильтров в столбце на этапе запроса.

* Используемая функция секционирования — [bin_at ()](../query/binatfunction.md) и не может быть настраиваемой.

#### <a name="partition-properties"></a>Свойства раздела

* `RangeSize``timespan`Скалярная константа, указывающая размер каждой секции DateTime.
  Рекомендуется:
  * Начните со значения `1.00:00:00` (один день).
  * Не устанавливайте значение короче этого, так как это может привести к тому, что таблица имеет большое количество небольших экстентов, которые невозможно объединить.
* `Reference`— Это `datetime` Скалярная константа, указывающая на фиксированную точку во времени в соответствии с согласованными секциями даты и времени.
  * Мы рекомендуем начать с `1970-01-01 00:00:00` .
  * Если имеются записи, в которых ключ секции даты имеет `null` значения, то для их значения секции задается значение `Reference` .

#### <a name="example"></a>Пример

Фрагмент кода показывает универсальный ключ секции с диапазоном DateTime для `datetime` типизированного столбца с именем `timestamp` .
Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "ColumnName": "timestamp",
  "Kind": "UniformRange",
  "Properties": {
    "Reference": "1970-01-01T00:00:00",
    "RangeSize": "1.00:00:00"
  }
}
```

## <a name="the-policy-object"></a>Объект политики

По умолчанию политика секционирования данных в таблице имеет значение `null` , в этом случае данные в таблице не будут секционированы.

Политика секционирования данных имеет следующие основные свойства.

* **Партитионкэйс**:
  * Коллекция [ключей разделов](#partition-keys) , определяющих способ секционирования данных в таблице.
  * Таблица может содержать `2` ключи до секций с одним из следующих вариантов.
    * Один [ключ хэш-секции](#hash-partition-key).
    * Один [универсальный ключ секции даты и времени](#uniform-range-datetime-partition-key).
    * Один ключ [хэш-секции](#hash-partition-key) и один [ключ секции DateTime с одинаковым диапазоном](#uniform-range-datetime-partition-key).
  * Каждый ключ секции имеет следующие свойства.
    * `ColumnName`: `string ` — Имя столбца, в соответствии с которым будут секционированы данные.
    * `Kind`: `string` — Тип секционирования данных для применения ( `Hash` или `UniformRange` ).
    * `Properties`: `property bag` — Определяет параметры, в соответствии с которыми выполняется секционирование.

* **Еффективедатетиме**:
  * Дата и время (в формате UTC), с которых действует политика.
  * Это свойство необязательно. Если он не указан, то политика вступит в силу на данных, полученных после применения политики.
  * Любые однородные (несекционированные) экстенты, которые могут быть удалены из-за удержания, игнорируются процессом секционирования, поскольку время создания предшествует 90% эффективного периода обратимого удаления таблицы.

### <a name="example"></a>Пример

Объект политики секционирования данных с двумя ключами секции.
1. Ключ хэш-секции для `string` столбца с именем `tenant_id` .
    - Он использует `XxHash64` хэш-функцию с значением `MaxPartitionCount` 256 и значением по умолчанию `Seed` `1` .
1. Ключ секции одинакового диапазона дат и времени для `datetime` столбца типа с именем `timestamp` .
    - Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "PartitionKeys": [
    {
      "ColumnName": "tenant_id",
      "Kind": "Hash",
      "Properties": {
        "Function": "XxHash64",
        "MaxPartitionCount": 256,
        "Seed": 1
      }
    },
    {
      "ColumnName": "timestamp",
      "Kind": "UniformRange",
      "Properties": {
        "Reference": "1970-01-01T00:00:00",
        "RangeSize": "1.00:00:00"
      }
    }
  ]
}
```

### <a name="additional-properties"></a>Дополнительные свойства

Следующие свойства могут быть определены как часть политики, но являются необязательными, поэтому рекомендуется не изменять их.

* **Минровкаунтпероператион**:
  * Минимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это свойство необязательно. Значение по умолчанию — `0`.

* **Максровкаунтпероператион**:
  * Максимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это свойство необязательно. Значение по умолчанию — `0` , а целевой объект по умолчанию — 5 000 000 записей.

## <a name="notes"></a>Примечания

### <a name="the-data-partitioning-process"></a>Процесс секционирования данных

* Секционирование данных выполняется как фоновый процесс приема, выполняемый в кластере.
  * В таблице, которая постоянно принимается в, ожидается "хвостовая" данных, которые еще должны быть секционированы (однородные экстенты).
* Секционирование данных выполняется только в активных экстентах независимо от значения `EffectiveDateTime` свойства в политике.
  * Если требуется секционирование холодного экстента, необходимо временно настроить [политику кэширования](cachepolicy.md).

#### <a name="monitoring"></a>Наблюдение

* Можно отслеживать ход выполнения или состояние секционирования в кластере. Используйте команду [. показывать диагностику](../management/diagnostics.md#show-diagnostics) .

```kusto
.show diagnostics
| project MinPartitioningPercentageInSingleTable,
          TableWithMinPartitioningPercentage
```

Выходные данные включают:

  * `MinPartitioningPercentageInSingleTable`: Минимальный процент секционированных данных во всех таблицах, имеющих политику секционирования данных в кластере.
      * Если этот процент постоянно находится под 90%, оцените емкость секционирования кластера (см. раздел [емкость](partitioningpolicy.md#capacity)).
  * `TableWithMinPartitioningPercentage`— Полное имя таблицы, в которой показано процент секционирования.

#### <a name="capacity"></a>Capacity

* Процесс секционирования данных приводит к созданию большего количества экстентов. Кластер может постепенно увеличить [емкость объединения](../management/capacitypolicy.md#extents-merge-capacity), чтобы процесс [объединения экстентов](../management/extents-overview.md) мог быть завершен.
* Если имеется высокая пропускная способность приема или большое количество таблиц, для которых определена политика секционирования, то кластер может постепенно увеличить [емкость раздела](../management/capacitypolicy.md#extents-partition-capacity), чтобы [процесс секционирования](#the-data-partitioning-process) мог оказаться в курсе.
* Чтобы не потреблять слишком много ресурсов, эти динамические увеличения будут ограничены. Может потребоваться постепенное и линейное увеличение их сверх ограничения, если они полностью используются.
  * Если увеличение емкости приводит к значительному увеличению использования [ресурсов кластера, можно масштабировать кластер](../../manage-cluster-vertical-scaling.md) / [out](../../manage-cluster-horizontal-scaling.md)вручную или включить Автомасштабирование.

### <a name="outliers-in-partitioned-columns"></a>Выбросы в секционированных столбцах

* Если ключ хэш-секции содержит значения, которые гораздо более распространены, чем другие, например пустая строка или универсальное значение (например, `null` или `N/A` ), или они представляют сущность (например `tenant_id` ,), более распространенную в наборе данных, может повлиять на несбалансированное распределение данных между узлами кластера и снизить производительность запросов.
* Если ключ секции даты и времени с равномерным диапазоном имеет большой процент значений из большинства значений в столбце (например, значения даты и времени, предшествующие прошлому или будущему), то это может увеличить издержки процесса секционирования данных и привести ко многим небольшим экстентам, которые кластеру потребуется отследить.

В обоих случаях следует либо исправить данные, либо отфильтровать все несущественные записи в данных до или во время приема, чтобы снизить издержки на секционирование данных в кластере. Например, используйте [политику обновления](updatepolicy.md).

## <a name="next-steps"></a>Дальнейшие действия

Используйте [команды управления политиками секционирования](../management/partitioning-policy.md) для управления политиками секционирования данных для таблиц.
