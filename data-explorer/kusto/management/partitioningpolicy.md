---
title: Политика секционирования данных (Предварительная версия) — Azure обозреватель данных | Документация Майкрософт
description: В этой статье описывается политика секционирования данных (Предварительная версия) в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
ms.openlocfilehash: e03ff6fe7ffb65d11b59cc98f150df617d42932d
ms.sourcegitcommit: 1faf502280ebda268cdfbeec2e8ef3d582dfc23e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/01/2020
ms.locfileid: "82616378"
---
# <a name="data-partitioning-policy-preview"></a>Политика секционирования данных (Предварительная версия)

Политика секционирования определяет, следует ли секционировать [экстенты (сегменты данных)](../management/extents-overview.md) для определенной таблицы.

> [!NOTE]
> Функция секционирования данных доступна в *предварительной версии*.

Основная цель политики — повысить производительность запросов, которые можно сократить до небольшого подмножества значений в секционированных столбцах.
Вторичное потенциальное преимущество — это лучшее сжатие данных.

> [!WARNING]
> В то время как не существует жестко заданных ограничений на объем таблиц, для которых может быть определена политика, во всех дополнительных таблицах в фоновый процесс секционирования данных, выполняющийся на узлах кластера, добавляются дополнительные ресурсы, которые могут потребовать дополнительных ресурсов кластера. см. раздел [емкость](#capacity).

## <a name="partition-keys"></a>Ключи секции

Поддерживаются следующие виды ключей разделов:

|Вид                                                   |Тип столбца |Свойства раздела                    |Значение секции                                        |
|-------------------------------------------------------|------------|----------------------------------------|-------------------------------------------------------|
|[Хэш](#hash-partition-key)                            |`string`    |`Function`, `MaxPartitionCount`, `Seed` | `Function`(`ColumnName`, `MaxPartitionCount`, `Seed`) |
|[Однородный диапазон](#uniform-range-datetime-partition-key) |`datetime`  |`RangeSize`, `Reference`                | `bin_at`(`ColumnName`, `RangeSize`, `Reference`)      |

### <a name="hash-partition-key"></a>Ключ хэш-секции

Применение ключа хэш-секции к столбцу `string`с типом данных в таблице уместно, когда *большинство* запросов использует фильтры равенства (`==`, `in()`) для столбца с определенным `string`типом для *больших измерений* (10 миллионов или выше), например `application_ID`, `tenant_ID` или. `user_ID`

* Для секционирования данных используется функция хэширования по модулю.
* Все *однородные* (секционированные) экстенты, принадлежащие к одной секции, назначаются одному и тому же узлу данных.
* Данные в *однородных* (секционированных) экстентах упорядочиваются по ключу хэш-секции.
  * Не обязательно включать ключ секции в [политику порядка строк](roworderpolicy.md), если он определен для таблицы.
* Запросы, использующие [стратегию случайного](../query/shufflequery.md)переключения, `shuffle key` в которой используется в `join` `summarize` или `make-series` является ключом хэш-секции таблицы, должны выполняться лучше, так как объем данных, необходимых для перемещения между узлами кластера, значительно уменьшился.

#### <a name="partition-properties"></a>Свойства раздела

* `Function`имя функции хэш-кода для использования.
  * Поддерживаемое значение: `XxHash64`.
* `MaxPartitionCount`Максимальное количество создаваемых секций (аргумент-остаток функции hash-остатка) за период времени.
  * Поддерживаются значения в диапазоне `(1,1024]`.
    * Ожидается значение:
      * Больше, чем число узлов в кластере
      * Меньше, чем количество элементов в столбце.
    * Чем выше значение, тем больше издержек в процессе секционирования данных на узлах кластера, а чем больше количество экстентов для каждого периода времени.
    * Рекомендуемое значение для начала — `256`.
      * При необходимости ее можно скорректировать (обычно в обратном порядке), основываясь на упомянутых выше вопросах, и (или) на основе измерения преимуществ производительности запросов и затрат на секционирование данных после приема.
* `Seed`значение, используемое для случайного значения хэша.
  * Значение должно быть положительным целым числом.
  * Рекомендуемое значение (и по умолчанию, если оно не `1`указано) равно.

#### <a name="example"></a>Пример

Ниже приведен ключ хэш-секции для `string`столбца с именем. `tenant_id`

`XxHash64` Он использует хэш-функцию с `MaxPartitionCount` параметром `256`, а значение по умолчанию `1` `Seed` —.

```json
{
  "ColumnName": "tenant_id",
  "Kind": "Hash",
  "Properties": {
    "Function": "XxHash64",
    "MaxPartitionCount": 256,
    "Seed": 1
  }
}
```

### <a name="uniform-range-datetime-partition-key"></a>Ключ секции DateTime с равномерным диапазоном

Применение ключа секции даты и времени с равномерным `datetime`диапазоном для столбца с типом в таблице уместно, если данные, полученные в таблице, *вряд* ли будут упорядочены в соответствии с этим столбцом. В таких случаях может оказаться полезным повторное перемещение данных между экстентами, чтобы каждый экстент мог включать записи из ограниченного диапазона времени, что приведет к более эффективной работе с фильтрами для `datetime` столбца во время запроса.

* Используемая функция секционирования — [bin_at ()](../query/binatfunction.md) и не может быть настраиваемой.

#### <a name="partition-properties"></a>Свойства раздела

* `RangeSize``timespan` скалярная константа, указывающая размер каждой секции DateTime.
* `Reference`— Это `datetime` скалярная константа типа, указывающая фиксированную точку во времени в соответствии с тем, какие секции даты и времени вычисляются.
  * Если имеются записи, в которых ключ секции даты имеет `null` значения, то для их значения секции задается значение. `Reference`

#### <a name="example"></a>Пример

Ниже приведен универсальный ключ секции с диапазоном DateTime для `datetime`типизированного столбца с именем`timestamp`

Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "ColumnName": "timestamp",
  "Kind": "UniformRange",
  "Properties": {
    "Reference": "1970-01-01T00:00:00",
    "RangeSize": "1.00:00:00"
  }
}
```

## <a name="the-policy-object"></a>Объект политики

По умолчанию политика секционирования данных таблицы имеет `null`значение, в этом случае данные в таблице не будут секционированы.

Политика секционирования данных имеет следующие основные свойства.

* **Партитионкэйс**:
  * Коллекция [ключей разделов](#partition-keys) , определяющих способ секционирования данных в таблице.
  * В таблице может быть несколько ключей `2` секционирования с одним из следующих трех параметров:
    * 1 [ключ хэш-секции](#hash-partition-key).
    * 1 [универсальный ключ секции DateTime с диапазоном](#uniform-range-datetime-partition-key).
    * 1 [ключ хэш-секции](#hash-partition-key) и 1 [однородный ключ секции DateTime](#uniform-range-datetime-partition-key).
  * Каждый ключ секции имеет следующие свойства.
    * `ColumnName`: `string ` — Имя столбца, в соответствии с которым будут секционированы данные.
    * `Kind`: `string` — Тип секционирования данных для применения (`Hash` или `UniformRange`).
    * `Properties`: `property bag` — определяет параметры, в соответствии с которыми выполняется секционирование.

* **Еффективедатетиме**:
  * Дата и время (в формате UTC), с которых действует политика.
  * Это свойство является *необязательным* . Если не указано, политика вступит в силу при применении данных после применения политики.
  * Все односторонние (несекционированные) экстенты, которые привязаны к скорому завершению, отбрасываются из-за удержания (т. е. время создания предшествует 90% периода бездействия обратимого удаления таблицы), не учитывается процессом секционирования.

### <a name="example"></a>Пример

Ниже приведен объект политики секционирования данных с двумя ключами раздела:
1. Ключ хэш-секции для `string`столбца с именем. `tenant_id`
    - Он использует `XxHash64` хэш-функцию с значением `MaxPartitionCount` 256 и значением по умолчанию. `Seed` `1`
2. Универсальный ключ секции с диапазоном DateTime для `datetime`типизированного столбца с именем`timestamp`
    - Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "PartitionKeys": [
    {
      "ColumnName": "tenant_id",
      "Kind": "Hash",
      "Properties": {
        "Function": "XxHash64",
        "MaxPartitionCount": 256,
        "Seed": 1
      }
    },
    {
      "ColumnName": "timestamp",
      "Kind": "UniformRange",
      "Properties": {
        "Reference": "1970-01-01T00:00:00",
        "RangeSize": "1.00:00:00"
      }
    }
  ]
}
```

### <a name="additional-properties"></a>Дополнительные свойства

Следующие свойства могут быть определены как часть политики, но являются *необязательными* , и их не рекомендуется изменять.

* **Минровкаунтпероператион**:
  * Минимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это свойство является *необязательным*и имеет значение по умолчанию `0`.

* **Максровкаунтпероператион**:
  * Максимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это свойство является *необязательным*и имеет значение по умолчанию `0` (в этом случае действует целевой объект по умолчанию 5 000 000 записей).

## <a name="notes"></a>Примечания

### <a name="the-data-partitioning-process"></a>Процесс секционирования данных

* Секционирование данных выполняется как фоновый процесс приема, выполняемый в кластере.
  * В таблице, которая постоянно принимается в, ожидается "хвост" данных, которые еще должны быть секционированы (*однородные* экстенты).
* Секционирование данных выполняется только в активных экстентах независимо от значения `EffectiveDateTime` свойства в политике.
  * Если требуется секционирование холодных экстентов, необходимо временно настроить [политику кэширования](cachepolicy.md) .

#### <a name="monitoring"></a>Наблюдение

* Вы можете отслеживать ход выполнения или состояние секционирования в кластере с помощью команды [. показывать диагностику](../management/diagnostics.md#show-diagnostics) :

```kusto
.show diagnostics
| project MinPartitioningPercentageInSingleTable,
          TableWithMinPartitioningPercentage
```

Выходные данные включают:

  * `MinPartitioningPercentageInSingleTable`: минимальный процент секционированных данных во всех таблицах, имеющих политику секционирования данных в кластере.
      * Если этот процент постоянно находится в течение 90%, оцените емкость секционирования кластера (см. [ниже](partitioningpolicy.md#capacity)).
  * `TableWithMinPartitioningPercentage`— полное имя таблицы, в которой показано процент секционирования.

#### <a name="capacity"></a>Capacity

* Поскольку процесс секционирования данных приводит к созданию большего количества экстентов, может потребоваться (постепенно и линейно) увеличить емкость кластера для [объединения](../management/capacitypolicy.md#extents-merge-capacity) экстентов, чтобы процесс [слияния экстентов](../management/extents-overview.md) мог поддерживаться.
* Если это необходимо (например, в случае высокой пропускной способности приема и (или) большого количества таблиц, требующих секционирования), [емкость раздела](../management/capacitypolicy.md#extents-partition-capacity) кластера может быть увеличена (постепенно и линейно), что позволяет выполнять большее количество одновременных операций секционирования.
  * Если увеличение секционирования приводит к значительному увеличению использования ресурсов кластера, масштабирование кластера либо вручную, либо путем включения автомасштабирования.

### <a name="outliers-in-partitioned-columns"></a>Выбросы в секционированных столбцах

* Если ключ хэш-секции имеет большой процент значений, которые не заполнены должным образом (например, они пусты или имеют общее значение), это может повлиять на несбалансированное распределение данных между узлами кластера.
* Если ключ секции даты и времени с равномерным диапазоном имеет большой процент значений, которые являются "далеко" от большинства значений в столбце (например, значения DateTime из удаленных или будущих периодов).

В обоих случаях следует либо исправить данные, либо отфильтровать любые несущественные записи в данных до или во время приема (например, с помощью [политики обновления](updatepolicy.md)), чтобы снизить затраты на секционирование данных в кластере.

## <a name="next-steps"></a>Следующие шаги

Используйте [команды управления политиками секционирования](../management/partitioning-policy.md) для управления политиками секционирования данных для таблиц.
