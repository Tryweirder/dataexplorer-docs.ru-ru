---
title: Политика секционирования данных — Azure обозреватель данных
description: В этой статье описывается политика секционирования данных в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 06/10/2020
ms.openlocfilehash: c3f7212b062adaae1bd56399753270653204ad22
ms.sourcegitcommit: 53a727fceaa89e6022bc593a4aae70f1e0232f49
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2020
ms.locfileid: "89652114"
---
# <a name="data-partitioning-policy"></a>Политика секционирования данных

Политика секционирования определяет, следует ли секционировать [экстенты (сегменты данных)](../management/extents-overview.md) для определенной таблицы.

Основная цель политики — повысить производительность запросов, которые известны для ограничения набора данных путем фильтрации по секционированным столбцам, или статистической обработки или объединения в столбце с большим количеством элементов. Кроме того, политика может привести к более эффективному сжатию данных.

> [!CAUTION]
> Жестко запрограммированные ограничения на количество таблиц, для которых может быть определена политика, не заданы. Однако каждая дополнительная таблица добавляет издержки на фоновый процесс секционирования данных, который выполняется на узлах кластера. Это может привести к тому, что будут использоваться больше ресурсов кластера. Дополнительные сведения см. в разделе [мониторинг](#monitoring) и [емкость](#capacity).

## <a name="partition-keys"></a>Ключи секции

Поддерживаются следующие виды ключей секций.

|Вид                                                   |Тип столбца |Свойства раздела                    |Значение секции                                        |
|-------------------------------------------------------|------------|----------------------------------------|----------------------|
|[Хэш](#hash-partition-key)                            |`string`    |`Function`, `MaxPartitionCount`, `Seed` | `Function`(`ColumnName`, `MaxPartitionCount`, `Seed`) |
|[Однородный диапазон](#uniform-range-datetime-partition-key) |`datetime`  |`RangeSize`, `Reference`                | `bin_at`(`ColumnName`, `RangeSize`, `Reference`)      |

### <a name="hash-partition-key"></a>Ключ хэш-секции

> [!NOTE]
> Применить ключ хэш-секции к `string` столбцу типа в таблице только в следующих экземплярах:
> * Если в большинстве запросов используются фильтры равенства ( `==` , `in()` ).
> * Большинство запросов объединены или объединены по `string` столбцу с определенным типом *больших измерений* (кратность 10 миллионов или выше), например, `application_ID` `tenant_ID` или `user_ID` .

* Для секционирования данных используется функция хэширования по модулю.
* Данные в однородных (секционированных) экстентах упорядочиваются по ключу хэш-секции.
  * Не нужно включать ключ хэш-секции в [политику порядка строк](roworderpolicy.md), если он определен для таблицы.
* Запросы, использующие [стратегию случайного](../query/shufflequery.md)переключения, в которой `shuffle key` используется в `join` `summarize` или `make-series` является ключом хэш-секции таблицы, должны выполняться лучше, так как объем данных, необходимых для перемещения между узлами кластера, значительно уменьшился.

#### <a name="partition-properties"></a>Свойства раздела

* `Function` имя функции хэш-кода для использования.
  * Поддерживаемое значение: `XxHash64` .
* `MaxPartitionCount` Максимальное количество создаваемых секций (аргумент-остаток функции hash-остатка) за период времени.
  * Поддерживаемые значения находятся в диапазоне `(1,2048]` .
    * Ожидается значение:
      * Более 5 раз больше, чем количество узлов в кластере.
      * Меньше, чем количество элементов в столбце.
    * Чем выше значение, тем больше накладных расходов на узлы кластера и чем выше число экстентов для каждого периода времени.
    * Для кластеров с менее чем 50 узлами рекомендуется начинать со значения `256` .
      * При необходимости измените значение в соответствии с приведенными выше соображениями (например, количество узлов в кластере растет) или с учетом преимуществ производительности запросов и затрат на секционирование данных после приема.
* `Seed` значение, используемое для случайного значения хэша.
  * Значение должно быть положительным целым числом.
  * Рекомендуемое значение — `1` , которое является значением по умолчанию, если не указано.
* `PartitionAssignmentMode` режим, используемый для назначения секций узлам в кластере.
  * Поддерживаемые режимы:
    * `Default`: Все однородные (секционированные) экстенты, принадлежащие к одной секции, назначаются одному и тому же узлу.
    * `Uniform`: Значения секции экстентов не учитываются, а экстенты равномерно назначаются узлам кластера.
  * Если запросы не объединяют или не выполняют статистическую обработку для ключа хэш-секции, используйте `Uniform` . В противном случае используйте коллекцию `Default`.

#### <a name="example"></a>Пример

Ключ хэш-секции для `string` столбца с именем `tenant_id` .
Он использует `XxHash64` хэш-функцию с параметром `MaxPartitionCount` `256` , а значение по умолчанию — `Seed` `1` .

```json
{
  "ColumnName": "tenant_id",
  "Kind": "Hash",
  "Properties": {
    "Function": "XxHash64",
    "MaxPartitionCount": 256,
    "Seed": 1,
    "PartitionAssignmentMode": "Default"
  }
}
```

### <a name="uniform-range-datetime-partition-key"></a>Ключ секции DateTime с равномерным диапазоном

> [!NOTE] 
> Применение ключа секции даты и времени с равномерным диапазоном к `datetime` типизированному столбцу в таблице, если данные, полученные в таблице, вряд ли упорядочиваются в соответствии с этим столбцом.

В таких случаях может быть полезно переключить данные между экстентами так, чтобы каждый экстент мог включать записи из ограниченного диапазона времени. Это приведет к тому, что фильтры для этого `datetime` столбца будут более эффективны во время запроса.

Используемая функция секционирования — [bin_at ()](../query/binatfunction.md) и не может быть настраиваемой.

#### <a name="partition-properties"></a>Свойства раздела

* `RangeSize``timespan`Скалярная константа, указывающая размер каждой секции DateTime.
  Рекомендуется:
  * Начните со значения `1.00:00:00` (один день).
  * Не устанавливайте значение короче этого, так как это может привести к тому, что таблица имеет большое количество небольших экстентов, которые невозможно объединить.
* `Reference` — Это `datetime` Скалярная константа, указывающая на фиксированную точку во времени в соответствии с согласованными секциями даты и времени.
  * Мы рекомендуем начать с `1970-01-01 00:00:00` .
  * Если имеются записи, в которых ключ секции даты имеет `null` значения, то для их значения секции задается значение `Reference` .

#### <a name="example"></a>Пример

Фрагмент кода показывает универсальный ключ секции с диапазоном DateTime для `datetime` типизированного столбца с именем `timestamp` .
Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "ColumnName": "timestamp",
  "Kind": "UniformRange",
  "Properties": {
    "Reference": "1970-01-01T00:00:00",
    "RangeSize": "1.00:00:00"
  }
}
```

## <a name="the-policy-object"></a>Объект политики

По умолчанию политика секционирования данных в таблице имеет значение `null` , в этом случае данные в таблице не будут секционированы.

Политика секционирования данных имеет следующие основные свойства.

* **Партитионкэйс**:
  * Коллекция [ключей разделов](#partition-keys) , определяющих способ секционирования данных в таблице.
  * Таблица может содержать `2` ключи до секций с одним из следующих вариантов.
    * Один [ключ хэш-секции](#hash-partition-key).
    * Один [универсальный ключ секции даты и времени](#uniform-range-datetime-partition-key).
    * Один ключ [хэш-секции](#hash-partition-key) и один [ключ секции DateTime с одинаковым диапазоном](#uniform-range-datetime-partition-key).
  * Каждый ключ секции имеет следующие свойства.
    * `ColumnName`: `string ` — Имя столбца, в соответствии с которым будут секционированы данные.
    * `Kind`: `string` — Тип секционирования данных для применения ( `Hash` или `UniformRange` ).
    * `Properties`: `property bag` — Определяет параметры, в соответствии с которыми выполняется секционирование.

* **Еффективедатетиме**:
  * Дата и время (в формате UTC), с которых действует политика.
  * Это необязательное свойство. Если он не указан, то политика вступит в силу на данных, полученных после применения политики.
  * Любые однородные (несекционированные) экстенты, которые могут быть удалены из-за удержания, игнорируются процессом секционирования, поскольку время создания предшествует 90% эффективного периода обратимого удаления таблицы.

### <a name="example"></a>Пример

Объект политики секционирования данных с двумя ключами секции.
1. Ключ хэш-секции для `string` столбца с именем `tenant_id` .
    - Он использует `XxHash64` хэш-функцию с значением `MaxPartitionCount` 256 и значением по умолчанию `Seed` `1` .
1. Ключ секции одинакового диапазона дат и времени для `datetime` столбца типа с именем `timestamp` .
    - Он использует `datetime(1970-01-01)` в качестве контрольной точки и размер `1d` для каждой секции.

```json
{
  "PartitionKeys": [
    {
      "ColumnName": "tenant_id",
      "Kind": "Hash",
      "Properties": {
        "Function": "XxHash64",
        "MaxPartitionCount": 256,
        "Seed": 1,
        "PartitionAssignmentMode": "Default"
      }
    },
    {
      "ColumnName": "timestamp",
      "Kind": "UniformRange",
      "Properties": {
        "Reference": "1970-01-01T00:00:00",
        "RangeSize": "1.00:00:00"
      }
    }
  ]
}
```

### <a name="additional-properties"></a>Дополнительные свойства

Следующие свойства могут быть определены как часть политики, но являются необязательными, и их не рекомендуется изменять.

* **Минровкаунтпероператион**:
  * Минимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это необязательное свойство. Значение по умолчанию — `0`.

* **Максровкаунтпероператион**:
  * Максимальная Целевая сумма для количества строк исходных экстентов одной операции секционирования данных.
  * Это необязательное свойство. Значение по умолчанию — `0` , а целевой объект по умолчанию — 5 000 000 записей.
    * Можно задать значение ниже 5 мин, если вы видите, что операции секционирования потребляют очень большой объем памяти или ЦП на операцию. Дополнительные сведения см. в разделе [мониторинг](#monitoring).

## <a name="notes"></a>Примечания

### <a name="the-data-partitioning-process"></a>Процесс секционирования данных

* Секционирование данных выполняется как фоновый процесс приема, выполняемый в кластере.
  * В таблице, которая постоянно принимается в, ожидается "хвостовая" данных, которые еще должны быть секционированы (однородные экстенты).
* Секционирование данных выполняется только в активных экстентах независимо от значения `EffectiveDateTime` свойства в политике.
  * Если требуется секционирование холодного экстента, необходимо временно настроить [политику кэширования](cachepolicy.md).

#### <a name="monitoring"></a>Наблюдение

Используйте команду [. показывать диагностику](../management/diagnostics.md#show-diagnostics) , чтобы отслеживать ход выполнения или состояние секционирования в кластере.

```kusto
.show diagnostics
| project MinPartitioningPercentageInSingleTable, TableWithMinPartitioningPercentage
```

Выходные данные включают:

  * `MinPartitioningPercentageInSingleTable`: Минимальный процент секционированных данных во всех таблицах, имеющих политику секционирования данных в кластере.
    * Если этот процент постоянно находится под 90%, оцените [емкость](partitioningpolicy.md#capacity)секционирования кластера.
  * `TableWithMinPartitioningPercentage`— Полное имя таблицы, в которой показано процент секционирования.

Используйте [команды. показ команд](commands.md) для наблюдения за командами секционирования и их использованием ресурсов. Пример:

```kusto
.show commands 
| where StartedOn > ago(1d)
| where CommandType == "ExtentsPartition"
| parse Text with ".partition async table " TableName " extents" *
| summarize count(), sum(TotalCpu), avg(tolong(ResourcesUtilization.MemoryPeak)) by TableName, bin(StartedOn, 15m)
| render timechart with(ysplit = panels)
```

#### <a name="capacity"></a>Capacity

* Процесс секционирования данных приводит к созданию большего количества экстентов. Кластер может постепенно увеличить [емкость объединения](../management/capacitypolicy.md#extents-merge-capacity), чтобы процесс [объединения экстентов](../management/extents-overview.md) мог быть завершен.
* Если имеется высокая пропускная способность приема или большое количество таблиц, для которых определена политика секционирования, то кластер может постепенно увеличить [емкость раздела](../management/capacitypolicy.md#extents-partition-capacity), чтобы [процесс секционирования](#the-data-partitioning-process) мог оказаться в курсе.
* Чтобы не потреблять слишком много ресурсов, эти динамические увеличения будут ограничены. Может потребоваться постепенное и линейное увеличение их сверх ограничения, если они полностью используются.
  * Если увеличение емкости приводит к значительному увеличению использования [ресурсов кластера, можно масштабировать кластер](../../manage-cluster-vertical-scaling.md) / [out](../../manage-cluster-horizontal-scaling.md)вручную или включить Автомасштабирование.

### <a name="outliers-in-partitioned-columns"></a>Выбросы в секционированных столбцах

* Если ключ хэш-секции содержит значения, которые гораздо более распространены, чем другие, например пустая строка или универсальное значение (например, `null` или `N/A` ), или они представляют сущность (например `tenant_id` ,), более распространенную в наборе данных, может повлиять на несбалансированное распределение данных между узлами кластера и снизить производительность запросов.
* Если ключ секции даты и времени с равномерным диапазоном имеет большой процент значений из большинства значений в столбце (например, значения даты и времени, предшествующие прошлому или будущему), то это может увеличить издержки процесса секционирования данных и привести ко многим небольшим экстентам, которые кластеру потребуется отследить.

В обоих случаях следует либо исправить данные, либо отфильтровать все несущественные записи в данных до или во время приема, чтобы снизить издержки на секционирование данных в кластере. Например, используйте [политику обновления](updatepolicy.md).

## <a name="next-steps"></a>Дальнейшие действия

Используйте [команды управления политиками секционирования](../management/partitioning-policy.md) для управления политиками секционирования данных для таблиц.
