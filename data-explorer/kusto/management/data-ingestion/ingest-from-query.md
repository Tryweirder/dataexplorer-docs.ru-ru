---
title: Прием запросов Kusto (Set, Append, replace) — Azure обозреватель данных
description: В этой статье описывается прием из запроса (. Set,. append,. Set-или-Append,. Set-или-Replace) в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
ms.openlocfilehash: 5248b9d986845ff7f35085cef0100cf3ab4b90da
ms.sourcegitcommit: e87b6cb2075d36dbb445b16c5b83eff7eaf3cdfa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85264476"
---
# <a name="ingest-from-query-set-append-set-or-append-set-or-replace"></a>Прием из запроса (. Set,. append,. Set-или-Append,. Set-или-Replace)

Эти команды выполняют запрос или команду элемента управления и принимают результаты запроса в таблицу. Различие между этими командами заключается в том, как они воспринимают существующие или несуществующие таблицы и данные.

|Get-Help          |Если таблица существует                     |Если таблица не существует                    |
|-----------------|------------------------------------|------------------------------------------|
|`.set`           |Команда завершается ошибкой                  |Таблица создается и данные принимаются|
|`.append`        |Данные добавляются в таблицу      |Команда завершается ошибкой                        |
|`.set-or-append` |Данные добавляются в таблицу      |Таблица создается и данные принимаются|
|`.set-or-replace`|Данные заменяются данными в таблице|Таблица создается и данные принимаются|

**Синтаксис**

`.set`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ...] `)` ] `<|` *Куерйоркомманд*

`.append`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ... `])` ] `<|` *Куерйоркомманд*

`.set-or-append`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ...] `)` ] `<|` *Куерйоркомманд*

`.set-or-replace`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ...] `)` ] `<|` *Куерйоркомманд*

**Аргументы**

* `async`: Если указано, команда немедленно возвращает и продолжает прием в фоновом режиме. Результаты выполнения команды будут содержать `OperationId` значение, которое затем можно использовать с `.show operations` командой для получения состояния и результатов приема.
* *TableName*: имя таблицы для приема данных.
  Имя таблицы всегда связано с базой данных в контексте.
* *PropertyName*, *propertyvalue*— любое количество свойств приема, влияющих на процесс приема.

 Поддерживаемые свойства приема.

|Свойство        |Описание|
|----------------|-----------------------------------------------------------------------------------------------------------------------------|
|`creationTime`   | Значение DateTime, отформатированное как строка ISO8601, для использования во время создания занятых экстентов данных. Если не указано, будет использоваться текущее значение ( `now()` ).|
|`extend_schema`  | Логическое значение, которое, если указано, указывает команде на расширение схемы таблицы. Значение по умолчанию — false. Этот параметр применяется только к `.append` `.set-or-append` `set-or-replace` командам, и. Только разрешенные расширения схемы имеют дополнительные столбцы, добавленные в конец таблицы.|
|`recreate_schema`  | Логическое значение, которое. Указывает, может ли команда воссоздать схему таблицы, если она указана. Значение по умолчанию — false. Этот параметр применяется только к команде *Set-OR-REPLACE* . Этот параметр имеет приоритет над свойством extend_schema, если оба заданы|
|`folder`         | Папка, которая будет назначена таблице. Если таблица уже существует, это свойство запишет папку таблицы.|
|`ingestIfNotExists`   | Строковое значение, которое. Если указано, предотвращается прием успешных выполнений, если в таблице уже есть данные, помеченные `ingest-by:` тегом с тем же значением|
|`policy_ingestiontime`   | Значение типа Boolean. Указывает, следует ли включить [политику времени приема](../../management/ingestiontime-policy.md) для таблицы, созданной этой командой. Значение по умолчанию — true.|
|`tags`   | Строка JSON, указывающая, какие проверки должны выполняться во время приема|
|`docstring`   | Строка, задокументированная в таблице|

 Свойство, которое управляет поведением команды.

|Свойство        |Тип    |Описание:|
|----------------|--------|-----------------------------------------------------------------------------------------------------------------------------|
|`distributed`   |`bool`  |Указывает, что команда получает от всех узлов, которые выполняют запрос, параллельно. Значение по умолчанию — false.  См. примечания ниже.|

* *Куерйоркомманд*: текст запроса или команды элемента управления, результаты которого будут использоваться в качестве данных для приема.

> [!NOTE]
> `.show`Поддерживаются только команды управления.

**Замечания**

* `.set-or-replace`заменяет данные таблицы, если она существует. Он удаляет существующие сегменты данных или создает целевую таблицу, если она еще не существует.
  Схема таблицы будет сохранена, если для одного `extend_schema` из `recreate_schema` свойств или свойства приема не задано значение true. Если схема изменена, она происходит перед фактическим приемом данных в собственной транзакции. Невозможность приема данных не означает, что схема не была изменена.
* `.set-or-append``.append`команды и будут сохранять схему, если `extend_schema` свойство приема не имеет значение true. Если схема изменена, она происходит перед фактическим приемом данных в собственной транзакции. Невозможность приема данных не означает, что схема не была изменена.
* Мы рекомендуем ограничить объем данных для приема до 1 ГБ на операцию приема. При необходимости можно использовать несколько команд приема.
* Прием данных — это ресурсоемкие операции, которые могут повлиять на параллельные действия в кластере, включая выполнение запросов. Старайтесь не выполнять слишком много таких команд одновременно.
* При сопоставлении схемы результирующего набора с таблицей целевой таблицы сравнение основывается на типах столбцов. Имена столбцов не совпадают. Убедитесь, что столбцы схемы результатов запроса находятся в том же порядке, что и таблица. В противном случае данные будут поступать в неправильный столбец.
* Установка `distributed` флага в значение "true" полезно в том случае, если объем данных, формируемых запросом, имеет большой размер, превышает 1 ГБ, а запрос не требует сериализации, чтобы несколько узлов могли параллельно создавать выходные данные.
  Если результаты запроса невелики, не используйте этот флаг, так как он может не создавать большое количество небольших сегментов данных.

**Примеры** 

Создайте новую таблицу с именем «Рецентеррорс» в базе данных, которая имеет ту же схему, что и «Логстабле», и содержит все записи об ошибках за последний час.

```kusto
.set RecentErrors <|
   LogsTable
   | where Level == "Error" and Timestamp > now() - time(1h)
```

Создайте новую таблицу с именем "Олдекстентс" в базе данных, которая содержит один столбец "Екстентид", и содержит идентификаторы экстентов всех экстентов в базе данных, которые были созданы более чем за 30 дней раньше. База данных содержит существующую таблицу с именем «Мекстентс».

```kusto
.set async OldExtents <|
   MyExtents 
   | where CreatedOn < now() - time(30d)
   | project ExtentId
```

Добавьте данные в существующую таблицу с именем "Олдекстентс" в текущей базе данных, которая содержит один столбец "Екстентид", и содержит идентификаторы экстентов всех экстентов в базе данных, которые были созданы более чем за 30 дней раньше.
Пометьте новую область тегами `tagA` и `tagB` , основываясь на существующей таблице с именем «мекстентс».

```kusto
.append OldExtents with(tags='["TagA","TagB"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId
```

Добавьте данные в таблицу "Олдекстентс" в текущей базе данных или создайте таблицу, если она еще не существует. Пометьте новый экстент на `ingest-by:myTag` . Сделайте это только в том случае, если таблица еще не содержит экстент, помеченный как `ingest-by:myTag` , на основе существующей таблицы с именем "мекстентс".

```kusto
.set-or-append async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <|
   MyExtents
   | where CreatedOn < now() - time(30d)
   | project ExtentId
```

Замените данные в таблице "Олдекстентс" в текущей базе данных или создайте таблицу, если она еще не существует. Пометьте новый экстент на `ingest-by:myTag` .

```kusto
.set-or-replace async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId
```

Добавьте данные в таблицу "Олдекстентс" в текущей базе данных, устанавливая время создания экстентов на конкретный DateTime в прошлом.

```kusto
.append async OldExtents with(creationTime='2017-02-13T11:09:36.7992775Z') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

**Возврат выходных данных**
 
Возвращает сведения о экстентах, созданных из-за `.set` `.append` команды или.

**Пример выходных данных**

|екстентид |оригиналсизе |екстентсизе |CompressedSize |IndexSize |RowCount | 
|--|--|--|--|--|--|
|23a05ed6-376d-4119-b1fc-6493bcb05563 |1291 |5882 |1568 |4314 |10 |
