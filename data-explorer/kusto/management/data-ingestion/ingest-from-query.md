---
title: Прием запросов Kusto (Set, Append, replace) — Azure обозреватель данных
description: В этой статье описывается прием из запроса (. Set,. append,. Set-или-Append,. Set-или-Replace) в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
ms.openlocfilehash: cd9d0f9156387f3a42d41b000aefc9eac0793f9d
ms.sourcegitcommit: 188f89553b9d0230a8e7152fa1fce56c09ebb6d6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2020
ms.locfileid: "84512509"
---
# <a name="ingest-from-query-set-append-set-or-append-set-or-replace"></a>Прием из запроса (. Set,. append,. Set-или-Append,. Set-или-Replace)

Эти команды выполняют запрос или команду элемента управления и принимают результаты запроса в таблицу. Различие между этими командами заключается в том, как они обрабатывают существующие или несуществующие таблицы и данные:

|Get-Help          |Если таблица существует                     |Если таблица не существует                    |
|-----------------|------------------------------------|------------------------------------------|
|`.set`           |Команда завершается ошибкой.                  |Таблица создается и данные принимаются.|
|`.append`        |Данные добавляются в таблицу.      |Команда завершается ошибкой.                        |
|`.set-or-append` |Данные добавляются в таблицу.      |Таблица создается и данные принимаются.|
|`.set-or-replace`|Данные заменяют данные в таблице.|Таблица создается и данные принимаются.|

**Синтаксис**

`.set`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ...] `)` ] `<|` *Куерйоркомманд*

`.append`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ... `])` ] `<|` *Куерйоркомманд*

`.set-or-append`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ...] `)` ] `<|` *Куерйоркомманд*

`.set-or-replace`[ `async` ] *TableName* [ `with` `(` *PropertyName* `=` *propertyvalue* [ `,` ...] `)` ] `<|` *Куерйоркомманд*

**Аргументы**

* `async`: Если указано, команда немедленно возвращает значение и продолжает прием в фоновом режиме. Результаты выполнения команды будут содержать `OperationId` значение, которое затем можно использовать с `.show operations` командой для получения состояния завершения приема и результатов.
* *TableName*: имя таблицы для приема данных.
  Имя таблицы всегда указывается относительно базы данных в контексте.
* *PropertyName*, *propertyvalue*— любое количество свойств приема, влияющих на процесс приема.

 Поддерживаемые свойства приема:

|Свойство.        |Описание|
|----------------|-----------------------------------------------------------------------------------------------------------------------------|
|`creationTime`   | Значение DateTime (в формате строки ISO8601), используемое во время создания занятых экстентов данных. Если не указано, будет использоваться текущее значение (Now ()).|
|`extend_schema`  | Логическое значение, которое, если указано, указывает команде на расширение схемы таблицы (по умолчанию используется значение false). Этот параметр применяется только к командам. append. Set-или-Append и Set-или-Replace. Только допустимые расширения схемы содержат дополнительные столбцы, добавляемые в конец таблицы.|
|`recreate_schema`  | Логическое значение, которое указывает, может ли команда воссоздать схему таблицы (значение по умолчанию — false). Этот параметр применяется только к команде Set-или-Replace. Этот параметр имеет приоритет над свойством extend_schema, если оба заданы.|
|`folder`         | Папка, которая будет назначена таблице. Если таблица уже существует, это свойство переопределит папку таблицы.|
|`ingestIfNotExists`   | Строковое значение, которое, если указано, предотвращает успешность приема, если в таблице уже есть данные, помеченные тегом приема: с тем же значением.|
|`policy_ingestiontime`   | Логическое значение, которое (при наличии) указывает, следует ли включить [политику времени приема](../../management/ingestiontime-policy.md) для таблицы, созданной этой командой. Значение по умолчанию — true.|
|`tags`   | Строка JSON, которая указывает, какие проверки будут выполняться во время приема.|
|`docstring`   | Строка, задокументированная в таблице.|

  Кроме того, существует свойство, которое управляет поведением самой команды:

|Свойство.        |Type    |Описание:|
|----------------|--------|-----------------------------------------------------------------------------------------------------------------------------|
|`distributed`   |`bool`  |Указывает, что команда получает от всех узлов, которые выполняют запрос, параллельно. (Значение по умолчанию — `false` .)  См. примечания ниже.|

* *Куерйоркомманд*: текст запроса или команды элемента управления, результаты которого будут использоваться в качестве данных для приема.

> [!NOTE]
> `.show`Поддерживаются только команды управления.

**Замечания**

* `.set-or-replace`заменяет данные таблицы, если она существует (удаляет существующие сегменты данных), или создает целевую таблицу, если она еще не существует.
  Схема таблицы будет сохранена, если `extend_schema` `recreate_schema` для свойства или приема не задано значение `true` . Если схема изменена, это происходит перед фактическим приемом данных в собственной транзакции, поэтому сбой приема данных не означает, что схема не была изменена.
* `.set-or-append``.append`команды и сохраняют схему, если `extend_schema` свойство приема не имеет значение `true` . Если схема изменена, это происходит перед фактическим приемом данных в собственной транзакции, поэтому сбой приема данных не означает, что схема не была изменена.
* **Настоятельно рекомендуется** , чтобы данные для приема были ограничены размером менее 1 ГБ на операцию приема. При необходимости можно использовать несколько команд приема.
* Прием данных — это ресурсоемкие операции, которые могут повлиять на параллельные действия в кластере, включая выполнение запросов. Избегайте одновременного выполнения "слишком большого числа" таких команд.
* При сопоставлении схемы результирующего набора с таблицей целевой таблицы сравнение основывается на типах столбцов. Имена столбцов не совпадают, поэтому убедитесь, что столбцы схемы результатов запроса находятся в том же порядке, что и таблица, в противном случае данные будут поступать в неправильный столбец.
* Установка `distributed` флага `true` будет полезна, если объем данных, формируемых запросом, является большим (объемом 1 ГБ данных) **, а** запрос не требует сериализации (чтобы несколько узлов могли параллельно создавать выходные данные).
  Если результаты запроса невелики, не рекомендуется использовать этот флаг, так как это может привести к ненужному созданию большого количества небольших сегментов данных.

**Примеры** 

Создайте новую таблицу с именем "Рецентеррорс" в текущей базе данных, которая имеет ту же схему, что и "Логстабле", и содержит все записи об ошибках за последний час:

```kusto
.set RecentErrors <|
   LogsTable
   | where Level == "Error" and Timestamp > now() - time(1h)
```

Создайте новую таблицу с именем "Олдекстентс" в текущей базе данных, которая содержит один столбец ("Екстентид") и содержит идентификаторы экстентов всех экстентов в базе данных, которые были созданы более 30 дней назад на основе существующей таблицы с именем "Мекстентс":

```kusto
.set async OldExtents <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

Добавьте данные в существующую таблицу с именем "Олдекстентс" в текущей базе данных, которая содержит один столбец ("Екстентид") и содержит идентификаторы экстентов всех экстентов в базе данных, которые были созданы более 30 дней назад, и пометка нового экстента тегами `tagA` и `tagB` на основе существующей таблицы с именем "мекстентс":

```kusto
.append OldExtents with(tags='["TagA","TagB"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```
 
Добавьте данные в таблицу "Олдекстентс" в текущей базе данных (или создайте таблицу, если она еще не создана), при условии добавления нового экстента в `ingest-by:myTag` . Сделайте это только в том случае, если таблица еще не содержит экстент, помеченный как `ingest-by:myTag` , на основе существующей таблицы с именем "мекстентс":

```kusto
.set-or-append async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

Замените данные в таблице "Олдекстентс" в текущей базе данных (или создайте таблицу, если она еще не создана), разметив новую область с помощью `ingest-by:myTag` .

```kusto
.set-or-replace async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

Добавьте данные в таблицу "Олдекстентс" в текущей базе данных, установив время создания экстентов на конкретный DateTime в прошлом:

```kusto
.append async OldExtents with(creationTime='2017-02-13T11:09:36.7992775Z') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

**Возврат выходных данных**
 
Возвращает сведения о экстентах, созданных в результате выполнения `.set` `.append` команды или.

**Пример выходных данных**

|екстентид |оригиналсизе |екстентсизе |CompressedSize |IndexSize |RowCount | 
|--|--|--|--|--|--|
|23a05ed6-376d-4119-b1fc-6493bcb05563 |1291 |5882 |1568 |4314 |10 |