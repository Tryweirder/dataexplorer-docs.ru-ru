---
title: Прием из запросов Kusto (set, append, replace) в Azure Data Explorer
description: В этой статье описывается прием из запроса (.set, .append, .set-or-append, .set-or-replace) в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
ms.localizationpriority: high
ms.openlocfilehash: 18959e2387a1a0faf92261dc3c35eca0db44c158
ms.sourcegitcommit: f49e581d9156e57459bc69c94838d886c166449e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2020
ms.locfileid: "95512899"
---
# <a name="ingest-from-query-set-append-set-or-append-set-or-replace"></a>Прием из запроса (.set, .append, .set-or-append, .set-or-replace)

Эти команды выполняют запрос или управляющую команду и принимают результаты запроса в таблицу. Различие между этими командами заключается в том, как они обрабатывают существующие или несуществующие таблицы и данные.

|Команда          |Если таблица существует                     |Если таблица не существует                    |
|-----------------|------------------------------------|------------------------------------------|
|`.set`           |Команда завершается со сбоем                  |Таблица создается, а данные принимаются|
|`.append`        |Данные добавляются в таблицу      |Команда завершается со сбоем                        |
|`.set-or-append` |Данные добавляются в таблицу      |Таблица создается, а данные принимаются|
|`.set-or-replace`|Данные заменяют данные в таблице|Таблица создается, а данные принимаются|

**Синтаксис**

`.set` [`async`] *TableName* [`with` `(`*PropertyName* `=` *PropertyValue* [`,` ...]`)`] `<|` *QueryOrCommand*

`.append` [`async`] *TableName* [`with` `(`*PropertyName* `=` *PropertyValue* [`,` ...`])`] `<|` *QueryOrCommand*

`.set-or-append` [`async`] *TableName* [`with` `(`*PropertyName* `=` *PropertyValue* [`,` ...]`)`] `<|` *QueryOrCommand*

`.set-or-replace` [`async`] *TableName* [`with` `(`*PropertyName* `=` *PropertyValue* [`,` ...]`)`] `<|` *QueryOrCommand*

**Аргументы**

* `async` — если указан, команда немедленно возвращает результат и продолжает прием в фоновом режиме. Результаты выполнения команды будут включать в себя значение `OperationId`, которое затем можно использовать с командой `.show operations`, чтобы получить данные о состоянии завершения приема и его результаты.
* *TableName* — имя таблицы, в которую будут приниматься данные.
  Имя таблицы всегда связано с базой данных в контексте.
* *PropertyName*, *PropertyValue* — любое количество свойств приема, влияющих на процесс приема данных.

 Ниже приведены поддерживаемые свойства приема.

|Свойство        |Описание|
|----------------|-----------------------------------------------------------------------------------------------------------------------------|
|`creationTime`   | Значение даты и времени (в формате строки ISO8601), которое будет указано как время создания принятых экстентов данных. Если не указано, используется текущее значение (`now()`).|
|`extend_schema`  | Логическое значение, которое (при наличии) указывает команде расширить схему таблицы. Значение по умолчанию — false. Этот параметр применяется только в командах `.append`, `.set-or-append` и `set-or-replace`. Только разрешенные расширения схемы содержат дополнительные столбцы, добавляемые в конец таблицы.|
|`recreate_schema`  | Логическое значение, которое (при наличии) разрешает команде воссоздать схему таблицы. Значение по умолчанию — false. Этот параметр применяется только в команде *set-or-replace*. Этот параметр имеет приоритет над свойством extend_schema, если заданы оба свойства.|
|`folder`         | Папка, которая будет назначена таблице. Если таблица уже существует, это свойство перезапишет папку таблицы.|
|`ingestIfNotExists`   | Значение типа string, которое запрещает считать прием успешным, если в таблице уже есть данные с тегом `ingest-by:` и идентичным значением.|
|`policy_ingestiontime`   | Значение типа Boolean. При наличии указывает, следует ли включить [политику времени приема](../../management/ingestiontime-policy.md) для таблицы, созданной этой командой. Значение по умолчанию — true.|
|`tags`   | Строка JSON, которая указывает, какие проверки будут выполняться во время приема.|
|`docstring`   | Строка, документирующая таблицу.|

 Свойство, которое управляет поведением команды.

|Свойство        |Тип    |Описание|
|----------------|--------|-----------------------------------------------------------------------------------------------------------------------------|
|`distributed`   |`bool`  |Указывает, что команда принимает данные от всех узлов, выполняя запрос параллельно. Значение по умолчанию — false.  См. примечания ниже.|

* *QueryOrCommand* — текст запроса или управляющая команда, результаты которой будут использоваться в качестве данных для приема.

> [!NOTE]
> Поддерживаются только управляющие команды `.show`.

**Замечания**

* `.set-or-replace` заменяет данные в таблице, если она существует. Удаляет существующие сегменты данных или создает целевую таблицу, если она не существует.
  Схема таблицы будет сохранена, если только для одного из свойств приема `extend_schema` или `recreate_schema` не задано значение true. Если схема изменена, сохранение выполняется перед фактическим приемом данных в собственной транзакции. Невозможность приема данных не означает, что схема не была изменена.
* Команды `.set-or-append` и `.append` сохранят схему, если только для свойства приема `extend_schema` не задано значение true. Если схема изменена, сохранение выполняется перед фактическим приемом данных в собственной транзакции. Невозможность приема данных не означает, что схема не была изменена.
* Мы рекомендуем ограничить объем принимаемых данных значением не более 1 ГБ на операцию приема. При необходимости можно использовать несколько команд приема.
* Прием данных — это ресурсоемкая операция, которая может повлиять на параллельные действия в кластере, в том числе на выполнение запросов. Избегайте одновременного выполнения большого числа таких команд.
* При сопоставлении схемы результирующего набора со схемой целевой таблицы сравнение основывается на типах столбцов. При этом имена столбцов не совпадают. Убедитесь, что столбцы схемы результатов запроса расположены в том же порядке, что и столбцы таблицы. В противном случае данные будут приниматься некорректно (в другой столбец).
* Установите для флага `distributed` значение true, если объем данных, выдаваемых запросом, слишком велик (превышает 1 ГБ), а запрос не требует сериализации. Благодаря этому несколько узлов смогут параллельно выводить данные.
  Если размер результатов запроса невелик, не используйте этот флаг, так как это приведет к ненужному созданию множества небольших сегментов данных.

**Примеры** 

Создайте таблицу с именем :::no-loc text="RecentErrors"::: в базе данных, которая имеет ту же схему, что и :::no-loc text="LogsTable":::, и содержит все записи об ошибках за последний час.

```kusto
.set RecentErrors <|
   LogsTable
   | where Level == "Error" and Timestamp > now() - time(1h)
```

Создайте таблицу с именем OldExtents в базе данных, содержащую один столбец ExtentId с идентификаторами всех экстентов в базе данных, которые были созданы более чем 30 дней назад. База данных включает таблицу с именем MyExtents.

```kusto
.set async OldExtents <|
   MyExtents 
   | where CreatedOn < now() - time(30d)
   | project ExtentId
```

Добавьте данные в существующую таблицу с именем OldExtents в текущей базе данных, содержащей один столбец ExtentId с идентификаторами всех экстентов в базе данных, которые были созданы более чем 30 дней назад.
Присвойте новому экстенту теги `tagA` и `tagB` на основе существующей таблицы с именем MyExtents.

```kusto
.append OldExtents with(tags='["TagA","TagB"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId
```

Добавьте данные в таблицу OldExtents в текущей базе данных или создайте таблицу, если она не существует. Присвойте новому экстенту тег `ingest-by:myTag`. Сделайте это только в том случае, если таблица еще не содержит экстент с тегом `ingest-by:myTag` (на основе существующей таблицы с именем MyExtents).

```kusto
.set-or-append async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <|
   MyExtents
   | where CreatedOn < now() - time(30d)
   | project ExtentId
```

Замените данные в таблице OldExtents в текущей базе данных или создайте таблицу, если она не существует. Присвойте новому экстенту тег `ingest-by:myTag`.

```kusto
.set-or-replace async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId
```

Добавьте данные в таблицу OldExtents в текущей базе данных и задайте для созданных экстентов время создания, соответствующее определенному времени в прошлом.

```kusto
.append async OldExtents with(creationTime='2017-02-13T11:09:36.7992775Z') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

**Return output**
 
Возвращает сведения об экстентах, созданных в результате выполнения команд `.set` или `.append`.

**Пример выходных данных**

|ExtentId |OriginalSize |ExtentSize |CompressedSize |IndexSize |RowCount | 
|--|--|--|--|--|--|
|23a05ed6-376d-4119-b1fc-6493bcb05563 |1291 |5882 |1568 |4314 |10 |
