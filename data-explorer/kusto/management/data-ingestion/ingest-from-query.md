---
title: Ingest от запроса (.set, .append, .set-or-append, .set-or-replace) - Azure Data Explorer Документы Майкрософт
description: В этой статье описывается ingest из запроса (.set, .append, .set-or-append, .set-or-replace) в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/30/2020
ms.openlocfilehash: fb0bbb06bb8d28dd3951a7faedf55b0d84155301
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81521460"
---
# <a name="ingest-from-query-set-append-set-or-append-set-or-replace"></a>Проглокизирование из запроса (.set, .append, .set-or-append, .set-or-replace)

Эти команды выполняют запрос или команду управления и вовлая результаты запроса в таблицу. Разница между этими командами заключается в том, как они относятся к существующим или несуществующим таблицам и данным:

|Команда          |Если таблица существует                     |Если таблица не существует                    |
|-----------------|------------------------------------|------------------------------------------|
|`.set`           |Команда выходит из строя.                  |Таблица создается и данные попадает в систему.|
|`.append`        |Данные присваиваемы к таблице.      |Команда выходит из строя.                        |
|`.set-or-append` |Данные присваиваемы к таблице.      |Таблица создается и данные попадает в систему.|
|`.set-or-replace`|Данные заменяют данные в таблице.|Таблица создается и данные попадает в систему.|

**Синтаксис**

`.set``async`ТаблицаИмя -`with` `(` *PropertyName* `=` *PropertyValue* `,` *TableName* `)` `<|` *ЗапросИли*

`.append``async`ТаблицаИмя -`with` `(` *PropertyName* `=` *PropertyValue* ...`,` *TableName* `])` `<|` *ЗапросИли*

`.set-or-append``async`ТаблицаИмя -`with` `(` *PropertyName* `=` *PropertyValue* `,` *TableName* `)` `<|` *ЗапросИли*

`.set-or-replace``async`ТаблицаИмя -`with` `(` *PropertyName* `=` *PropertyValue* `,` *TableName* `)` `<|` *ЗапросИли*

**Аргументы**

* `async`: Если указано, команда немедленно вернется и продолжит проглатывание в фоновом режиме. Результаты команды будут включать `OperationId` значение, которое затем `.show operation` может быть использовано с командой для получения состояния завершения приема и результатов.
* *TableName*: Название таблицы для глотания данных.
  Имя таблицы всегда относительно базы данных в контексте.
* *PropertyName*, *PropertyValue*: Любое количество свойств приема, которые влияют на процесс приема.

 Поддерживаемые свойства приема:

|Свойство.        |Описание|
|----------------|-----------------------------------------------------------------------------------------------------------------------------|
|`creationTime`   | Значение времени датирования (отформатированное как строка ISO8601) для использования во время создания просачивания объемов данных. Если не указано, будет использоваться текущее значение (теперь()) .|
|`extend_schema`  | Значение Boolean, которое, если указано, поручает команде расширить схему таблицы (по умолчанию на ложные). Эта опция применяется только к командам .append .set-or-append и set-or-replace. Только допустимые расширения схемы содержат дополнительные столбцы, добавляемые в конец таблицы.|
|`recreate_schema`  | Значение Boolean, которое, если указано, описывает, может ли команда воссоздать схему таблицы (по умолчанию для ложных). Эта опция применяется только к команде "установка или замена". Этот параметр имеет приоритет над extend_schema свойством, если оба установлены.|
|`folder`         | Папка для обозначения таблицы. Если таблица уже существует, это свойство переопределяет папку таблицы.|
|`ingestIfNotExists`   | Значение строки, если указано, предотвращает проглатывание, если в таблице уже есть данные, отмеченные ingest-by: тег с тем же значением.|
|`policy_ingestiontime`   | Логическое значение, которое (при наличии) указывает, следует ли включить [политику времени приема](../../management/ingestiontime-policy.md) для таблицы, созданной этой командой. Значение по умолчанию — true.|
|`tags`   | Строка JSON, которая указывает, какие проверки будут выполняться во время приема.|
|`docstring`   | Строка, документирующая таблицу.|

  Кроме того, есть свойство, которое контролирует поведение самой команды:

|Свойство        |Тип    |Описание|
|----------------|--------|-----------------------------------------------------------------------------------------------------------------------------|
|`distributed`   |`bool`  |Означает, что команда глотает из всех узлов, исполняющих запрос параллельно. (По умолчанию до `false`.)  Смотрите замечания ниже.|

* *QueryOrCommand*: Текст запроса или команда управления, результаты которой будут использоваться в качестве данных для проглотания.

> [!NOTE]
> Поддерживаются только `.show` команды управления.

**Замечания**

* `.set-or-replace`заменяет данные таблицы, если она существует (отбрасывает существующие осколки данных) или создает целевую таблицу, если она еще не существует.
  Схема таблицы будет сохранена, `extend_schema` если `recreate_schema` одно из свойств `true`или свойство приема не установлено. Если схема изменена, это происходит до фактического проглатывания данных в собственной транзакции, поэтому неспособность глотать данные не означает, что схема не была изменена.
* `.set-or-append`и `.append` команды сохранят схему, `extend_schema` если свойство приема `true`не будет установлено. Если схема изменена, это происходит до фактического проглатывания данных в собственной транзакции, поэтому неспособность глотать данные не означает, что схема не была изменена.
* Настоятельно **рекомендуется, чтобы** данные для приема были ограничены менее чем 1 ГБ на операцию по проглатывания. При необходимости могут использоваться несколько команд приема.
* Потребление данных — это ресурсоемкая операция, которая может повлиять на параллельные действия кластера, включая выполнение запросов. Избегайте запуска "слишком много" таких команд вместе в то же время.
* При сопоставлении схемы набора результатов с целевой таблицей сравнение основано на типах столбцов. Нет соответствия имен столбцов, поэтому убедитесь, что столбцы схемы результатов запроса находятся в том же порядке, что и таблица, в противном случае данные будут попаданы в неправильный столбец.
* Установка `distributed` флага `true` на это полезно, когда объем данных, производимых запросом, велик (превышает 1 ГБ данных) **и** запрос не требует сериализации (так что несколько узлов могут производить выход параллельно).
  Когда результаты запроса малы, не рекомендуется использовать этот флаг, так как он может генерировать много небольших осколков данных напрасно.

**Примеры** 

Создайте новую таблицу под названием "Недавние ошибки" в текущей базе данных, которая имеет ту же схему, что и "LogsTable" и содержит все записи ошибок последнего часа:

```kusto
.set RecentErrors <|
   LogsTable
   | where Level == "Error" and Timestamp > now() - time(1h)
```

Создайте новую таблицу под названием "OldExtents" в текущей базе данных, которая имеет один столбец ("ExtentId") и содержит идентификаторы всех уровней в базе данных, которые были созданы более 30 дней назад, на основе существующей таблицы под названием "MyExtents":

```kusto
.set async OldExtents <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

Придатите данные к существующей таблице под названием "OldExtents" в текущей базе данных, которая имеет один столбец ("ExtentId") и содержит идентификаторы всех уровней в базе данных, которые были созданы более 30 дней назад, при этом пометки новой степени с тегами `tagA` и `tagB`, на основе существующей таблицы под названием "MyExtents":

```kusto
.append OldExtents with(tags='["TagA","TagB"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```
 
Придатите данные к таблице "OldExtents" в текущей базе данных (или создайте таблицу, если она еще не существует), при этом пометка новой степени с `ingest-by:myTag`помощью . Сделайте это только в том случае, если `ingest-by:myTag`таблица уже не содержит степень, помеченную с помощью существующей таблицы под названием "MyExtents":

```kusto
.set-or-append async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

Замените данные в таблице "OldExtents" в текущей базе данных (или создайте таблицу, `ingest-by:myTag`если она еще не существует), при этом пометив новую степень с помощью .

```kusto
.set-or-replace async OldExtents with(tags='["ingest-by:myTag"]', ingestIfNotExists='["myTag"]') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

Прилагая данные к таблице "OldExtents" в текущей базе данных, устанавливая время создания созданного размера (ы) к определенному времени дат в прошлом:

```kusto
.append async OldExtents with(creationTime='2017-02-13T11:09:36.7992775Z') <| 
   MyExtents 
   | where CreatedOn < now() - time(30d) 
   | project ExtentId     
```

**Выход возврата**
 
Возвращает информацию о масштабах, созданных в `.set` результате команды или `.append` команды.

**Вывод примера**

|ExtentId |OriginalSize |ExtentSize |СжатыйРазмер |IndexSize |RowCount | 
|--|--|--|--|--|--|
|23a05ed6-376d-4119-b1fc-6493bcb05563 |1291 |5882 |1568 |4314 |10 |