---
title: Курсоры баз данных - Azure Data Explorer Документы Майкрософт
description: В этой статье описаны курсоры базы данных в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.openlocfilehash: 90ec677a7eaf1f326509828b5415b022742fd9ed
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81521324"
---
# <a name="database-cursors"></a>Курсоры базы данных

**Курсор базы данных** — это объект уровня базы данных, который позволяет запрашивать базу данных несколько раз и получать последовательные результаты, даже если параллельно с запросами происходят операции по сбору данных/хранению данных.

Курсоры баз данных предназначены для решения двух важных сценариев:

* Возможность повторять один и тот же запрос несколько раз и получать одни и те же результаты, если запрос указывает на "один и тот же набор данных".

* Возможность выполнения запроса "точно один раз" (запрос, который "видит" только данные, которые предыдущий запрос не видел, потому что данные были недоступны тогда).
   Это позволяет, например, итерировать все вновь прибывшие данные в таблице, не опасаясь обработки одной и той же записи дважды или пропуска записей по ошибке.

Курсор базы данных представлен на языке запросов как масштабируемое значение типа. `string` Фактическое значение должно считаться непрозрачным, и нет никакой поддержки для любой операции, кроме сохранения ее стоимости и/или использования функций курсора, отмеченных ниже.

## <a name="cursor-functions"></a>Функции для работы с курсорами

Kusto предоставляет три функции, чтобы помочь реализовать два сценария выше:

* [cursor_current ()](../query/cursorcurrent.md): Используйте эту функцию для получения текущего значения курсора базы данных.
   Это значение можно использовать в качестве аргумента в сторону двух других функций.
   Эта функция также имеет синоним, `current_cursor()`.

* [cursor_after (rhs:string)](../query/cursorafterfunction.md): Эта специальная функция может быть использована на записях таблиц, в которых [включена политика IngestionTime.](ingestiontime-policy.md) Он возвращает скалярное `bool` значение типа, указывая, происходит ли значение курсора `ingestion_time()` базы данных записи после значения курсора `rhs` базы данных.

* [cursor_before_or_at (rhs:string)](../query/cursorbeforeoratfunction.md): Эта специальная функция может быть использована на записях таблицы, в которых [включена политика IngestionTime.](ingestiontime-policy.md) Он возвращает скалярное `bool` значение типа, указывая, происходит ли значение курсора `ingestion_time()` базы данных записи после значения курсора `rhs` базы данных.

Две специальные`cursor_after` функции `cursor_before_or_at`(и ) также имеют побочный эффект: Когда они используются, Kusto будет `@ExtendedProperties` исходить **текущее значение курсора базы данных** в набор результатов запроса. Название свойства для курсора, `Cursor`и его значение `string`является одним. Пример:

```json
{"Cursor" : "636040929866477946"}
```

## <a name="restrictions"></a>Ограничения

Курсоры баз данных могут использоваться только со таблицами, для которых включена [политика IngestionTime.](ingestiontime-policy.md) Каждая запись в такой таблице связана со значением курсора базы данных, действовававшее при поимке записи, и поэтому можно использовать функцию [ingestion_time().](../query/ingestiontimefunction.md)

Объект курсора базы данных не имеет значимого значения, если только база данных не имеет хотя бы одну таблицу с определенной [политикой IngestionTime.](ingestiontime-policy.md)
Кроме того, гарантируется только обновление этого значения по мере необходимости по мере необходимости в таких таблицах и запусказапросов, которые ссылаются на такие таблицы. В других случаях его могут обновлять или нет.

Процесс проглатывания сначала фиксирует данные (так что он доступен для запроса), и только после этого назначает фактическое значение курсора каждой записи. Это означает, что если попытаться запросить данные сразу после завершения приема с помощью курсора базы данных, результаты могут еще не включать последние добавленные записи, поскольку они еще не назначены значением курсора. Аналогичным образом, повторное извлечение текущего значения курсора базы данных может вернуть одно и то же значение (даже если проглатывание было сделано между ними), поскольку только коммит курсора обновит его значение.

## <a name="example-processing-of-records-exactly-once"></a>Пример: Обработка записей ровно один раз

Предположим `Employees` таблицу `[Name, Salary]`со схемой .
Для непрерывной обработки новых записей по мере их попадания в таблицу используйте следующую процедуру:

```kusto
// [Once] Enable the IngestionTime policy on table Employees
.set table Employees policy ingestiontime true

// [Once] Get all the data that the Employees table currently holds 
Employees | where cursor_after('')

// The query above will return the database cursor value in
// the @ExtendedProperties result set. Lets assume that it returns
// the value '636040929866477946'

// [Many] Get all the data that was added to the Employees table
// since the previous query was run using the previously-returned
// database cursor 
Employees | where cursor_after('636040929866477946') // -> 636040929866477950

Employees | where cursor_after('636040929866477950') // -> 636040929866479999

Employees | where cursor_after('636040929866479999') // -> 636040939866479000
```