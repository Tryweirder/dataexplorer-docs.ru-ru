---
title: Курсоры базы данных — Azure обозреватель данных
description: В этой статье описываются курсоры базы данных в Azure обозреватель данных.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 02/13/2020
ms.openlocfilehash: 75dc0aa0ff23bfb4f08be9fac84fa34cf9526508
ms.sourcegitcommit: 8e097319ea989661e1958efaa1586459d2b69292
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/15/2020
ms.locfileid: "84780632"
---
# <a name="database-cursors"></a>Курсоры базы данных

**Курсор базы данных** — это объект уровня базы данных, позволяющий несколько раз запрашивать базу данных. Вы получите единообразные результаты, даже если во время выполнения запросов выполняются операции, выполняемые `data-append` `data-retention` параллельно.

Курсоры базы данных предназначены для решения двух важных сценариев:

* Возможность повторять один и тот же запрос несколько раз и получает те же результаты, если запрос указывает на один набор данных.

* Возможность создания запроса «ровно один раз». Этот запрос «видит» данные, которые не отображаются в предыдущем запросе, так как данные не были доступны.
   Запрос позволяет выполнить итерацию, например, с помощью всех вновь полученных данных в таблице, не опасаясь обработки одной и той же записи дважды или пропуская записи по ошибке.

Курсор базы данных представлен на языке запросов как скалярное значение типа `string` . Фактическое значение должно считаться непрозрачным и не поддерживать никаких операций, кроме сохранения ее значения, или использовать функции курсора, указанные ниже.

## <a name="cursor-functions"></a>Функции для работы с курсорами

Kusto предоставляет три функции для реализации двух описанных выше сценариев.

* [cursor_current ()](../query/cursorcurrent.md): Эта функция используется для получения текущего значения курсора базы данных.
   Это значение можно использовать в качестве аргумента для двух других функций.
   Эта функция также имеет синоним, `current_cursor()` .

* [cursor_after (RHS: String)](../query/cursorafterfunction.md). эту специальную функцию можно использовать для записей таблицы, для которых включена [Политика инжестионтиме](ingestiontime-policy.md) . Он возвращает скалярное значение типа `bool` , указывающее, `ingestion_time()` приходится ли значение курсора базы данных записи после `rhs` значения курсора базы данных.

* [cursor_before_or_at (RHS: String)](../query/cursorbeforeoratfunction.md). эту специальную функцию можно использовать для записей таблицы, для которых включена [Политика инжестионтиме](ingestiontime-policy.md) . Он возвращает скалярное значение типа `bool` , указывающее, `ingestion_time()` приходится ли значение курсора базы данных записи после `rhs` значения курсора базы данных.

Две специальные функции ( `cursor_after` и `cursor_before_or_at` ) также имеют побочные эффекты: когда они используются, Kusto выводит **Текущее значение курсора базы данных** в `@ExtendedProperties` результирующий набор запроса. Имя свойства курсора — `Cursor` , а его значение — Single `string` . 

Пример:

```json
{"Cursor" : "636040929866477946"}
```

## <a name="restrictions"></a>Ограничения

Курсоры базы данных можно использовать только с таблицами, для которых включена [Политика инжестионтиме](ingestiontime-policy.md) . Каждая запись в такой таблице связана со значением курсора базы данных, который действовал при приеме записи.
Таким образом, можно использовать функцию [ingestion_time ()](../query/ingestiontimefunction.md) .

Объект курсора базы данных не имеет осмысленного значения, если только в базе данных не определена хотя бы одна таблица с определенной [политикой инжестионтиме](ingestiontime-policy.md) .
Это значение гарантированно обновляется, как требуется для журнала приема, в такие таблицы и запросы, которые ссылаются на эти таблицы. В других случаях это может быть или не может быть обновлено.

Процесс приема сначала фиксирует данные, чтобы они были доступны для выполнения запросов, а затем назначает фактическое значение курсора каждой записи. Если вы попытаетесь запросить данные сразу после завершения приема с помощью курсора базы данных, результаты могут еще не включать последние добавленные записи, так как им еще не было присвоено значение курсора. Кроме того, многократное получение значения курсора текущей базы данных может вернуть одно и то же значение, даже если прием был выполнен между, так как только фиксация курсора может обновить его значение.

## <a name="example-processing-records-exactly-once"></a>Пример. обработка записей только один раз

Для таблицы `Employees` со схемой `[Name, Salary]` для непрерывной обработки новых записей по мере их приема в таблицу используйте следующую процедуру.

```kusto
// [Once] Enable the IngestionTime policy on table Employees
.set table Employees policy ingestiontime true

// [Once] Get all the data that the Employees table currently holds 
Employees | where cursor_after('')

// The query above will return the database cursor value in
// the @ExtendedProperties result set. Lets assume that it returns
// the value '636040929866477946'

// [Many] Get all the data that was added to the Employees table
// since the previous query was run using the previously-returned
// database cursor 
Employees | where cursor_after('636040929866477946') // -> 636040929866477950

Employees | where cursor_after('636040929866477950') // -> 636040929866479999

Employees | where cursor_after('636040929866479999') // -> 636040939866479000
```
