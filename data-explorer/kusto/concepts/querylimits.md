---
title: Ограничения запросов — обозреватель данных Azure
description: В этой статье описываются ограничения запросов в обозреватель данных Azure.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: alexans
ms.service: data-explorer
ms.topic: reference
ms.date: 03/12/2020
ms.openlocfilehash: ee36823bb3f730a12f7ad2d1febe91439d4a2aad
ms.sourcegitcommit: 898f67b83ae8cf55e93ce172a6fd3473b7c1c094
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "92343289"
---
# <a name="query-limits"></a>Ограничения на запросы

Kusto — это нерегламентированный механизм запросов, который размещает большие наборы данных и пытается удовлетворить запросы, задерживая все необходимые данные в памяти.
Существует риск, что запросы будут монопольно заключаться в ресурсах службы без ограничений. Kusto предоставляет ряд встроенных функций защиты в виде ограничений по умолчанию для запросов. Если вы собираетесь удалить эти ограничения, сначала определите, действительно ли вы получаете какое бы то ни было значение.

## <a name="limit-on-query-concurrency"></a>Ограничение на параллелизм запросов

**Параллелизм запросов**  — это ограничение, которое кластер накладывает на ряд запросов, выполняющихся в одно и то же время.

* Значение по умолчанию для ограничения параллелизма запросов зависит от кластера SKU, на котором он работает, и вычисляется следующим образом: `Cores-Per-Node x 10` .
  * Например, для кластера, настроенного на SKU D14v2, где каждый компьютер имеет 16 виртуальных ядер, ограничение параллелизма запросов по умолчанию равно `16 cores x10 = 160` .
* Значение по умолчанию можно изменить, настроив [политику регулирования запросов](../management/query-throttling-policy.md). 
  * Фактическое число запросов, которые могут выполняться одновременно в кластере, зависит от различных факторов. Наиболее главными факторами являются SKU кластера, доступные ресурсы кластера и шаблоны запросов. Политику регулирования запросов можно настроить на основе нагрузочных тестов, выполняемых в рабочих шаблонах запросов.

## <a name="limit-on-result-set-size-result-truncation"></a>Ограничение на размер результирующего набора (усечение результата)

**Усечение результатов** — это ограничение, установленное по умолчанию для результирующего набора, возвращаемого запросом. Kusto ограничивает число записей, возвращаемых клиенту, до **500 000**, а общий размер данных для этих записей — **64 МБ**. При превышении какого-либо из этих ограничений запрос завершается ошибкой "частичный сбой запроса". Превышение общего размера данных приведет к возникновению исключения с сообщением:

```
The Kusto DataEngine has failed to execute a query: 'Query result set has exceeded the internal data size limit 67108864 (E_QUERY_RESULT_SET_TOO_LARGE).'
```

Превышение числа записей приведет к сбою с исключением, которое говорит:

```
The Kusto DataEngine has failed to execute a query: 'Query result set has exceeded the internal record count limit 500000 (E_QUERY_RESULT_SET_TOO_LARGE).'
```

Существует несколько стратегий, связанных с этой ошибкой.

* Уменьшите размер результирующего набора, изменив запрос, чтобы возвращались только интересные данные. Эта стратегия полезна, если первоначальный неудачный запрос является слишком широким. Например, запрос не выполняет проекцию ненужных столбцов данных.
* Уменьшите размер результирующего набора путем сдвига обработки после запроса, например агрегатов, в сам запрос. Стратегия полезна в сценариях, где выходные данные запроса подаются в другую систему обработки, а затем — дополнительные агрегаты.
* Если требуется экспортировать большие наборы данных из службы, переключитесь с запросов на использование [экспорта данных](../management/data-export/index.md) .
* Попросите службы отключить этот предел запросов с помощью `set` приведенных ниже инструкций или флагов в [свойствах запроса клиента](../api/netfx/request-properties.md).

Ниже приведены методы уменьшения размера результирующего набора, создаваемого запросом.

* Используйте группу [оператор суммирования](../query/summarizeoperator.md) и выполните статистическое вычисление по аналогичным записям в выходных данных запроса. Потенциально выборке некоторых столбцов с помощью [статистической функции Any](../query/any-aggfunction.md).
* Используйте [оператор Take](../query/takeoperator.md) для выборки выходных данных запроса.
* Используйте [функцию SUBSTRING](../query/substringfunction.md) для удаления столбцов с широкими текстовыми столбцами.
* Используйте [оператор Project](../query/projectoperator.md) для удаления неинтересного столбца из результирующего набора.

Усечение результатов можно отключить с помощью `notruncation` параметра запроса.
Рекомендуется по-прежнему использовать некоторую форму ограничения.

Пример:

```kusto
set notruncation;
MyTable | take 1000000
```

Кроме того, можно более детально контролировать усечение результатов, установив значение `truncationmaxsize` (максимальный размер данных в байтах, значение по умолчанию — 64 МБ) и `truncationmaxrecords` (максимальное число записей, значение по умолчанию — 500 000). Например, следующий запрос задает усечение результатов в 1 105 записей или 1 МБ в зависимости от того, какое из этих значений превышено.

```kusto
set truncationmaxsize=1048576;
set truncationmaxrecords=1105;
MyTable | where User=="UserId1"
```

Удаление предельного усечения результатов означает, что вы собираетесь переместить данные большого объема из Kusto.

Можно удалить предельный результат усечения в целях экспорта с помощью `.export` команды или последующего агрегата. При выборе более поздней статистической обработки рассмотрите возможность объединения с помощью Kusto.

Kusto предоставляет ряд клиентских библиотек, которые могут выполнять "бесконечно большие" результаты, перепотокая их в вызывающий объект. Используйте одну из этих библиотек и настройте ее в режиме потоковой передачи. Например, используйте клиент .NET Framework (Microsoft. Azure. Kusto. Data) и задайте для свойства потоковой передачи строки подключения *значение true*или используйте вызов *ExecuteQueryV2Async ()* , который всегда создает потоки результатов.

Усечение результата применяется по умолчанию, а не только к потоку результата, возвращенному клиенту. Он также применяется по умолчанию к любому вложенному запросу, который один кластер вызывает другому кластеру в межкластерном запросе, с аналогичными эффектами.

## <a name="limit-on-memory-per-iterator"></a>Ограничение памяти на итератор

**Максимальное количество памяти для итератора результирующего набора** — еще один предел, используемый Kusto для защиты от запросов с неограниченным количеством. Это ограничение, представленное параметром запроса `maxmemoryconsumptionperiterator` , задает верхнюю границу объема памяти, которую может удерживать один итератор результирующего набора плана запроса. Это ограничение применяется к конкретным итераторам, которые не являются потоковой передачей по природе, например `join` .) Ниже приведено несколько сообщений об ошибках, которые будут возвращаться в ситуации, когда происходит следующее:

```
The ClusterBy operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete E_RUNAWAY_QUERY.

The DemultiplexedResultSetCache operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The ExecuteAndCache operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The HashJoin operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The Sort operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The Summarize operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The TopNestedAggregator operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The TopNested operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).
```

По умолчанию это значение равно 5 ГБ. Вы можете увеличить это значение до половины физической памяти компьютера:

```kusto
set maxmemoryconsumptionperiterator=68719476736;
MyTable | ...
```

Во многих случаях превышение этого ограничения можно избежать, выполнив выборку набора данных. В двух приведенных ниже запросах показано, как выполнить выборку. Первый — это статистическая выборка, использующая генератор случайных чисел). Вторая — детерминированная выборка, которая выполняется путем хэширования некоторого столбца из набора данных, обычно с определенным ИДЕНТИФИКАТОРом.

```kusto
T | where rand() < 0.1 | ...

T | where hash(UserId, 10) == 1 | ...
```

## <a name="limit-on-memory-per-node"></a>Ограничение памяти на узел

**Максимальный объем памяти для каждого запроса на узел** — это еще один предел, используемый для защиты от запросов с превышением предельного числа. Это ограничение, представленное параметром запроса `max_memory_consumption_per_query_per_node` , задает верхнюю границу объема памяти, которую можно использовать на одном узле для конкретного запроса.

```kusto
set max_memory_consumption_per_query_per_node=68719476736;
MyTable | ...
```

## <a name="limit-on-accumulated-string-sets"></a>Ограничение на накопленные наборы строк

В различных операциях запроса Kusto необходимо «собрать» строковые значения и зафиксировать их внутренним образом перед началом получения результатов. Эти накопленные наборы строк ограничены размером и количеством элементов, которые они могут содержать. Кроме того, каждая отдельная строка не должна превышать определенный предел.
Превышение одного из этих ограничений приведет к одной из следующих ошибок:

```
Runaway query (E_RUNAWAY_QUERY). (message: 'Accumulated string array getting too large and exceeds the limit of ...GB (see https://aka.ms/kustoquerylimits)')

Runaway query (E_RUNAWAY_QUERY). (message: 'Accumulated string array getting too large and exceeds the maximum count of ..GB items (see http://aka.ms/kustoquerylimits)')
```

В настоящее время нет переключателя для увеличения максимального размера набора строк.
В качестве обходного решения измените запрос, чтобы уменьшить объем данных, которые должны быть помещены в буфер. Можно проецировать ненужные столбцы, прежде чем они будут использоваться операторами, такими как соединение и формирование сводных данных. Также можно использовать стратегию запросов с [случайным](../query/shufflequery.md) использованием.

## <a name="limit-execution-timeout"></a>Ограничить время ожидания выполнения

**Время ожидания сервера** — это время ожидания на стороне службы, применяемое ко всем запросам.
Время ожидания выполнения запросов (команды запросов и управления) применяется в нескольких точках в Kusto:

* Клиентская библиотека (если используется)
* Конечная точка службы, которая принимает запрос
* обработчик службы, обрабатывающий запрос

По умолчанию для запросов установлено время ожидания в четыре минуты, а для команд управления — 10 минут. При необходимости это значение можно увеличить (с ограниченным интервалом в один час).

* При запросе с помощью Kusto. Explorer используйте **Сервис** &gt; **Параметры**_ &gt; _*Connections* *  &gt; **запрос время ожидания сервера**.
* Программно, задайте `servertimeout` для свойства запроса клиента значение типа `System.TimeSpan` вплоть до часа.

**Примечания об истечении времени ожидания**

* На стороне клиента время ожидания применяется к создаваемому запросу до тех пор, пока ответ не будет поступает клиенту. Время, затрачиваемое на чтение полезных данных на клиенте, не рассматривается как часть времени ожидания. Это зависит от того, насколько быстро вызывающая сторона извлекает данные из потока.
* Кроме того, на стороне клиента фактически использованное значение времени ожидания немного выше, чем значение времени ожидания сервера, запрошенное пользователем. Это различие заключается в том, чтобы разрешить сетевые задержки.
* Чтобы автоматически использовать максимально допустимое время ожидания запроса, задайте для свойства "запрос клиента" значение `norequesttimeout` `true` .

<!--
  Request timeout can also be set using a set statement, but we don't mention
  it here since it shouldn't be used in production scenarios.
-->

## <a name="limit-on-query-cpu-resource-usage"></a>Ограничение использования ресурсов ЦП для запросов

Kusto позволяет выполнять запросы и использовать столько ресурсов ЦП, сколько использует кластер. Он пытается выполнить адекватный циклический перебор запросов, если выполняется более одного. Этот метод обеспечивает лучшую производительность для специальных запросов.
В других случаях может потребоваться ограничить ресурсы ЦП, используемые для конкретного запроса. Например, при выполнении «фонового задания» система может допускать большие задержки, чтобы обеспечить высокий приоритет параллельных запросов ad-hoc.

Kusto поддерживает указание двух [свойств клиентского запроса](../api/netfx/request-properties.md) при выполнении запроса. Свойства  *query_fanout_threads_percent* и *query_fanout_nodes_percent*.
Оба свойства — это целые числа, которые по умолчанию имеют максимальное значение (100), но могут быть сокращены для конкретного запроса на какое-либо другое значение. 

Первый, *query_fanout_threads_percent*, управляет коэффициентом ветвление для использования потоков. Если это 100%, кластер будет назначать все ЦП на каждом узле. Например, 16 ЦП в кластере, развернутом на узлах Azure D14. Если это 50%, то будет использоваться половина ЦП и т. д. Числа округляются вплоть до целого, поэтому его можно легко установить в 0. Во втором, *query_fanout_nodes_percent*, определяет, сколько узлов запросов в кластере следует использовать для каждой операции распределения вложенных запросов. Он работает аналогичным образом.

## <a name="limit-on-query-complexity"></a>Ограничение на сложность запроса

Во время выполнения запроса текст запроса преобразуется в дерево реляционных операторов, представляющих запрос.
Если глубина дерева превышает внутреннее пороговое значение на нескольких тысячах уровней, запрос считается слишком сложным для обработки и завершается с кодом ошибки. Ошибка указывает на то, что дерево реляционных операторов превышает пределы.
Ограничения превышаются из-за запросов с длинными списками бинарных операторов, Объединенных в цепочку. Пример:

```kusto
T 
| where Column == "value1" or 
        Column == "value2" or 
        .... or
        Column == "valueN"
```

В этом конкретном случае перепишите запрос с помощью [`in()`](../query/inoperator.md) оператора.

```kusto
T 
| where Column in ("value1", "value2".... "valueN")
```
