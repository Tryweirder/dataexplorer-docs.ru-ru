---
title: Ограничения запросов - Azure Data Explorer Документы Майкрософт
description: В этой статье описаны ограничения запросов в Azure Data Explorer.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/12/2020
ms.openlocfilehash: 437e9781b9e29db7496292ba6a416f6e0c769e8b
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81523075"
---
# <a name="query-limits"></a>Ограничения на запросы

Поскольку Kusto является механизмом специальных запросов, который размещает большие наборы данных и пытается удовлетворить запросы, удерживая все соответствующие данные в памяти, существует врожденный риск того, что запросы будут монополизировать ресурсы службы без границ. Kusto предоставляет ряд встроенных защит в виде ограничений запросов по умолчанию.

## <a name="limit-on-query-concurrency"></a>Ограничение на параллелизм запроса

**Совалюту запроса** — это ограничение, которое кластер налагает на количество запросов, запущенных одновременно.
Значение по умолчанию лимита параллелизма запроса зависит от кластера SKU, на который он работает, и рассчитывается как: `Cores-Per-Node x 10`. Например, для кластера, настроенного на SKU D14v2, где каждая машина имеет 16 vCores, лимит `16 cores x10 = 160`по умолчанию.
Значение по умолчанию может быть изменено путем создания подтверждающего билета. В будущем этот элемент управления также будет подвергаться через команду управления.

## <a name="limit-on-result-set-size-result-truncation"></a>Ограничение размера набора результата (усечение результата)

**Усечение результата** — это ограничение, установленное по умолчанию для набора результатов, возвращенного запросом. Kusto ограничивает количество записей, возвращенных клиенту, **до 500 000,** а общая память этих записей до **64 МБ.** При превышении одного из этих ограничений запрос завершается с "частичным сбоем запроса". Превышение общей памяти будет генерировать исключение с сообщением:

```
The Kusto DataEngine has failed to execute a query: 'Query result set has exceeded the internal data size limit 67108864 (E_QUERY_RESULT_SET_TOO_LARGE).'
```

Превышение числа записей не удастся с исключением, которое говорит:

```
The Kusto DataEngine has failed to execute a query: 'Query result set has exceeded the internal record count limit 500000 (E_QUERY_RESULT_SET_TOO_LARGE).'
```

Существует ряд стратегий борьбы с этой ошибкой:

* Уменьшение размера набора результата путем изменения запроса, чтобы не возвращать неинтересные данные. Это обычно полезно, когда первоначальный (неудачный) запрос слишком "широкий" (например, он не проецирует не нужные столбцы данных).
* Уменьшение размера набора результатов путем переноса обработки постзапросов (например, агрегации) в сам запрос. Это полезно в сценариях, когда выход запроса подается в другую систему обработки, которая затем выполняет дополнительные агрегации. 
* Переход от запросов к использованию [экспорта данных.](../management/data-export/index.md)
   Это уместно, когда требуется экспортировать большие наборы данных из службы.
* Проинструктируйте службу для подавления этого лимита запроса.

Общие методы уменьшения размера набора результатов, производимые запросом:

* Использование [группы обобщений оператора](../query/summarizeoperator.md) и агрегирования по аналогичным записям в выходе запроса, потенциально выборка некоторых столбцов с использованием [любой функции агрегации.](../query/any-aggfunction.md)
* Использование [оператора take](../query/takeoperator.md) для опробование вывода запроса.
* Использование [функции подстрина](../query/substringfunction.md) для обрезки широких столбцов свободного текста.
* Использование [оператора проекта](../query/projectoperator.md) для отбросилюбои любого неинтересного столбца из набора результатов.

Можно отключить усечение результата, используя опцию запроса. `notruncation` Настоятельно рекомендуется, чтобы в этом случае, некоторые формы ограничения по-прежнему введены в действие. Пример:

```kusto
set notruncation;
MyTable | take 1000000
```

Кроме того, можно иметь более изысканный контроль над усечением результатов, установив значение `truncationmaxsize` (максимальный `truncationmaxrecords` размер данных в байтах, по умолчанию до 64 МБ) и (максимальное количество записей, по умолчанию до 500 000). Например, следующий запрос устанавливает усечение результатов либо на 1105 записях, либо на 1 МБ, в зависимости от того, что будет превышено:

```kusto
set truncationmaxsize=1048576;
set truncationmaxrecords=1105;
MyTable | where User=="Ploni"
```

Библиотеки клиентов Kusto в настоящее время предполагают существование этого предела. В то время как вы можете увеличить лимит без границ, в конечном итоге вы достигнете пределов клиента, которые в настоящее время не настраиваются. Одним из возможных обходных средств является прямое программное решение для контракта REST API и реализация потокового парзера для результатов запроса Kusto. Сообщите команде Kusto, если вы столкнетесь с этой проблемой, чтобы мы могли расставить приоритеты потокового клиента надлежащим образом.

Усечение результата применяется по умолчанию, а не только к потоку результатов, возвращенному клиенту; он также применяется по умолчанию к любому подзапросу, который один кластер Kusto выдает другому кластеру Kusto в кросс-кластерном запросе с аналогичными эффектами.

## <a name="limit-on-memory-per-iterator"></a>Ограничение памяти на итератор

**Максимальная память на итератор набора результатов** является еще одним ограничением, используемым Kusto для защиты от "беглых" запросов. Это ограничение (представленное `maxmemoryconsumptionperiterator`опцией запроса) устанавливает верхнюю границу на объеме памяти, который может удерживать итератор одного плана запроса. (Это ограничение распространяется на конкретные итераторы, которые `join`не потокового по своей природе, таких как .) Вот несколько сообщений об ошибках, которые будут возвращены, когда это произойдет:

```
The ClusterBy operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete E_RUNAWAY_QUERY.

The DemultiplexedResultSetCache operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The ExecuteAndCache operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The HashJoin operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The Sort operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The Summarize operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The TopNestedAggregator operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).

The TopNested operator has exceeded the memory budget during evaluation. Results may be incorrect or incomplete (E_RUNAWAY_QUERY).
```

По умолчанию это значение устанавливается на 5 ГБ. Можно увеличить это значение до половины физической памяти машины:

```kusto
set maxmemoryconsumptionperiterator=68719476736;
MyTable | ...
```

При рассмотрении вопроса об удалении этих ограничений сначала определите, действительно ли вы получаете какое-либо значение. В частности, удаление лимита усечения результатов означает, что вы намереваетесь перемещать объемные данные из `.export` Кусто - либо в экспортных целях (в этом случае вам настоятельно рекомендуется использовать команду), либо для последующей агрегации (в этом случае рассмотреть возможность агрегирования с помощью Kusto).
Сообщите команде Kusto, если у вас есть бизнес-сценарий, который не может быть выполнен ни одним из этих предлагаемых решений.  

Во многих случаях превышения этого предела можно избежать путем выборки данных, установленных до 10%. В двух приведенных ниже запросах показано, как выполнять эту выборку. Во-первых, это статистическая выборка (с использованием генератора случайных чисел). Вторая – детерминированная выборка (путем хэширования некоторых столбцов из набора данных, обычно некоторых идентификаторов):

```kusto
T | where rand() < 0.1 | ...

T | where hash(UserId, 10) == 1 | ...
```

## <a name="limit-on-memory-per-node"></a>Ограничение памяти на узла

**Максимальная память на запрос на узла** — это еще одно ограничение, используемое Kusto для защиты от «беглых» запросов. Это ограничение (представленное `max_memory_consumption_per_query_per_node`опцией запроса) устанавливает верхнюю границу на объеме памяти, которое может быть выделено на одном узлах для конкретного запроса. 


```kusto
set max_memory_consumption_per_query_per_node=68719476736;
MyTable | ...
```

## <a name="limit-on-accumulated-string-sets"></a>Ограничение на накопленные наборы строк

В различных операциях запросов Kusto необходимо «собрать» значения строки и буферизировать их внутренне, прежде чем он сможет начать производить результаты. Эти накопленные наборы строк ограничены по размеру и в том, сколько элементов они могут содержать. Кроме того, каждая отдельная строка не может превышать определенный предел.
Превышение одного из этих ограничений приведет к одной из следующих ошибок:

```
Runaway query (E_RUNAWAY_QUERY). (message: 'Accumulated string array getting too large and exceeds the limit of ...GB (see https://aka.ms/kustoquerylimits)')

Runaway query (E_RUNAWAY_QUERY). (message: 'Accumulated string array getting too large and exceeds the maximum count of 2G items (see http://aka.ms/kustoquerylimits)')

Runaway query (E_RUNAWAY_QUERY). (message: 'Single string size shouldn't exceed the limit of 2GB (see http://aka.ms/kustoquerylimits)')
```

В настоящее время нет переключателя для увеличения максимального размера набора строк.
В качестве обходного пути перефразируйте запрос, чтобы уменьшить объем данных, которые должны быть буферизированы. Например, проецируя ненужные столбцы до того, как они «вводят» операторов, таких как соединение и обобщение. Или, например, с помощью стратегии [тасовки запроса.](../query/shufflequery.md)

## <a name="limit-on-request-execution-time-timeout"></a>Ограничение времени выполнения запроса (тайм-аут)

**Тайм-аут сервера** — это тайм-аут в сторону обслуживания, который применяется ко всем запросам.
Тайм-аут при запуске запросов (запросы и команды управления) обеспечивается в нескольких точках:

* В клиентской библиотеке Kusto (при использовании)
* В конечном пункте службы Kusto, которая принимает запрос
* В сервисном движке Kusto, который обрабатывает запрос

По умолчанию тайм-аут устанавливается на четыре минуты для запросов и десять минут для команд управления. Это значение может быть увеличено в случае необходимости (ограничено в один час):

* Если вы задаете запрос с помощью **Options** *  &gt; Kusto.Explorer, используйте **Connections** &gt; **Timeout** **Tools** &gt;
* Программно установите свойство запроса `servertimeout` клиента (значение типа, `System.TimeSpan`до часа).

Заметки о тайм-аутах:

* На стороне клиента тайм-аут применяется из создаваемого запроса до момента, когда ответ начинает поступать к клиенту. Время, необходимое для чтения полезной нагрузки обратно на клиента не рассматривается как часть тайм-аута (потому что это зависит от того, как быстро абонент вытаскивает данные из потока).
* Кроме того, на стороне клиента, фактическое значение тайм-аута используется немного выше, чем сервер время отогиваемых значение, запрошенное пользователем. Это необходимо для обеспечения просеченности сети.
* Что делать, то не все операторы запросов соблюдают значение тайм-аута.
   Мы постепенно добавляем эту поддержку.
* Чтобы Kusto автоматически использовал максимально допустимый тайм-аут `norequesttimeout` `true`запроса, установите свойство запроса клиента.

<!--
  Request timeout can also be set using a set statement, but we don't mention
  it here as it should not be used in production scenarios.
-->

## <a name="limit-on-query-cpu-resource-usage"></a>Ограничение на использование ресурсов процессора запроса

По умолчанию Kusto позволяет выполнять запросы для использования столько ресурсов процессора, сколько кластер, пытаясь сделать справедливый круговой круг между запросами, если работает более одного. Во многих случаях это дает наилучшую производительность для специальных запросов.
В других случаях можно ограничить ресурсы процессора, выделенные для конкретного запроса. Например, если один из них работает "фоновая работа", можно терпеть более высокие прослушка, с тем чтобы дать одновременные специальные запросы высокой приоритетной задачей.

Поддержка Kusto, определяющая два [свойства запроса клиента](../api/netfx/request-properties.md) при запуске запроса, **query_fanout_threads_percent** и **query_fanout_nodes_percent.**
Оба являются неопределенными, которые по умолчанию до максимального значения (100), но могут быть сокращены для конкретного запроса до некоторого значения. Первый управляет фактором фанаута для использования потока; когда это 100% кластер будет назначить все процессоры на каждом узел (например, на кластере, развернутом на узлах Azure D14, 16 процессоров) к запросу, когда это 50%, чем половина процессоров будет использоваться, и т.д. (Числа округлены до всего процессора, так что это безопасно установить его на 0.) Второй контролирует, сколько узлов в кластере использовать на одну операцию распределения подзапросов, и функционирует аналогичным образом.

## <a name="limit-on-query-complexity"></a>Ограничение сложности запроса

Во время выполнения запроса текст запроса преобразуется в дерево реляционных операторов, представляющих запрос.
В случае, если глубина дерева превышает внутренний порог (несколько тысяч уровней), запрос считается слишком сложным для обработки и сбой с кодом ошибки, указывающим на то, что дерево реляционных операторов превышает пределы.
В большинстве случаев это вызвано запросом, который содержит длинный список бинарных операторов, прикованных друг к другу, например:

```kusto
T 
| where Column == "value1" or 
        Column == "value2" or 
        .... or
        Column == "valueN"
```

Для этого конкретного случая - рекомендуется переписать [`in()`](../query/inoperator.md) запрос с помощью оператора. 

```kusto
T 
| where Column in ("value1", "value2".... "valueN")
```